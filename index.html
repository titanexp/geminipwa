//+------------------------------------------------------------------+
//| GridTrapEA2_Final_Recycle_Norm_HedgePlus_AdxFix_v42_3Filters.mq5  |
//| - GridTrapEA 完全修正版 v31 ベース                                |
//| - [Add] ZigZag Breakout/SL ロジック (v32, v33)                    |
//| - [Add] SMAフィルタの設定を分離 (v34)                             |
//| - [Add] ZigZagの時間足をEntry/SLで個別に設定可能に変更 (v35)           |
//| - [Mod] ZigZagエントリーとMA等の併用を可能にする修正                   |
//| - [Add] ZigZag SLを「最も有利なポジション」のみに適用する機能を追加       |
//| - [Mod] 各種SMA機能をEMA等に変更可能なオプションを追加 (v36)           |
//| - [Add] MAの選択肢にVWAP(VWMA)を追加 (v37)                        |
//| - [Add] 指定日エントリー除外機能を追加 (v38)                        |
//| - [Add] 口座ドローダウンによる緊急精算＆一時停止機能を追加 (v39)        |
//| - [Add] DD保護時に「全決済」か「完全両建て」か選べる機能を追加 (v40)      |
//| - [Mod] 逆張り(Normal)と順張り(Trend)の制御を独立化 (v41)             |
//| - [Add] ADXフィルタを3種類(A/B/C)に拡張 (v42)                      |
//+------------------------------------------------------------------+
#property strict
#include <Trade\Trade.mqh>

//--- マジックナンバー定義
#define MAGIC_GRID  444444
#define MAGIC_HEDGE 333333
#define MAGIC_TREND 444445

//--- 定数
#define ONEDAY (3600 * 24)
#define SUNDAY 0
#define FRIDAY 5

//--- Enum定義
enum ENUM_GRID_DIRECTION { DIR_BOTH=0, DIR_BUY_ONLY=1, DIR_SELL_ONLY=2 };
enum ENUM_ORDER_MODE     { MODE_LIMIT=0, MODE_STOP=1 };
enum ENUM_HEDGE_MANUAL_MODE { HEDGE_ON_TRACKING=0, HEDGE_ON_STOP=1 };
enum ENUM_ANCHOR_TYPE { ANCHOR_YEARLY, ANCHOR_MONTHLY, ANCHOR_WEEKLY, ANCHOR_DAILY_ETH, ANCHOR_SESSION_RTH, ANCHOR_H4, ANCHOR_H1 };
enum ENUM_AVWAP_BAND_MODE { BAND_MODE_NONE=0, BAND_MODE_AVOID_OUTSIDE=1, BAND_MODE_REQUIRE_OUTSIDE=2 };
// [v37] 拡張MAタイプ定義
enum ENUM_MA_TYPE_EXT { 
   MA_TYPE_SMA  = 0, // SMA (Simple)
   MA_TYPE_EMA  = 1, // EMA (Exponential)
   MA_TYPE_SMMA = 2, // SMMA (Smoothed)
   MA_TYPE_LWMA = 3, // LWMA (Linear Weighted)
   MA_TYPE_VWMA = 4  // VWAP/VWMA (Volume Weighted)
};
// [v40] DDアクション定義
enum ENUM_DD_ACTION {
   DD_ACTION_CLOSE_ALL  = 0, // 全ポジション決済 (Close All)
   DD_ACTION_FULL_HEDGE = 1  // 完全両建てロック (Full Hedge Lock)
};

enum ENUM_MA_METHOD_CUSTOM { MODE_SMA_C=0, MODE_EMA_C=1, MODE_SMMA_C=2, MODE_LWMA_C=3 };
enum ENUM_GRID_STEP_MODE { STEP_MODE_FIXED=0, STEP_MODE_ATR=1, STEP_MODE_ADX=2 };
enum ENUM_CALC_UNIT { UNIT_POINT=0, UNIT_PERCENT=1 };
enum ENUM_SPLIT_MODE { SPLIT_FIXED_COUNT=0, SPLIT_AUTO_BALANCE=1 };

//+------------------------------------------------------------------+
//| 入力パラメータ                                                     |
//+------------------------------------------------------------------+
//--- 手動制御
input group "=== ⑧ 手動制御 (Manual Control) ==="
input bool   InpFreezeAndClearOrders = false;        // [Freeze] 注文全消去＆新規停止 (保有ポジは維持)

//--- 基本戦略（グリッド設定）
input group "=== ①-A 基本戦略（通常時/レンジ設定） ==="
input ENUM_GRID_DIRECTION InpDirectionMode   = DIR_SELL_ONLY;// 売買方向 (買いのみ/売りのみ/両方)
input ENUM_ORDER_MODE     InpOrderMode       = MODE_LIMIT;  // 注文方式 (指値=逆張り / 逆指値=順張り)
input double              InpLotSize         = 0.01;        // [固定] 基準ロット数 (自動OFF時)
input double              InpLotMultiplier   = 1.0;         // ロット倍率 (1.0=単利 / 1.0超=マーチン)
input int                 InpMaxOrders       = 10;          // 最大グリッド段数 (片側あたり)
input double              InpGridStepMultiplier = 1.0;      // 間隔の倍率 (1.0=等間隔, >1.0=拡大)
input bool                InpEnableTPMultiplier = true;    // 利確幅にも倍率を適用する

//--- グリッド中心設定
input group "=== ①-A-2 グリッド中心設定 (Center Price Option) ==="
input bool            InpUseCenterMA       = true;       // [Center] 現在価格ではなくMAを中心にグリッドを組む
input ENUM_MA_TYPE_EXT InpCenterMAMethod   = MA_TYPE_SMA;// [Center] MA種別 (SMA/EMA/VWMA等)
input int             InpCenterMAPeriod    = 20;         // [Center] 基準MAの期間
input ENUM_TIMEFRAMES InpCenterMATimeframe = PERIOD_M2;  // [Center] 基準MAの時間足

//--- ZigZagエントリー & SL (New)
input group "=== ①-H ZigZag Entry/SL (Option) ==="
input bool   InpUseZigZagEntry = false;      // [ZigZag] エントリー基準をZigZag頂点にする
input ENUM_TIMEFRAMES InpZigZagTimeframe_Entry = PERIOD_CURRENT; // [ZigZag] Entry判定の時間足 (New)
input bool   InpUseZigZagForSL = false;      // [ZigZag] 損切り(SL)基準をZigZag頂点にする
input ENUM_TIMEFRAMES InpZigZagTimeframe_SL    = PERIOD_CURRENT; // [ZigZag] SL判定の時間足 (New)
input int    InpZigZagDepth    = 12;         // [ZigZag] Depth
input int    InpZigZagDeviation= 5;          // [ZigZag] Deviation
input int    InpZigZagBackstep = 3;          // [ZigZag] Backstep
input double InpZigZagOffset   = 0;          // [ZigZag] Entryの頂点からのオフセット (Point)
input double InpZigZagSLOffset = 100;        // [ZigZag] SLの頂点からのオフセット (Point)

//--- 動的グリッド幅 (複合計算)
input group "=== ①-B 動的グリッド幅 (通常時) ==="
input ENUM_CALC_UNIT      InpStepUnit        = UNIT_PERCENT;  // [Unit] グリッド幅の指定単位 (Point/%)
input double              InpGridStep        = 0.15;         // [Base] 基準間隔 (Unit設定に従う)
input bool                InpUseATRGrid      = false;       // [ATR] ATR変動幅を適用する (Baseと比較して大きい方を採用)
input int                 InpAtrStepPeriod    = 14;         // [ATR] 計算期間
input ENUM_TIMEFRAMES     InpAtrStepTimeframe = PERIOD_H1;  // [ATR] 時間足
input double              InpAtrStepMultiplier= 0.5;        // [ATR] 倍率 (ATR × この値 = ポイント幅)
input bool                InpUseADXGrid      = false;       // [ADX] ADX(Filter A)でさらに拡大する
input double              InpAdxStepPower    = 0.01;        // [ADX] 拡大係数 (例:0.01 なら ADX40で +40%拡大)
input int                 InpMinGridStep     = 50;          // 計算結果の最小値 (Point固定)

//--- 資金管理 (自動ロット)
input group "=== ①-C 資金管理 (自動ロット計算) ==="
input bool   InpUseAutoLot    = true; // 自動ロット計算を使用する (True=ON)
input double InpBaseBalance   = 65000;// 基準となる資金量 (例: 100,000)
input double InpBaseLot       = 0.01;  // 基準資金あたりのロット数

//--- ロット減衰 (追加機能)
input group "=== ①-C-2 ロット減衰 (遠くの注文を小さく) ==="
input bool   InpUseLotDecay        = false; // [減衰] 遠くの注文ほどロットを減らす (True=ON)
input double InpLotDecayMultiplier = 0.8;   // [減衰] 減衰倍率 (例: 0.8 = 前の注文の80%サイズ)

//--- 定期リセット設定
input group "=== ①-D 定期リセット設定 (Periodic Reset) ==="
input bool   InpUsePeriodicReset  = true; // [Reset] 一定時間ごとにグリッドを再構築する (True=ON)
input int    InpGridResetInterval = 240;    // [Reset] 再構築の間隔 (分)

//--- クールダウン設定
input group "=== ①-E クールダウン設定 (Cool Down) ==="
input bool   InpUseCoolDown      = true;  // [Cool] 約定後に一定時間エントリーを停止する (True=ON)
input int    InpCoolDownMinutes  = 1080;      // [Cool] 停止時間 (分)

//--- 分割エントリー
input group "=== ①-F 分割エントリー設定 (Multiple Positions) ==="
input bool            InpEnableSplitEntry = false;          // [Split] 同一注文を複数回発行する機能を使う
input ENUM_SPLIT_MODE InpSplitMode        = SPLIT_FIXED_COUNT; // [Split] 数の決定方法
input int             InpFixedSplitCount  = 2;              // [Split] 固定数 (例: 2なら常に2つずつ)
input double          InpSplitBalanceUnit = 100000;         // [Split] 自動計算時の単位資金 (例: 10万円につき1つ)
input int             InpMaxSplitLimit    = 20;             // [Split] 安全装置：最大分割数

//--- リピート機能 (New)
input group "=== ①-G リピート機能 (Single Repeat) ==="
input bool   InpEnableRecycle     = false;      // [Repeat] 利確されたグリッドを単体で補充する
input bool   InpRecycleUseNewMA   = false;      // [Repeat] 補充時、アンカーを維持せずMA等で引き直す（※通常はFalse推奨）

//--- 決済・安全装置
input group "=== ② 決済・安全装置 (通常時) ==="
input ENUM_CALC_UNIT      InpTpSlUnit        = UNIT_PERCENT;  // [Unit] TP/SLの指定単位 (Point/%)
input double              InpGridTakeProfit  = 3.2;         // 利確幅 (Unit設定に従う)
input double              InpGridStopLoss    = 0;           // 損切り幅 (0=無効 / Unit設定に従う)

// トレーリングストップ (Pct Only)
input bool                InpUseTrailingStop   = false;     // トレーリングストップ(TS)を使う
input double              InpStartTrailingStop = 1.5;       // [TS] 開始する利益幅 (%)
input double              InpTrailingDistance  = 0.2;       // [TS] 追従する距離 (%)
input double              InpTrailingStep      = 0.1;       // [TS] 更新幅 (%)

// ブレイクイーブン (通常時)
input bool                InpUseBreakEven      = false;     // [BE] ブレイクイーブン機能を使う
input double              InpBreakEvenTrigger  = 2.0;       // [BE] 発動する利益幅 (%)
input double              InpBreakEvenMargin   = 0.05;      // [BE] 建値への加算幅 (%)

//--- 自動追尾・緊急停止
input group "=== ③ 自動追尾・緊急停止システム ==="
input ENUM_CALC_UNIT      InpSafetyUnit      = UNIT_PERCENT;  // [Unit] 追尾・停止幅の指定単位 (Point/%)
input double InpRangeThreshold    = 2.5;         // [追尾] グリッド再構築の判定幅 (Unit設定に従う)
input bool   InpUseMaxRangeStop   = false;       // [緊急] 最大レンジ逸脱で強制停止する
input double InpMaxRangePoints    = 2000;        // [緊急] 許容する最大レンジ幅 (Unit設定に従う)

// [重要] 勝手な決済を防ぐための安全スイッチ
input bool   InpCloseProfitOnStop = false;       // [Safety] 停止時に「含み益」を決済する (False=維持する)
input bool   InpCloseLossOnStop   = false;       // [Safety] 停止時に「含み損」も決済する (False=維持する)

//--- ADX制御 (設定分離・3種類)
input group "=== ④-A1 ADX Filter A (Normal停止/Base Grid) ==="
input bool   InpUseAdxFilter_A      = true;        // [Filter A] 使用する
input ENUM_TIMEFRAMES InpFilterAdxTimeframe_A = PERIOD_M5; // [Filter A] 時間足
input int    InpFilterAdxPeriod_A   = 14;          // [Filter A] 計算期間
input double InpFilterAdxThreshold_A= 30.0;        // [Filter A] 停止判定ADX値

input group "=== ④-A2 ADX Filter B (Normal停止) ==="
input bool   InpUseAdxFilter_B      = false;       // [Filter B] 使用する
input ENUM_TIMEFRAMES InpFilterAdxTimeframe_B = PERIOD_M15;// [Filter B] 時間足
input int    InpFilterAdxPeriod_B   = 14;          // [Filter B] 計算期間
input double InpFilterAdxThreshold_B= 40.0;        // [Filter B] 停止判定ADX値

input group "=== ④-A3 ADX Filter C (Normal停止) ==="
input bool   InpUseAdxFilter_C      = false;       // [Filter C] 使用する
input ENUM_TIMEFRAMES InpFilterAdxTimeframe_C = PERIOD_H1; // [Filter C] 時間足
input int    InpFilterAdxPeriod_C   = 14;          // [Filter C] 計算期間
input double InpFilterAdxThreshold_C= 50.0;        // [Filter C] 停止判定ADX値

input group "=== ④-B ADX Trend Trigger (順張りへの切り替え) ==="
input bool   InpSwitchToTrendOnADX= true;       // ADX高騰時に「順張り(逆指値)」に切り替える機能ON
input ENUM_TIMEFRAMES InpTrendAdxTimeframe = PERIOD_MN1; // [Trend] 時間足 (専用設定)
input int    InpTrendAdxPeriod    = 14;          // [Trend] 計算期間 (専用設定)
input double InpTrendAdxThreshold = 40.0;        // [Trend] 発動判定ADX値
input int    InpTrendHoldMinutes  = 480;          // [Trend] ★モード切り替え後の最低維持時間(分)

//--- トレンドモード専用設定
input group "=== ④-C トレンドモード専用設定 (順張り時) ==="
input double InpTrendGridStep       = 1.0;   // [Trend] グリッド間隔 (Unit準拠)
input double InpTrendStepMultiplier = 1.5;   // [Trend] 間隔倍率
input double InpTrendTakeProfit     = 1.0;   // [Trend] 利確幅 (Unit準拠)
input double InpTrendStopLoss       = 0.0;   // [Trend] 損切り幅 (Unit準拠)
input double InpTrendLotMultiplier  = 1.0;   // [Trend] ロット倍率
input int    InpTrendMaxOrders      = 5;     // [Trend] 最大注文数 (片側)

// [New] トレンド専用ブレイクイーブン
input bool   InpTrendUseBreakEven     = true;  // [Trend] 専用ブレイクイーブンを使う
input double InpTrendBreakEvenTrigger = 1.0;   // [Trend] 発動する利益幅 (%)
input double InpTrendBreakEvenMargin  = 0.05;  // [Trend] 建値への加算幅 (%)

//--- 基本フィルター (時間・曜日・MA/VWMA)
input group "=== ⑤-A MA Filter (Normal/Range) ==="
input bool   InpUseMAFilter_Normal    = true;       // [MA-N] 通常時のトレンドフィルタ
input ENUM_MA_TYPE_EXT InpMAMethod_Normal = MA_TYPE_SMA; // [MA-N] MA種別 (SMA/EMA/VWMA等)
input int    InpMAPeriod_Normal       = 20;         // [MA-N] 計算期間
input ENUM_TIMEFRAMES InpMATF_Normal  = PERIOD_M2;  // [MA-N] 時間足

input group "=== ⑤-B MA Filter (ADX Trend) ==="
input bool   InpUseMAFilter_Trend     = false;       // [MA-T] トレンドモード時のフィルタ
input ENUM_MA_TYPE_EXT InpMAMethod_Trend  = MA_TYPE_SMA;  // [MA-T] MA種別 (SMA/EMA/VWMA等)
input int    InpMAPeriod_Trend        = 20;          // [MA-T] 計算期間
input ENUM_TIMEFRAMES InpMATF_Trend   = PERIOD_MN1;  // [MA-T] 時間足

input group "=== ⑤-C その他フィルター (共通) ==="
input bool   InpUseTimeFilter         = false;        // [時間] 取引時間を制限する (日本時間)
input int    InpTradeStartHourJST     = 9;           // [時間] 取引開始時 (時)
input int    InpTradeEndHourJST       = 1;           // [時間] 取引終了時 (時)
input bool   InpNoEntryOnFriday       = false;       // [曜日] 金曜日は新規グリッドを禁止する

// [New] 指定日エントリー除外機能
input group "=== ⑤-D 特定日エントリー除外 (Specific Date Filter) ==="
input string InpNoEntryDates_Normal = ""; // [Normal] 除外日 (例: 2025.12.25, 2026.01.01)
input string InpNoEntryDates_Trend  = ""; // [Trend]  除外日 (例: FOMCの日など)

//--- ヘッジ機能 (上級者向け)
input group "=== ⑥ ヘッジ機能 (上級者向け) ==="
input bool   InpUseAdxHedge       = false;       // [Hedge] ADX高騰時にヘッジを入れる
input ENUM_TIMEFRAMES InpHedgeAdxTimeframe = PERIOD_D1; // [Hedge] ADX時間足
input int             InpHedgeAdxPeriod    = 14;        // [Hedge] ADX期間
input double InpAdxHedgeThreshold = 25.0;        // [Hedge] ヘッジ開始ADX値
input double InpAdxHedgeExit      = 20.0;        // [Hedge] ヘッジ終了ADX値
input bool   InpUseManualHedge    = false;       // [Hedge] 追尾・停止時にヘッジを入れる
input ENUM_HEDGE_MANUAL_MODE InpHedgeManualMode = HEDGE_ON_STOP; // [Hedge] 発動タイミング
input bool   InpUseAutoHedgeLot   = true;        // [Hedge] ロットを自動計算する (差分ロット)
input double InpAutoLotMultiplier = 1.0;         // [Hedge] 自動ロット倍率
input double InpManualHedgeLot    = 0.05;        // [Hedge] 固定ロットの場合の数量
input ENUM_CALC_UNIT InpHedgeTpSlUnit = UNIT_PERCENT; // [Hedge] SL/TP単位 (Point/%)
input double InpHedgeSL           = 0;           // [Hedge] ヘッジSL (Unit設定に従う)
input double InpHedgeTP           = 2.0;           // [Hedge] ヘッジTP (Unit設定に従う)

// [New] ヘッジ専用ブレイクイーブン
input bool   InpHedgeUseBreakEven     = true;  // [Hedge] 専用ブレイクイーブンを使う
input double InpHedgeBreakEvenTrigger = 1.0;   // [Hedge] 発動する利益幅 (%)
input double InpHedgeBreakEvenMargin  = 0.05;  // [Hedge] 建値への加算幅 (%)

//--- 高度なフィルター (初期値OFF)
input group "=== ⑦ 高度なフィルター (初期値OFF) ==="
// US流
input bool   InpUseSolidCandleFilter  = false;       // [US流] 実体率判定 (ヒゲ回避)
input double InpSolidBodyRatio        = 0.6;         // [US流] 実体率のしきい値
input bool   InpUseMarginCallFilter   = false;       // [US流] NYマージンコール時間帯回避
input int    InpMC_StartHourSrv       = 20;          // [US流] 回避開始 (サーバー時間)
input int    InpMC_EndHourSrv         = 21;          // [US流] 回避終了 (サーバー時間)
// 桃流
input bool   InpUseGapFilter          = false;       // [桃流] 窓埋め警戒 (Gap Filter)
input double InpGapThresholdATR       = 1.5;         // [桃流] 窓判定のATR倍率
input bool   InpUsePivotFilter        = false;       // [桃流] Pivotライン直前回避
input int    InpPivotBufferPoints     = 100;         // [桃流] Pivot回避幅 (Point)
input bool   InpUse3DayRule           = false;       // [桃流] 3日間ルール (急変動後の待機)
input int    Inp3DayLookbackBars      = 72;          // [桃流] 監視期間 (バー本数)
input double Inp3DayVolThreshold      = 3.0;         // [桃流] 変動判定ATR倍率
input bool   InpUseTTMSqueeze         = false;       // [桃流] TTM Squeeze (スクイーズ中は停止)
input int    InpTTM_Period            = 20;          // [桃流] TTM 計算期間
input bool   InpUseCMFFilter          = false;       // [桃流] CMF (資金流出入判定)
input int    InpCMF_Period            = 20;          // [桃流] CMF 計算期間
input double InpCMF_Threshold         = 0.0;         // [桃流] CMF 判定ライン
input bool   InpUse21EMAFilter        = false;       // [桃流] 21EMAフィルタ
input double Inp21EMABufferPoints     = 10.0;        // [桃流] 21EMAバッファ
input bool   InpUseWoodiesFilter      = false;       // [桃流] Woodies CCI
input int    InpWCCI_Period           = 14;          // [桃流] CCI期間
input bool   InpUseMomoMAFilter       = false;       // [桃流] 追加MAフィルタ
input ENUM_MA_METHOD_CUSTOM InpMomoMAMethod = MODE_EMA_C; // [桃流] MA種類
input int    InpMomoMAPeriod          = 100;         // [桃流] MA期間
input ENUM_TIMEFRAMES InpMomoMATimeframe = PERIOD_H4;// [桃流] MA時間足
input bool   InpUseZVRFilter          = false;       // [ZVR] 出来高(Volume)フィルタ
input double InpZVR_ThresholdPct      = 80.0;        // [ZVR] しきい値(%)
// AVWAP
input bool   InpUseAnchoredVWAP       = false;       // [AVWAP] アンカーVWAPフィルタ
input bool   InpAVWAP_TrendFollow     = true;        // [AVWAP] 順張りロジック (True=順張り)
input int    InpAVWAP_Confluence      = 3;           // [AVWAP] 何個合致すれば許可するか
input bool   InpAVWAP_Yearly          = false;       // [AVWAP] 年次 (Yearly)
input bool   InpAVWAP_Monthly         = false;       // [AVWAP] 月次 (Monthly)
input bool   InpAVWAP_Weekly          = true;        // [AVWAP] 週次 (Weekly)
input bool   InpAVWAP_Daily           = true;        // [AVWAP] 日次 (Daily)
input bool   InpAVWAP_H4              = true;        // [AVWAP] 4時間 (H4)
// その他
input bool   InpUsePerfectOrder       = false;       // [PO] パーフェクトオーダー判定
input ENUM_MA_TYPE_EXT InpPerfectOrderMethod = MA_TYPE_SMA; // [PO] MA種別 (SMA/EMA/VWMA等)
input bool   InpUseTrlBslFilter       = false;       // [Line] TRL/BSL (ZigZagライン回避)
input ENUM_TIMEFRAMES InpTrlBslTimeframe = PERIOD_H4;// [Line] 計算時間足
input int    InpTrlBslDepth           = 24;          // [Line] Depth
input int    InpTrlBslDeviation       = 5;           // [Line] Deviation
input int    InpTrlBslBackstep        = 3;           // [Line] Backstep
input double InpLineAvoidThreshold    = 0.1;         // [Line] 接近回避しきい値(%)

// [New] DD保護設定
input group "=== ⑨ 口座ドローダウン保護 (Account Protection) ==="
input bool   InpUseDDProtection    = false; // [DD] DD保護機能を使う
input double InpMaxDDPercent       = 40.0;  // [DD] 許容最大ドローダウン (%)
input int    InpDDPauseHours       = 24;    // [DD] 精算/ロック後の停止時間 (時間)
input ENUM_DD_ACTION InpDDAction   = DD_ACTION_CLOSE_ALL; // [DD] 保護時の動作 (全決済 or 両建て)


//--- グローバル変数
CTrade g_trade;
double g_gridCenterPrice = 0.0;    // 現在のグリッドセンター(計算用)
double g_fixedAnchorPrice = 0.0;   // 固定されたグリッドセンター(ロック用)
double g_fixedAnchorBuy = 0.0;     // [ZigZag] 買い用アンカー
double g_fixedAnchorSell = 0.0;    // [ZigZag] 売り用アンカー
double g_fixedSLBuy = 0.0;         // [ZigZag] 買い用SL (v33)
double g_fixedSLSell = 0.0;        // [ZigZag] 売り用SL (v33)

bool   g_isHedgeActive = false;
bool   g_isEmergencyStopped = false;
datetime g_lastGridResetTime = 0; 
datetime g_latestPositionTime = 0; // 最新のポジション約定時間
bool   g_currentGridIsTrend = false; // 現在展開中のグリッドがトレンドモードかどうか
datetime g_trendLastHighTime = 0;    // [New] 最後にトレンドADXが閾値を超えた時間
bool   g_isTodayRestricted = false;  // [New] 今日が除外日かどうか

// DD保護用
bool     g_isDDStopped = false;      // DD保護による停止フラグ
datetime g_ddStopStartTime = 0;      // 停止開始時間

// インジケータハンドル
// [Mod] Filter用ハンドルの配列化(管理しやすくするため個別変数定義)
int g_filterAdxHandle_A = INVALID_HANDLE;
int g_filterAdxHandle_B = INVALID_HANDLE;
int g_filterAdxHandle_C = INVALID_HANDLE;

int g_trendAdxHandle  = INVALID_HANDLE;
int g_hedgeAdxHandle  = INVALID_HANDLE; 
int g_maNormalHandle = INVALID_HANDLE; 
int g_maTrendHandle  = INVALID_HANDLE; 
int g_21emaHandle = INVALID_HANDLE;
int g_momoMaHandle = INVALID_HANDLE;
int g_wcciHandle = INVALID_HANDLE;
int g_atrHandle = INVALID_HANDLE;
int g_ttm_bbHandle = INVALID_HANDLE;
int g_ttm_maHandle = INVALID_HANDLE;
int g_poMA1 = INVALID_HANDLE, g_poMA2 = INVALID_HANDLE, g_poMA3 = INVALID_HANDLE, g_poMA4 = INVALID_HANDLE, g_poMA5 = INVALID_HANDLE; 
int g_trlZigZagHandle = INVALID_HANDLE;
int g_centerMaHandle = INVALID_HANDLE;
int g_zigzagEntryHandle = INVALID_HANDLE; // [New] ZigZag Entry用
int g_zigzagSLHandle    = INVALID_HANDLE; // [New] ZigZag SL用

// TRL/BSL 計算用
double g_trlSlope=0, g_trlIntercept=0, g_bslSlope=0, g_bslIntercept=0;
bool g_trlValid=false, g_bslValid=false;
datetime g_lastTrlCalcTime = 0;

// 前方宣言
void UpdateVisuals();
void DrawLabel(string name, string text, int x, int y, color clr, int fontSize=10, bool bold=false);
void DrawHLine(string name, double price, color clr, ENUM_LINE_STYLE style, int width);
void DeleteAllPendingOrders(long targetMagic = -1); // 一括削除用関数 (引数追加)

//+------------------------------------------------------------------+
//| ヘルパー関数群                                                    |
//+------------------------------------------------------------------+
bool IsTradingAllowedTimeJST()
{
   if(!InpUseTimeFilter) return true;
   datetime serverNow = TimeCurrent();
   datetime jstNow = serverNow - (3 * 3600) + (9 * 3600); // 簡易GMT+3
   MqlDateTime dt; TimeToStruct(jstNow, dt);
   int curMin = dt.hour * 60 + dt.min;
   int startMin = InpTradeStartHourJST * 60;
   int endMin = InpTradeEndHourJST * 60;
   if(startMin == endMin) return true;
   if(startMin < endMin) return (curMin >= startMin && curMin < endMin);
   else return (curMin >= startMin || curMin < endMin);
}

// [New] 指定された日付リストに今日が含まれているか確認する関数
bool IsRestrictedDate(string dateList)
{
   if(dateList == "") return false;
   
   string today = TimeToString(TimeCurrent(), TIME_DATE); // Format: "yyyy.mm.dd"
   string dates[];
   int count = StringSplit(dateList, ',', dates);
   
   for(int i=0; i<count; i++) {
      string d = dates[i];
      StringTrimLeft(d); StringTrimRight(d);
      
      // 区切り文字のゆらぎ吸収 (-, / -> .)
      StringReplace(d, "-", ".");
      StringReplace(d, "/", ".");
      
      if(d == today) return true;
   }
   return false;
}

double GetADXValue(int handle)
{
   if(handle == INVALID_HANDLE) return 0.0;
   double buf[]; ArraySetAsSeries(buf, true);
   if(CopyBuffer(handle, 0, 0, 1, buf) <= 0) return 0.0;
   return buf[0];
}

double GetATR(ENUM_TIMEFRAMES tf, int period)
{
   int h = iATR(_Symbol, tf, period);
   if(h == INVALID_HANDLE) return 0.0;
   double buf[]; ArraySetAsSeries(buf, true);
   if(CopyBuffer(h, 0, 1, 1, buf) <= 0) { IndicatorRelease(h); return 0.0; }
   IndicatorRelease(h);
   return buf[0];
}

// [v37] 汎用MA値取得関数 (VWAP/VWMA対応)
// VWMAの場合、ハンドルを使用せずその場で計算する
double GetMAValue(int handle, ENUM_MA_TYPE_EXT type, ENUM_TIMEFRAMES tf, int period)
{
   if(type == MA_TYPE_VWMA) {
      // VWMA (Rolling VWAP) 計算
      // Formula: Sum(Price * Volume) / Sum(Volume)
      MqlRates rates[];
      ArraySetAsSeries(rates, true);
      // 最新のバーから期間分取得
      if(CopyRates(_Symbol, tf, 0, period, rates) < period) return 0.0;
      
      double sumPV = 0.0;
      double sumV  = 0.0;
      
      for(int i=0; i<period; i++) {
         double price = rates[i].close; // Close価格を使用
         double vol   = (double)rates[i].tick_volume;
         sumPV += price * vol;
         sumV  += vol;
      }
      
      return (sumV > 0) ? (sumPV / sumV) : 0.0;
   }
   else {
      // SMA, EMA, SMMA, LWMA (ハンドル使用)
      if(handle == INVALID_HANDLE) return 0.0;
      double buf[]; ArraySetAsSeries(buf, true);
      if(CopyBuffer(handle, 0, 0, 1, buf) <= 0) return 0.0;
      return buf[0];
   }
}

double GetAbsoluteDistance(ENUM_CALC_UNIT unit, double val, double price)
{
   if(val <= 0) return 0.0;
   
   if(unit == UNIT_PERCENT) {
      // パーセントモード: 価格の X% を計算
      return price * (val / 100.0);
   } else {
      // ポイントモード: ポイント値を価格幅に変換
      return val * SymbolInfoDouble(_Symbol, SYMBOL_POINT);
   }
}

// [New] 価格の正規化（丸め処理）関数
double NormalizePrice(double price)
{
   int digits = (int)SymbolInfoInteger(_Symbol, SYMBOL_DIGITS);
   return NormalizeDouble(price, digits);
}

// 分割エントリー数を計算する関数
int GetSplitCount()
{
   if(!InpEnableSplitEntry) return 1;
   
   int count = 1;
   if(InpSplitMode == SPLIT_FIXED_COUNT) {
      count = InpFixedSplitCount;
   } else if(InpSplitMode == SPLIT_AUTO_BALANCE) {
      double bal = AccountInfoDouble(ACCOUNT_BALANCE);
      if(InpSplitBalanceUnit > 0) {
         count = (int)MathFloor(bal / InpSplitBalanceUnit);
      }
   }
   
   if(count < 1) count = 1;
   if(count > InpMaxSplitLimit) count = InpMaxSplitLimit;
   
   return count;
}

// 全待機注文の一括削除関数 (引数で対象を指定可能に変更)
// magic = -1 なら全て削除、それ以外なら指定のマジックナンバーのみ削除
void DeleteAllPendingOrders(long targetMagic = -1)
{
   for(int i = OrdersTotal()-1; i >= 0; i--) {
      ulong ticket = OrderGetTicket(i);
      if(ticket > 0 && OrderSelect(ticket)) {
         long magic = OrderGetInteger(ORDER_MAGIC);
         // 対象のEAかつ、(全指定 or 特定のマジックナンバー一致)
         if( (magic == MAGIC_GRID || magic == MAGIC_TREND) && (targetMagic == -1 || magic == targetMagic) ) {
            g_trade.OrderDelete(ticket);
         }
      }
   }
}

//+------------------------------------------------------------------+
//| [New] ZigZag高値・安値の取得関数 (MTF対応版)                        |
//| - 指定したハンドルと時間足でHigh/Lowを探して返す                      |
//+------------------------------------------------------------------+
bool GetZigZagHighLow(int handle, ENUM_TIMEFRAMES tf, double &outHigh, double &outLow)
{
   if(handle == INVALID_HANDLE) return false;
   
   double zigBuf[]; ArraySetAsSeries(zigBuf, true);
   // 過去500バーから検索
   if(CopyBuffer(handle, 0, 0, 500, zigBuf) <= 0) return false;
   
   double foundHigh = 0;
   double foundLow = 0;
   
   for(int i=0; i<ArraySize(zigBuf); i++) {
      double zVal = zigBuf[i];
      if(zVal != 0 && zVal != EMPTY_VALUE) {
         // MTF対応のため iHigh/iLow にも tf を渡す
         double h = iHigh(_Symbol, tf, i);
         double l = iLow(_Symbol, tf, i);
         double c = iClose(_Symbol, tf, i);
         
         double margin = SymbolInfoDouble(_Symbol, SYMBOL_POINT) * 2;
         
         if(foundHigh == 0 && MathAbs(zVal - h) < margin) foundHigh = zVal;
         else if(foundHigh == 0 && zVal > c) foundHigh = zVal; // 簡易判定
         
         if(foundLow == 0 && MathAbs(zVal - l) < margin) foundLow = zVal;
         else if(foundLow == 0 && zVal < c) foundLow = zVal; // 簡易判定
         
         if(foundHigh != 0 && foundLow != 0) break;
      }
   }
   
   if(foundHigh > 0 && foundLow > 0) {
      outHigh = foundHigh;
      outLow = foundLow;
      return true;
   }
   return false;
}

//+------------------------------------------------------------------+
//| 指定したグリッドレベルの既存数を確認する (引数 magic 追加)            |
//+------------------------------------------------------------------+
int CountGridLevel(bool isBuy, int gridIndex, long targetMagic)
{
   int count = 0;
   string searchTag = StringFormat("GT_%s_%d", isBuy ? "B" : "S", gridIndex);
   
   // 待機注文をカウント
   for(int i=0; i<OrdersTotal(); i++) {
      ulong ticket = OrderGetTicket(i);
      if(ticket > 0 && OrderSelect(ticket) && OrderGetInteger(ORDER_MAGIC)==targetMagic) {
         string comment = OrderGetString(ORDER_COMMENT);
         if(StringFind(comment, searchTag) >= 0) count++;
      }
   }
   
   // 保有ポジションをカウント
   for(int i=0; i<PositionsTotal(); i++) {
      ulong ticket = PositionGetTicket(i);
      if(ticket > 0 && PositionSelectByTicket(ticket) && PositionGetInteger(POSITION_MAGIC)==targetMagic) {
         string comment = PositionGetString(POSITION_COMMENT);
         if(StringFind(comment, searchTag) >= 0) count++;
      }
   }
   return count;
}

//+------------------------------------------------------------------+
//| TRL/BSL (ZigZagライン) 計算                                       |
//+------------------------------------------------------------------+
void CalculateTrendLines()
{
   if(!InpUseTrlBslFilter || g_trlZigZagHandle == INVALID_HANDLE) return;
   
   int bars = 500;
   double zigBuf[]; ArraySetAsSeries(zigBuf, true);
   if(CopyBuffer(g_trlZigZagHandle, 0, 0, bars, zigBuf) <= 0) return;
   
   MqlRates rates[]; ArraySetAsSeries(rates, true);
   if(CopyRates(_Symbol, InpTrlBslTimeframe, 0, bars, rates) <= 0) return;

   double hVal[2]; datetime hTime[2]; int hCnt=0;
   double lVal[2]; datetime lTime[2]; int lCnt=0;

   for(int i=0; i<bars && (hCnt<2 || lCnt<2); i++) {
      double z = zigBuf[i];
      if(z!=0 && z!=EMPTY_VALUE) {
         if(MathAbs(z - rates[i].high) < Point()*0.5 && hCnt<2) {
            hVal[hCnt] = z; hTime[hCnt] = rates[i].time; hCnt++;
         }
         else if(MathAbs(z - rates[i].low) < Point()*0.5 && lCnt<2) {
            lVal[lCnt] = z; lTime[lCnt] = rates[i].time; lCnt++;
         }
      }
   }

   g_trlValid = false;
   if(hCnt==2 && hVal[0] < hVal[1]) {
      double x1 = (double)hTime[1], x2 = (double)hTime[0];
      if(x2!=x1) {
         g_trlSlope = (hVal[0] - hVal[1]) / (x2 - x1);
         g_trlIntercept = hVal[1] - g_trlSlope * x1;
         g_trlValid = true;
      }
   }
   g_bslValid = false;
   if(lCnt==2 && lVal[0] > lVal[1]) {
      double x1 = (double)lTime[1], x2 = (double)lTime[0];
      if(x2!=x1) {
         g_bslSlope = (lVal[0] - lVal[1]) / (x2 - x1);
         g_bslIntercept = lVal[1] - g_bslSlope * x1;
         g_bslValid = true;
      }
   }
}

//+------------------------------------------------------------------+
//| アンカーVWAP 計算                                                 |
//+------------------------------------------------------------------+
datetime GetAnchorTime(ENUM_ANCHOR_TYPE type)
{
   datetime now = TimeCurrent();
   MqlDateTime dt; TimeToStruct(now, dt);
   dt.min = 0; dt.sec = 0;
   if(type == ANCHOR_YEARLY) { dt.mon = 1; dt.day = 1; dt.hour = 0; }
   else if(type == ANCHOR_MONTHLY) { dt.day = 1; dt.hour = 0; }
   else if(type == ANCHOR_WEEKLY) { 
       dt.hour = 0; 
       return StructToTime(dt) - (dt.day_of_week * ONEDAY); 
   }
   else if(type == ANCHOR_DAILY_ETH) { dt.hour = 0; }
   else if(type == ANCHOR_H4) { dt.hour = (dt.hour/4)*4; }
   return StructToTime(dt);
}

double CalcAVWAP(datetime start)
{
   int startShift = iBarShift(_Symbol, PERIOD_M5, start);
   if(startShift < 0) return 0.0;
   int count = startShift + 1;
   MqlRates rates[]; ArraySetAsSeries(rates, true);
   if(CopyRates(_Symbol, PERIOD_M5, 0, count, rates) <= 0) return 0.0;
   
   double sumPV=0, sumV=0;
   for(int i=0; i<count; i++) {
       if(rates[i].time < start) break;
       double tp = (rates[i].high + rates[i].low + rates[i].close)/3.0;
       sumPV += tp * (double)rates[i].tick_volume;
       sumV += (double)rates[i].tick_volume;
   }
   return (sumV > 0) ? sumPV / sumV : 0.0;
}

//+------------------------------------------------------------------+
//| フィルター判定関数 (グリッド展開許可)                              |
//+------------------------------------------------------------------+
bool IsGridPlacementAllowed(bool isBuyGrid)
{
   if(InpNoEntryOnFriday) {
      MqlDateTime dt; TimeToStruct(TimeCurrent(), dt);
      if(dt.day_of_week == FRIDAY) return false;
   }
   if(!IsTradingAllowedTimeJST()) return false;
   if(InpUseMarginCallFilter) {
      MqlDateTime dt; TimeToStruct(TimeCurrent(), dt);
      if(dt.hour >= InpMC_StartHourSrv && dt.hour <= InpMC_EndHourSrv) return false;
   }
   double currentPrice = (isBuyGrid) ? SymbolInfoDouble(_Symbol, SYMBOL_ASK) : SymbolInfoDouble(_Symbol, SYMBOL_BID);

   // [Modified] MA Filter (Split Normal/Trend)
   bool useMA = false;
   int  maHandle = INVALID_HANDLE;
   ENUM_MA_TYPE_EXT maType;
   int maPeriod = 20;
   ENUM_TIMEFRAMES maTF = PERIOD_CURRENT;
   
   // 現在のモードに応じて設定を切り替え
   // [Fix] 独立動作対応: Normal用のチェックを行う場合は常にNormal設定を見る
   // Trend用フィルタが必要なら別途実装だが、ここではNormalフィルタとして実装する
   useMA = InpUseMAFilter_Normal;
   maHandle = g_maNormalHandle;
   maType   = InpMAMethod_Normal;
   maPeriod = InpMAPeriod_Normal;
   maTF     = InpMATF_Normal;

   if(useMA) {
      // [v37] GetMAValueで統一取得
      double maVal = GetMAValue(maHandle, maType, maTF, maPeriod);
      if(maVal > 0) {
          // ロジック: 買いなら価格 > MA, 売りなら価格 < MA で許可
          if(isBuyGrid && currentPrice < maVal) return false;
          if(!isBuyGrid && currentPrice > maVal) return false;
      }
   }

   if(InpUse21EMAFilter && g_21emaHandle != INVALID_HANDLE) {
      double ema[]; ArraySetAsSeries(ema, true);
      CopyBuffer(g_21emaHandle, 0, 0, 1, ema);
      double buffer = Inp21EMABufferPoints * SymbolInfoDouble(_Symbol, SYMBOL_POINT);
      if(isBuyGrid && currentPrice < (ema[0] + buffer)) return false;
      if(!isBuyGrid && currentPrice > (ema[0] - buffer)) return false;
   }
   if(InpUseWoodiesFilter && g_wcciHandle != INVALID_HANDLE) {
       double cci[]; ArraySetAsSeries(cci, true);
       CopyBuffer(g_wcciHandle, 0, 0, 1, cci);
       if(isBuyGrid && cci[0] < 0) return false;
       if(!isBuyGrid && cci[0] > 0) return false;
   }
   if(InpUseMomoMAFilter && g_momoMaHandle != INVALID_HANDLE) {
       double ma[]; ArraySetAsSeries(ma, true);
       CopyBuffer(g_momoMaHandle, 0, 0, 1, ma);
       if(isBuyGrid && currentPrice < ma[0]) return false;
       if(!isBuyGrid && currentPrice > ma[0]) return false;
   }
   if(InpUsePerfectOrder) {
       // [v37] GetMAValueで統一取得
       double s1 = GetMAValue(g_poMA1, InpPerfectOrderMethod, PERIOD_CURRENT, 5);
       double s2 = GetMAValue(g_poMA2, InpPerfectOrderMethod, PERIOD_CURRENT, 10);
       double s3 = GetMAValue(g_poMA3, InpPerfectOrderMethod, PERIOD_CURRENT, 20);
       double s4 = GetMAValue(g_poMA4, InpPerfectOrderMethod, PERIOD_CURRENT, 50);
       double s5 = GetMAValue(g_poMA5, InpPerfectOrderMethod, PERIOD_CURRENT, 100);

       bool poBuy = (s1>s2 && s2>s3 && s3>s4 && s4>s5 && s1>0);
       bool poSell = (s1<s2 && s2<s3 && s3<s4 && s4<s5 && s1>0);
       if(isBuyGrid && !poBuy) return false;
       if(!isBuyGrid && !poSell) return false;
   }
   if(InpUseAnchoredVWAP) {
       int pass = 0;
       ENUM_ANCHOR_TYPE anchors[] = {ANCHOR_YEARLY, ANCHOR_MONTHLY, ANCHOR_WEEKLY, ANCHOR_DAILY_ETH, ANCHOR_H4};
       bool enabled[] = {InpAVWAP_Yearly, InpAVWAP_Monthly, InpAVWAP_Weekly, InpAVWAP_Daily, InpAVWAP_H4};
       for(int i=0; i<5; i++) {
           if(!enabled[i]) { pass++; continue; }
           double vwap = CalcAVWAP(GetAnchorTime(anchors[i]));
           if(vwap > 0) {
               if(InpAVWAP_TrendFollow) {
                   if(isBuyGrid && currentPrice > vwap) pass++;
                   else if(!isBuyGrid && currentPrice < vwap) pass++;
               } else { pass++; }
           } else pass++;
       }
       if(pass < InpAVWAP_Confluence) return false;
   }
   if(InpUseSolidCandleFilter) {
       double o = iOpen(_Symbol, PERIOD_CURRENT, 1), c = iClose(_Symbol, PERIOD_CURRENT, 1), h = iHigh(_Symbol, PERIOD_CURRENT, 1), l = iLow(_Symbol, PERIOD_CURRENT, 1);
       if((h - l) > 0 && (MathAbs(c - o)/(h - l)) < InpSolidBodyRatio) return false;
   }
   if(InpUseGapFilter) {
       double atr = GetATR(PERIOD_D1, 14);
       double gap = iOpen(_Symbol, PERIOD_D1, 0) - iClose(_Symbol, PERIOD_D1, 1);
       if(gap > atr * InpGapThresholdATR && isBuyGrid) return false;
       if(gap < -atr * InpGapThresholdATR && !isBuyGrid) return false;
   }
   if(InpUsePivotFilter) {
       double h = iHigh(_Symbol, PERIOD_D1, 1), l = iLow(_Symbol, PERIOD_D1, 1), c = iClose(_Symbol, PERIOD_D1, 1), p = (h+l+c)/3.0;
       double r1 = 2*p - l, s1 = 2*p - h, buf = InpPivotBufferPoints * SymbolInfoDouble(_Symbol, SYMBOL_POINT);
       if(isBuyGrid && currentPrice < r1 && currentPrice > r1 - buf) return false;
       if(!isBuyGrid && currentPrice > s1 && currentPrice < s1 + buf) return false;
   }
   if(InpUse3DayRule) {
       double atr = GetATR(PERIOD_CURRENT, 14);
       for(int i=1; i<=Inp3DayLookbackBars; i++) {
           if((iHigh(_Symbol, PERIOD_CURRENT, i) - iLow(_Symbol, PERIOD_CURRENT, i)) > atr * Inp3DayVolThreshold) return false;
       }
   }
   if(InpUseTTMSqueeze && g_ttm_bbHandle != INVALID_HANDLE && g_ttm_maHandle != INVALID_HANDLE) {
       double up[1], low[1], ma[1], atrBuf[1];
       CopyBuffer(g_ttm_bbHandle, 1, 0, 1, up); CopyBuffer(g_ttm_bbHandle, 2, 0, 1, low);
       CopyBuffer(g_ttm_maHandle, 0, 0, 1, ma);
       int hATR = iATR(_Symbol, PERIOD_CURRENT, InpTTM_Period);
       CopyBuffer(hATR, 0, 0, 1, atrBuf); IndicatorRelease(hATR);
       double kcUp = ma[0] + (atrBuf[0] * 1.5), kcLow = ma[0] - (atrBuf[0] * 1.5);
       if(up[0] < kcUp && low[0] > kcLow) return false;
   }
   if(InpUseTrlBslFilter) {
       double priceTime = (double)TimeCurrent();
       if(isBuyGrid && g_trlValid) {
           double linePrice = g_trlSlope * priceTime + g_trlIntercept;
           if(currentPrice < linePrice && (linePrice - currentPrice)/currentPrice * 100.0 < InpLineAvoidThreshold) return false;
       }
       if(!isBuyGrid && g_bslValid) {
           double linePrice = g_bslSlope * priceTime + g_bslIntercept;
           if(currentPrice > linePrice && (currentPrice - linePrice)/currentPrice * 100.0 < InpLineAvoidThreshold) return false;
       }
   }
   return true;
}

//+------------------------------------------------------------------+
//| 基準ロットの計算 (資金管理)                                       |
//+------------------------------------------------------------------+
double GetCalculatedBaseLot()
{
   if(!InpUseAutoLot) return InpLotSize;
   double balance = AccountInfoDouble(ACCOUNT_BALANCE);
   if(InpBaseBalance <= 0) return InpLotSize;
   double calcLot = (balance / InpBaseBalance) * InpBaseLot;
   double minLot  = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
   double maxLot  = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX);
   double stepLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);
   if(stepLot > 0) calcLot = MathFloor(calcLot / stepLot) * stepLot;
   if(calcLot < minLot) calcLot = minLot;
   if(calcLot > maxLot) calcLot = maxLot;
   return calcLot;
}

//+------------------------------------------------------------------+
//| GridTrapEA コアロジック (並行処理版)                              |
//+------------------------------------------------------------------+
void PlaceGridOrders(bool forceReset)
{
   // [Freeze] フリーズモード時は注文配置を行わない
   if(InpFreezeAndClearOrders) return;
   if(g_isDDStopped) return; // DD保護

   // 1. 強制リセットの場合の処理
   if(forceReset) {
      DeleteAllPendingOrders(-1); // 全削除
      g_fixedAnchorPrice = 0.0;
      g_fixedAnchorBuy = 0.0;
      g_fixedAnchorSell = 0.0;
      g_fixedSLBuy = 0.0;
      g_fixedSLSell = 0.0;
   }
   
   // --- アンカー決定 (共通) ---
   double currentAsk = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
   double currentBid = SymbolInfoDouble(_Symbol, SYMBOL_BID);
   double point = SymbolInfoDouble(_Symbol, SYMBOL_POINT);

   if(g_fixedAnchorPrice == 0.0) {
       // --- Step 1: Base Anchor ---
       double centerPrice = (currentAsk + currentBid) / 2.0;
       if(InpUseCenterMA) {
          double maVal = GetMAValue(g_centerMaHandle, InpCenterMAMethod, InpCenterMATimeframe, InpCenterMAPeriod);
          if(maVal > 0) centerPrice = maVal;
       }
       g_fixedAnchorPrice = NormalizePrice(centerPrice);
       g_fixedAnchorBuy   = g_fixedAnchorPrice;
       g_fixedAnchorSell  = g_fixedAnchorPrice;
       
       // --- Step 2: ZigZag Anchor (ベースとして使用) ---
       if(InpUseZigZagEntry) {
           double zHigh=0, zLow=0;
           if(GetZigZagHighLow(g_zigzagEntryHandle, InpZigZagTimeframe_Entry, zHigh, zLow)) {
               // Limit/Stopでの入れ替えロジックは独立化のため固定せず、中心値とする
               g_fixedAnchorPrice = NormalizePrice((zHigh + zLow) / 2.0);
               g_fixedAnchorBuy   = g_fixedAnchorPrice;
               g_fixedAnchorSell  = g_fixedAnchorPrice;
           }
       }
       
       // --- Step 3: ZigZag SL (Option) - 独立して計算
       if(InpUseZigZagForSL) {
           double zSLHigh=0, zSLLow=0;
           if(GetZigZagHighLow(g_zigzagSLHandle, InpZigZagTimeframe_SL, zSLHigh, zSLLow)) {
               g_fixedSLBuy  = NormalizePrice(zSLLow - (InpZigZagSLOffset * point));
               g_fixedSLSell = NormalizePrice(zSLHigh + (InpZigZagSLOffset * point));
           } else {
               g_fixedSLBuy = 0; g_fixedSLSell = 0;
           }
       } else {
           g_fixedSLBuy = 0; g_fixedSLSell = 0;
       }
   }
   g_gridCenterPrice = g_fixedAnchorPrice;
   
   double baseLot = GetCalculatedBaseLot();
   int targetSplitCount = GetSplitCount();


   // =================================================================
   // 【A】 通常グリッド (Normal Grid) の処理
   // =================================================================
   double adxA = GetADXValue(g_filterAdxHandle_A);
   double adxB = GetADXValue(g_filterAdxHandle_B);
   double adxC = GetADXValue(g_filterAdxHandle_C);
   
   bool isNormalAllowed = true;

   // 1. ADXフィルタチェック (3種類のうちどれか一つでも引っかかれば停止)
   bool stopA = (InpUseAdxFilter_A && adxA > InpFilterAdxThreshold_A);
   bool stopB = (InpUseAdxFilter_B && adxB > InpFilterAdxThreshold_B);
   bool stopC = (InpUseAdxFilter_C && adxC > InpFilterAdxThreshold_C);
   
   if(stopA || stopB || stopC) {
       isNormalAllowed = false;
   }
   
   // 2. 指定日除外 (Normal)
   if(IsRestrictedDate(InpNoEntryDates_Normal)) isNormalAllowed = false;

   // 実行判定
   if(!isNormalAllowed) {
       // 条件を満たさない場合、Normal(Limit)注文のみ削除
       DeleteAllPendingOrders(MAGIC_GRID); 
   } 
   else {
       // --- 通常グリッドの展開 (Limit / 逆張り) ---
       g_trade.SetExpertMagicNumber(MAGIC_GRID); // マジックナンバーセット

       // パラメータ設定 (Normal)
       double step     = GetAbsoluteDistance(InpStepUnit, InpGridStep, g_gridCenterPrice);
       double tp       = GetAbsoluteDistance(InpTpSlUnit, InpGridTakeProfit, g_gridCenterPrice);
       double sl       = GetAbsoluteDistance(InpTpSlUnit, InpGridStopLoss, g_gridCenterPrice);
       
       // ATR/ADXでの幅調整
       if(InpUseATRGrid) {
           double atr = GetATR(InpAtrStepTimeframe, InpAtrStepPeriod);
           if(atr > 0) step = MathMax(step, atr * InpAtrStepMultiplier);
       }
       // [Mod] Filter A の値をADX拡大ロジックに使用
       if(InpUseADXGrid && adxA > 0) step *= (1.0 + (adxA * InpAdxStepPower));
       if(step < InpMinGridStep * point) step = InpMinGridStep * point;

       // 買い (Limit)
       if(InpDirectionMode != DIR_SELL_ONLY && IsGridPlacementAllowed(true)) { // Normal用フィルタチェック
           double accumDist = 0;
           double curStep = step;
           double curTP = tp;
           
           for(int i=1; i<=InpMaxOrders; i++) {
               accumDist += curStep;
               int needed = targetSplitCount - CountGridLevel(true, i, MAGIC_GRID); // Magic指定
               
               if(needed > 0) {
                   double lot = baseLot * MathPow(InpUseLotDecay ? InpLotDecayMultiplier : InpLotMultiplier, i-1);
                   lot = MathFloor(lot/SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP)) * SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);
                   if(lot < SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN)) lot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
                   
                   double entryPrice = NormalizePrice(g_fixedAnchorPrice - accumDist);
                   
                   // 現在価格より下ならBuyLimit
                   if(entryPrice < currentAsk) {
                        // [v33] ZigZag SL Logic for Limit
                        double oSL;
                        if(InpUseZigZagForSL && g_fixedSLBuy > 0) oSL = g_fixedSLBuy;
                        else oSL = (sl > 0) ? NormalizePrice(entryPrice - sl) : 0;
                        
                        double oTP = (curTP > 0) ? NormalizePrice(entryPrice + curTP) : 0;
                        // 分割発注ループ
                        for(int k=0; k<needed; k++) 
                            g_trade.BuyLimit(lot, entryPrice, _Symbol, oSL, oTP, ORDER_TIME_GTC, 0, StringFormat("GT_B_%d", i));
                   }
               }
               curStep *= InpGridStepMultiplier;
               if(InpEnableTPMultiplier) curTP *= InpGridStepMultiplier;
           }
       }

       // 売り (Limit)
       if(InpDirectionMode != DIR_BUY_ONLY && IsGridPlacementAllowed(false)) { // Normal用フィルタチェック
           double accumDist = 0;
           double curStep = step;
           double curTP = tp;
           
           for(int i=1; i<=InpMaxOrders; i++) {
               accumDist += curStep;
               int needed = targetSplitCount - CountGridLevel(false, i, MAGIC_GRID);
               
               if(needed > 0) {
                   double lot = baseLot * MathPow(InpUseLotDecay ? InpLotDecayMultiplier : InpLotMultiplier, i-1);
                   lot = MathFloor(lot/SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP)) * SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);
                   if(lot < SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN)) lot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);

                   double entryPrice = NormalizePrice(g_fixedAnchorPrice + accumDist);
                   
                   // 現在価格より上ならSellLimit
                   if(entryPrice > currentBid) {
                        double oSL;
                        if(InpUseZigZagForSL && g_fixedSLSell > 0) oSL = g_fixedSLSell;
                        else oSL = (sl > 0) ? NormalizePrice(entryPrice + sl) : 0;

                        double oTP = (curTP > 0) ? NormalizePrice(entryPrice - curTP) : 0;
                        for(int k=0; k<needed; k++) 
                            g_trade.SellLimit(lot, entryPrice, _Symbol, oSL, oTP, ORDER_TIME_GTC, 0, StringFormat("GT_S_%d", i));
                   }
               }
               curStep *= InpGridStepMultiplier;
               if(InpEnableTPMultiplier) curTP *= InpGridStepMultiplier;
           }
       }
   }


   // =================================================================
   // 【B】 トレンドグリッド (Trend Grid) の処理 - 独立動作
   // =================================================================
   if(!InpSwitchToTrendOnADX) return; // 機能OFFならここで終了

   double trendAdx = GetADXValue(g_trendAdxHandle);
   bool isTrendActive = false;
   
   // 判定ロジック
   if(trendAdx > InpTrendAdxThreshold) {
       isTrendActive = true;
       g_trendLastHighTime = TimeCurrent(); // 最終アクティブ時間を更新
       g_currentGridIsTrend = true; // 表示用フラグ (ON)
   } else {
       // ADXは下がったが、維持時間内か？
       if(TimeCurrent() - g_trendLastHighTime < InpTrendHoldMinutes * 60) {
           isTrendActive = true;
           g_currentGridIsTrend = true; // 表示用フラグ (Hold)
       } else {
           isTrendActive = false;
           g_currentGridIsTrend = false; // 表示用フラグ (OFF)
       }
   }
   
   // 指定日除外 (Trend)
   if(IsRestrictedDate(InpNoEntryDates_Trend)) isTrendActive = false;

   if(!isTrendActive) {
       // 条件を満たさない場合、Trend(Stop)注文のみ削除
       DeleteAllPendingOrders(MAGIC_TREND);
   }
   else {
       // --- トレンドグリッドの展開 (Stop / 順張り) ---
       g_trade.SetExpertMagicNumber(MAGIC_TREND); // ★マジックナンバー切り替え

       // パラメータ設定 (Trend)
       double step = GetAbsoluteDistance(InpStepUnit, InpTrendGridStep, g_gridCenterPrice);
       double tp   = GetAbsoluteDistance(InpTpSlUnit, InpTrendTakeProfit, g_gridCenterPrice);
       double sl   = GetAbsoluteDistance(InpTpSlUnit, InpTrendStopLoss, g_gridCenterPrice);
       // Trendモードは減衰とトレンド倍率のどちらか優先（元のロジック準拠）
       double activeLotMult = (InpUseLotDecay) ? InpLotDecayMultiplier : InpTrendLotMultiplier;

       // 買い (Stop)
       if(InpDirectionMode != DIR_SELL_ONLY) { // ※Trendフィルタは別途考慮必要だが一旦省略
           double accumDist = 0;
           double curStep = step;
           
           for(int i=1; i<=InpTrendMaxOrders; i++) {
               accumDist += curStep;
               int needed = targetSplitCount - CountGridLevel(true, i, MAGIC_TREND); // Magic指定
               
               if(needed > 0) {
                   double lot = baseLot * MathPow(activeLotMult, i-1);
                   lot = MathFloor(lot/SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP)) * SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);
                   if(lot < SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN)) lot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);

                   double entryPrice = NormalizePrice(g_fixedAnchorPrice + accumDist); // 上に置く
                   
                   // 現在価格より上ならBuyStop
                   if(entryPrice > currentAsk) {
                        double oSL;
                        if(InpUseZigZagForSL && g_fixedSLBuy > 0) oSL = g_fixedSLBuy;
                        else oSL = (sl > 0) ? NormalizePrice(entryPrice - sl) : 0;

                        double oTP = (tp > 0) ? NormalizePrice(entryPrice + tp) : 0; // TP固定幅
                        for(int k=0; k<needed; k++) 
                            g_trade.BuyStop(lot, entryPrice, _Symbol, oSL, oTP, ORDER_TIME_GTC, 0, StringFormat("GT_B_%d", i));
                   }
               }
               curStep *= InpTrendStepMultiplier;
           }
       }

       // 売り (Stop)
       if(InpDirectionMode != DIR_BUY_ONLY) {
           double accumDist = 0;
           double curStep = step;
           
           for(int i=1; i<=InpTrendMaxOrders; i++) {
               accumDist += curStep;
               int needed = targetSplitCount - CountGridLevel(false, i, MAGIC_TREND);
               
               if(needed > 0) {
                   double lot = baseLot * MathPow(activeLotMult, i-1);
                   lot = MathFloor(lot/SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP)) * SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);
                   if(lot < SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN)) lot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);

                   double entryPrice = NormalizePrice(g_fixedAnchorPrice - accumDist); // 下に置く
                   
                   // 現在価格より下ならSellStop
                   if(entryPrice < currentBid) {
                        double oSL;
                        if(InpUseZigZagForSL && g_fixedSLSell > 0) oSL = g_fixedSLSell;
                        else oSL = (sl > 0) ? NormalizePrice(entryPrice + sl) : 0;

                        double oTP = (tp > 0) ? NormalizePrice(entryPrice - tp) : 0; // TP固定幅
                        for(int k=0; k<needed; k++) 
                            g_trade.SellStop(lot, entryPrice, _Symbol, oSL, oTP, ORDER_TIME_GTC, 0, StringFormat("GT_S_%d", i));
                   }
               }
               curStep *= InpTrendStepMultiplier;
           }
       }
   }
   
   // 最後にマジックナンバーを戻しておく（安全のため）
   g_trade.SetExpertMagicNumber(MAGIC_GRID);
}

void OpenHedgePosition(string comment)
{
   if(g_isHedgeActive) return;
   
   double buyVol=0, sellVol=0;
   for(int i=PositionsTotal()-1; i>=0; i--) {
      ulong ticket = PositionGetTicket(i);
      if(ticket > 0 && PositionSelectByTicket(ticket) && PositionGetInteger(POSITION_MAGIC) == MAGIC_GRID) {
         if(PositionGetInteger(POSITION_TYPE)==POSITION_TYPE_BUY) buyVol += PositionGetDouble(POSITION_VOLUME);
         if(PositionGetInteger(POSITION_TYPE)==POSITION_TYPE_SELL) sellVol += PositionGetDouble(POSITION_VOLUME);
      }
   }
   
   int dir = -1; 
   double lot = InpManualHedgeLot;

   if(InpUseAutoHedgeLot && (buyVol+sellVol > 0)) {
       lot = MathAbs(buyVol - sellVol) * InpAutoLotMultiplier;
       if(buyVol > sellVol) dir = 1; else dir = 0; 
   } else {
       double current = (SymbolInfoDouble(_Symbol, SYMBOL_ASK)+SymbolInfoDouble(_Symbol, SYMBOL_BID))/2.0;
       if(current > g_gridCenterPrice) dir = 0; else dir = 1; 
   }
   
   // --- [Add] 分割エントリー対応 ---
   double totalLot = lot;
   int splitCount = GetSplitCount();
   double perPosLot = totalLot / (double)splitCount;
   
   double minLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
   double stepLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);
   
   // 個別ロットの正規化
   perPosLot = MathFloor(MathMax(perPosLot, minLot)/stepLot) * stepLot;
   // ---------------------------
   
   // --- SL/TPの距離計算ロジック (Unit対応) ---
   double priceBase = (dir == 0) ? SymbolInfoDouble(_Symbol, SYMBOL_ASK) : SymbolInfoDouble(_Symbol, SYMBOL_BID);
   double slDist = GetAbsoluteDistance(InpHedgeTpSlUnit, InpHedgeSL, priceBase);
   double tpDist = GetAbsoluteDistance(InpHedgeTpSlUnit, InpHedgeTP, priceBase);

   g_trade.SetExpertMagicNumber(MAGIC_HEDGE);
   
   bool anyPlaced = false;
   
   // [Add] 分割ループ
   for(int k=0; k<splitCount; k++)
   {
       if(dir == 0) { // Buy Hedge
          // [Fix] NormalizePrice適用
          double slPrice = (slDist > 0) ? NormalizePrice(priceBase - slDist) : 0;
          double tpPrice = (tpDist > 0) ? NormalizePrice(priceBase + tpDist) : 0;
          if(g_trade.Buy(perPosLot, _Symbol, 0, slPrice, tpPrice, comment)) anyPlaced = true;
       } else { // Sell Hedge
          // [Fix] NormalizePrice適用
          double slPrice = (slDist > 0) ? NormalizePrice(priceBase + slDist) : 0;
          double tpPrice = (tpDist > 0) ? NormalizePrice(priceBase - tpDist) : 0;
          if(g_trade.Sell(perPosLot, _Symbol, 0, slPrice, tpPrice, comment)) anyPlaced = true;
       }
   }
   
   if(anyPlaced) g_isHedgeActive = true;
   g_trade.SetExpertMagicNumber(MAGIC_GRID);
}

//+------------------------------------------------------------------+
//| [New] ZigZag SLを「最も有利な1つのポジション」にのみ適用する関数          |
//| 対象: 含み益が最も多い（または含み損が最も少ない）ポジション                 |
//+------------------------------------------------------------------+
void UpdateZigZagSL_BestPositionOnly()
{
   // 機能が無効、またはハンドルがない場合は終了
   if(!InpUseZigZagForSL || g_zigzagSLHandle == INVALID_HANDLE) return;

   // 1. 最新のZigZag価格からSL目標値を計算
   double zHigh=0, zLow=0;
   double targetSL_Buy = 0;
   double targetSL_Sell = 0;
   double point = SymbolInfoDouble(_Symbol, SYMBOL_POINT);

   if(GetZigZagHighLow(g_zigzagSLHandle, InpZigZagTimeframe_SL, zHigh, zLow)) {
      // BuyのSL = 安値 - オフセット
      targetSL_Buy  = NormalizePrice(zLow - (InpZigZagSLOffset * point));
      // SellのSL = 高値 + オフセット
      targetSL_Sell = NormalizePrice(zHigh + (InpZigZagSLOffset * point));
   } else {
      return; // ZigZagが取得できない場合は何もしない
   }

   // 2. 「最も有利な」ポジションを探す
   ulong bestBuyTicket = 0;
   double maxBuyProfit = -DBL_MAX; // 最低値で初期化
   double bestBuyCurrentSL = 0;
   double bestBuyTP = 0;

   ulong bestSellTicket = 0;
   double maxSellProfit = -DBL_MAX;
   double bestSellCurrentSL = 0;
   double bestSellTP = 0;

   for(int i=PositionsTotal()-1; i>=0; i--) {
      ulong ticket = PositionGetTicket(i);
      if(ticket > 0 && PositionSelectByTicket(ticket)) {
         long magic = PositionGetInteger(POSITION_MAGIC);
         // マジックナンバー(GRID or TREND)とシンボルの一致確認
         if( (magic == MAGIC_GRID || magic == MAGIC_TREND) && PositionGetString(POSITION_SYMBOL) == _Symbol) {
            double profit = PositionGetDouble(POSITION_PROFIT);
            long type = PositionGetInteger(POSITION_TYPE);

            if(type == POSITION_TYPE_BUY) {
               // 利益が現在の最大値より大きければ更新（含み損-500円より-100円の方が大きい＝有利）
               if(profit > maxBuyProfit) {
                  maxBuyProfit = profit;
                  bestBuyTicket = ticket;
                  bestBuyCurrentSL = PositionGetDouble(POSITION_SL);
                  bestBuyTP = PositionGetDouble(POSITION_TP);
               }
            }
            else if(type == POSITION_TYPE_SELL) {
               if(profit > maxSellProfit) {
                  maxSellProfit = profit;
                  bestSellTicket = ticket;
                  bestSellCurrentSL = PositionGetDouble(POSITION_SL);
                  bestSellTP = PositionGetDouble(POSITION_TP);
               }
            }
         }
      }
   }

   // 3. 選ばれた1つのポジションに対してのみSL更新を試みる
   
   // --- Buyポジションの更新 ---
   if(bestBuyTicket > 0 && targetSL_Buy > 0) {
      double currentPrice = SymbolInfoDouble(_Symbol, SYMBOL_BID);
      // 条件: 現在価格よりSLが下にあること（即決済回避） 
      // かつ、(SLが未設定 OR 新しいSLの方が有利[高い]位置にある)
      if(targetSL_Buy < currentPrice) {
         if(bestBuyCurrentSL == 0 || targetSL_Buy > bestBuyCurrentSL + point) {
             g_trade.PositionModify(bestBuyTicket, targetSL_Buy, bestBuyTP);
             PrintFormat("📈 ZigZag SL Update (Best Buy): Ticket %d, Profit %.0f, SL %.5f -> %.5f", 
                         bestBuyTicket, maxBuyProfit, bestBuyCurrentSL, targetSL_Buy);
         }
      }
   }

   // --- Sellポジションの更新 ---
   if(bestSellTicket > 0 && targetSL_Sell > 0) {
      double currentPrice = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
      // 条件: 現在価格よりSLが上にあること
      // かつ、(SLが未設定 OR 新しいSLの方が有利[低い]位置にある)
      if(targetSL_Sell > currentPrice) {
         if(bestSellCurrentSL == 0 || targetSL_Sell < bestSellCurrentSL - point) {
             g_trade.PositionModify(bestSellTicket, targetSL_Sell, bestSellTP);
             PrintFormat("📉 ZigZag SL Update (Best Sell): Ticket %d, Profit %.0f, SL %.5f -> %.5f", 
                         bestSellTicket, maxSellProfit, bestSellCurrentSL, targetSL_Sell);
         }
      }
   }
}

//+------------------------------------------------------------------+
//| Main System Events                                               |
//+------------------------------------------------------------------+
int OnInit()
{
   g_trade.SetExpertMagicNumber(MAGIC_GRID);
   
   // [Modified] ADXハンドルを3つ作成 (Filter A/B/C)
   if(InpUseAdxFilter_A || InpUseADXGrid) {
      g_filterAdxHandle_A = iADX(_Symbol, InpFilterAdxTimeframe_A, InpFilterAdxPeriod_A);
   }
   if(InpUseAdxFilter_B) {
      g_filterAdxHandle_B = iADX(_Symbol, InpFilterAdxTimeframe_B, InpFilterAdxPeriod_B);
   }
   if(InpUseAdxFilter_C) {
      g_filterAdxHandle_C = iADX(_Symbol, InpFilterAdxTimeframe_C, InpFilterAdxPeriod_C);
   }
   
   if(InpSwitchToTrendOnADX) {
      g_trendAdxHandle  = iADX(_Symbol, InpTrendAdxTimeframe, InpTrendAdxPeriod);
   }
   // [Add] ヘッジ専用ADX
   if(InpUseAdxHedge) {
      g_hedgeAdxHandle = iADX(_Symbol, InpHedgeAdxTimeframe, InpHedgeAdxPeriod);
   }
   
   // [Modified] MA handles (Normal/Trend split) with Option [v37 VWMA Logic]
   // VWMA以外の場合のみハンドルを作成する
   if(InpUseMAFilter_Normal && InpMAMethod_Normal != MA_TYPE_VWMA) {
       g_maNormalHandle = iMA(_Symbol, InpMATF_Normal, InpMAPeriod_Normal, 0, (ENUM_MA_METHOD)InpMAMethod_Normal, PRICE_CLOSE);
   }
   if(InpUseMAFilter_Trend && InpMAMethod_Trend != MA_TYPE_VWMA) {
       g_maTrendHandle  = iMA(_Symbol, InpMATF_Trend,  InpMAPeriod_Trend,  0, (ENUM_MA_METHOD)InpMAMethod_Trend, PRICE_CLOSE);
   }

   if(InpUse21EMAFilter) g_21emaHandle = iMA(_Symbol, PERIOD_CURRENT, 21, 0, MODE_EMA, PRICE_CLOSE);
   if(InpUseMomoMAFilter) g_momoMaHandle = iMA(_Symbol, InpMomoMATimeframe, InpMomoMAPeriod, 0, (ENUM_MA_METHOD)InpMomoMAMethod, PRICE_CLOSE);
   if(InpUseWoodiesFilter) g_wcciHandle = iCCI(_Symbol, PERIOD_CURRENT, InpWCCI_Period, PRICE_TYPICAL);
   if(InpUseTTMSqueeze) {
      g_ttm_bbHandle = iBands(_Symbol, PERIOD_CURRENT, InpTTM_Period, 0, 2.0, PRICE_CLOSE);
      g_ttm_maHandle = iMA(_Symbol, PERIOD_CURRENT, InpTTM_Period, 0, MODE_SMA, PRICE_CLOSE);
   }
   if(InpUseTrlBslFilter) {
      g_trlZigZagHandle = iCustom(_Symbol, InpTrlBslTimeframe, "Examples\\ZigZag", InpTrlBslDepth, InpTrlBslDeviation, InpTrlBslBackstep);
   }
   // [Modified] Perfect Order with Option [v37]
   if(InpUsePerfectOrder && InpPerfectOrderMethod != MA_TYPE_VWMA) {
      g_poMA1 = iMA(_Symbol, PERIOD_CURRENT, 5, 0, (ENUM_MA_METHOD)InpPerfectOrderMethod, PRICE_CLOSE); 
      g_poMA2 = iMA(_Symbol, PERIOD_CURRENT, 10, 0, (ENUM_MA_METHOD)InpPerfectOrderMethod, PRICE_CLOSE);
      g_poMA3 = iMA(_Symbol, PERIOD_CURRENT, 20, 0, (ENUM_MA_METHOD)InpPerfectOrderMethod, PRICE_CLOSE); 
      g_poMA4 = iMA(_Symbol, PERIOD_CURRENT, 50, 0, (ENUM_MA_METHOD)InpPerfectOrderMethod, PRICE_CLOSE);
      g_poMA5 = iMA(_Symbol, PERIOD_CURRENT, 100, 0, (ENUM_MA_METHOD)InpPerfectOrderMethod, PRICE_CLOSE);
   }

   // [New] 中心判定用MAハンドルの初期化 (with Option) [v37]
   if(InpUseCenterMA && InpCenterMAMethod != MA_TYPE_VWMA) {
      g_centerMaHandle = iMA(_Symbol, InpCenterMATimeframe, InpCenterMAPeriod, 0, (ENUM_MA_METHOD)InpCenterMAMethod, PRICE_CLOSE);
      if(g_centerMaHandle == INVALID_HANDLE) {
         Print("Error: Failed to create Center MA handle.");
         return INIT_FAILED;
      }
   }
   
   // [New] ZigZag Entry用ハンドルの初期化
   if(InpUseZigZagEntry) {
      g_zigzagEntryHandle = iCustom(_Symbol, InpZigZagTimeframe_Entry, "Examples\\ZigZag", InpZigZagDepth, InpZigZagDeviation, InpZigZagBackstep);
      if(g_zigzagEntryHandle == INVALID_HANDLE) {
         Print("Error: Failed to create ZigZag Entry handle. (Examples\\ZigZag not found?)");
         return INIT_FAILED;
      }
   }
   // [New] ZigZag SL用ハンドルの初期化
   if(InpUseZigZagForSL) {
      g_zigzagSLHandle = iCustom(_Symbol, InpZigZagTimeframe_SL, "Examples\\ZigZag", InpZigZagDepth, InpZigZagDeviation, InpZigZagBackstep);
      if(g_zigzagSLHandle == INVALID_HANDLE) {
         Print("Error: Failed to create ZigZag SL handle.");
         return INIT_FAILED;
      }
   }
   
   // [New] リセット時間の初期化
   g_lastGridResetTime = TimeCurrent();
   g_latestPositionTime = 0;
   g_fixedAnchorPrice = 0.0; // 初期化
   g_fixedAnchorBuy = 0.0;
   g_fixedAnchorSell = 0.0;
   g_fixedSLBuy = 0.0;
   g_fixedSLSell = 0.0;
   g_trendLastHighTime = 0; // [New]
   
   g_isDDStopped = false; // [New]
   g_ddStopStartTime = 0;

   // 初期状態の決定
   if(InpSwitchToTrendOnADX) {
       double initialAdx = GetADXValue(g_trendAdxHandle);
       g_currentGridIsTrend = (initialAdx > InpTrendAdxThreshold);
       if(g_currentGridIsTrend) g_trendLastHighTime = TimeCurrent();
   } else {
       g_currentGridIsTrend = false;
   }

   // [New] 起動時に強制クリーンアップと再構築を行う
   Print("EA Initialized. Force cleaning old orders and restarting grid...");
   
   // [Freeze] フリーズモードでなければ構築
   if(!InpFreezeAndClearOrders) {
       PlaceGridOrders(true); // true = 強制リセット(新規構築)
   }
   
   return INIT_SUCCEEDED;
}

void OnDeinit(const int reason)
{
   IndicatorRelease(g_filterAdxHandle_A);
   IndicatorRelease(g_filterAdxHandle_B);
   IndicatorRelease(g_filterAdxHandle_C);
   IndicatorRelease(g_trendAdxHandle); 
   IndicatorRelease(g_hedgeAdxHandle); // [New]
   IndicatorRelease(g_maNormalHandle);
   IndicatorRelease(g_maTrendHandle);
   IndicatorRelease(g_21emaHandle); IndicatorRelease(g_momoMaHandle);
   IndicatorRelease(g_wcciHandle); IndicatorRelease(g_ttm_bbHandle); IndicatorRelease(g_ttm_maHandle);
   IndicatorRelease(g_trlZigZagHandle);
   IndicatorRelease(g_centerMaHandle); 
   IndicatorRelease(g_zigzagEntryHandle); // [New]
   IndicatorRelease(g_zigzagSLHandle);    // [New]
   
   ObjectsDeleteAll(0, "GT_");
   Comment("");

   // [New] EAが削除、終了、再コンパイルなどで停止する際に、未約定の注文を全削除する
   if(reason == REASON_REMOVE || reason == REASON_CHARTCLOSE || reason == REASON_CLOSE || reason == REASON_RECOMPILE || reason == REASON_ACCOUNT) {
       Print("EA Deinit: Deleting all pending orders.");
       DeleteAllPendingOrders(-1);
   }
}

void OnTick()
{
   double currentPrice = (SymbolInfoDouble(_Symbol, SYMBOL_ASK) + SymbolInfoDouble(_Symbol, SYMBOL_BID)) / 2.0;

   // [Freeze Mode] 最優先制御
   if(InpFreezeAndClearOrders) {
      if(OrdersTotal() > 0) DeleteAllPendingOrders(-1);
      // 下のロジックは通す(TS等)
   }

   // --- [v40] 口座ドローダウン保護 (DD Protection) ---
   // ※最優先チェック
   if(InpUseDDProtection) {
       // DDが発動していない場合のチェック
       if(!g_isDDStopped) {
           double balance = AccountInfoDouble(ACCOUNT_BALANCE);
           double equity  = AccountInfoDouble(ACCOUNT_EQUITY);
           if(balance > 0) {
               double ddPercent = (balance - equity) / balance * 100.0;
               if(ddPercent >= InpMaxDDPercent) {
                   PrintFormat("🚨 MAX DRAWDOWN REACHED: %.1f%% (Limit %.1f%%). Executing Protection (%s)...", 
                               ddPercent, InpMaxDDPercent, EnumToString(InpDDAction));
                   
                   // 共通処理: 1. 全待機注文削除 (被害拡大防止)
                   DeleteAllPendingOrders(-1);
                   
                   // 処理分岐
                   if(InpDDAction == DD_ACTION_CLOSE_ALL) {
                       // A. 全決済モード
                       for(int i=PositionsTotal()-1; i>=0; i--) {
                           ulong ticket = PositionGetTicket(i);
                           if(ticket > 0 && PositionSelectByTicket(ticket)) {
                               long magic = PositionGetInteger(POSITION_MAGIC);
                               if((magic == MAGIC_GRID || magic == MAGIC_HEDGE || magic == MAGIC_TREND) && PositionGetString(POSITION_SYMBOL) == _Symbol) {
                                   g_trade.PositionClose(ticket);
                               }
                           }
                       }
                   } 
                   else if(InpDDAction == DD_ACTION_FULL_HEDGE) {
                       // B. 完全両建てロックモード
                       double sumBuy = 0.0;
                       double sumSell = 0.0;
                       
                       // 現在の保有量を計算
                       for(int i=PositionsTotal()-1; i>=0; i--) {
                           if(PositionGetTicket(i) > 0 && PositionGetString(POSITION_SYMBOL) == _Symbol) {
                               long magic = PositionGetInteger(POSITION_MAGIC);
                               if(magic == MAGIC_GRID || magic == MAGIC_HEDGE || magic == MAGIC_TREND) {
                                   long type = PositionGetInteger(POSITION_TYPE);
                                   double vol = PositionGetDouble(POSITION_VOLUME);
                                   if(type == POSITION_TYPE_BUY) sumBuy += vol;
                                   if(type == POSITION_TYPE_SELL) sumSell += vol;
                               }
                           }
                       }
                       
                       // 差分を計算して発注
                       double netLot = sumBuy - sumSell;
                       // 正規化 (ロットステップに合わせる)
                       double stepLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);
                       netLot = MathRound(netLot / stepLot) * stepLot;
                       
                       if(MathAbs(netLot) >= SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN)) {
                           // 買いが多い -> 売りヘッジを入れる
                           if(netLot > 0) {
                               g_trade.Sell(netLot, _Symbol, 0, 0, 0, "DD_FullHedge_Lock");
                           }
                           // 売りが多い -> 買いヘッジを入れる
                           else if(netLot < 0) {
                               g_trade.Buy(MathAbs(netLot), _Symbol, 0, 0, 0, "DD_FullHedge_Lock");
                           }
                       }
                   }
                   
                   // 共通処理: 3. 停止モードへ移行
                   g_isDDStopped = true;
                   g_ddStopStartTime = TimeCurrent();
                   g_fixedAnchorPrice = 0.0; // アンカーリセット
                   g_fixedAnchorBuy = 0.0;
                   g_fixedAnchorSell = 0.0;
                   
                   UpdateVisuals();
                   return; // 以降の処理はスキップ
               }
           }
       }
       // DD発動中の場合（復帰判定）
       else {
           long elapsed = TimeCurrent() - g_ddStopStartTime;
           long pauseSec = InpDDPauseHours * 3600;
           
           if(elapsed >= pauseSec) {
               Print("✅ DD Pause Time Ended. Resuming Grid...");
               g_isDDStopped = false;
               g_ddStopStartTime = 0;
               // アンカーなどは既にクリア済み。次のPlaceGridOrdersで再構築される
           } else {
               // 停止継続中
               UpdateVisuals();
               return; // 何もせず終了
           }
       }
   }
   // ------------------------------------------------

   if(InpUseTrlBslFilter) {
      datetime t = iTime(_Symbol, InpTrlBslTimeframe, 0);
      if(t != g_lastTrlCalcTime) { CalculateTrendLines(); g_lastTrlCalcTime = t; }
   }

   // 1. 緊急停止チェック (Unit対応)
   if(InpUseMaxRangeStop && !g_isEmergencyStopped) {
      double maxDist = GetAbsoluteDistance(InpSafetyUnit, InpMaxRangePoints, g_gridCenterPrice);
      double dist = MathAbs(currentPrice - g_gridCenterPrice);
      if(dist > maxDist) {
         Print("⚠️ Emergency Stop Triggered");
         g_fixedAnchorPrice = 0.0; // [Fix] 緊急停止時はアンカーを解除
         g_fixedAnchorBuy = 0.0;
         g_fixedAnchorSell = 0.0;
         DeleteAllPendingOrders(-1); // 一括削除を使用
         
         // [Modified] 設定に応じて決済を行う
         for(int i=PositionsTotal()-1; i>=0; i--) {
            ulong ticket = PositionGetTicket(i);
            if(ticket > 0 && PositionSelectByTicket(ticket)) {
               long magic = PositionGetInteger(POSITION_MAGIC);
               if(magic == MAGIC_GRID || magic == MAGIC_TREND) {
                   double profit = PositionGetDouble(POSITION_PROFIT);
                   bool shouldClose = false;
                   if(profit > 0 && InpCloseProfitOnStop) shouldClose = true;
                   if(profit < 0 && InpCloseLossOnStop)   shouldClose = true;

                   if(shouldClose) g_trade.PositionClose(ticket);
               }
            }
         }
         if(!InpFreezeAndClearOrders && InpUseManualHedge && InpHedgeManualMode == HEDGE_ON_STOP) {
            OpenHedgePosition("Emergency Hedge");
         }
         g_isEmergencyStopped = true;
      }
   }
   if(g_isEmergencyStopped) {
      UpdateVisuals();
      return;
   }
   
   // --- [New] 定期リセット機能 (Periodic Reset) ---
   // フリーズモード時はスキップ
   if(!InpFreezeAndClearOrders && InpUsePeriodicReset && InpGridResetInterval > 0 && !g_isEmergencyStopped) {
      if(TimeCurrent() - g_lastGridResetTime >= InpGridResetInterval * 60) {
          PrintFormat("⏳ Periodic Reset: %d minutes passed. Re-calculating grid...", InpGridResetInterval);
          g_fixedAnchorPrice = 0.0; // [Fix] リセット時はアンカーを解除
          g_fixedAnchorBuy = 0.0;
          g_fixedAnchorSell = 0.0;
          PlaceGridOrders(true); // true = 強制リセット
          g_lastGridResetTime = TimeCurrent();
      }
   }
   // ----------------------------------------------

   // 2. ADX制御 (分離ロジック) - モード切替判定を削除し、常に監視
   // (PlaceGridOrders内で処理するためここでは不要)
   
   // ヘッジ用 (Filter ADXではなく専用ADXを使用)
   if(!InpFreezeAndClearOrders && InpUseAdxHedge) {
      double hedgeAdx = GetADXValue(g_hedgeAdxHandle); // [Mod] 専用ADX値を取得
      
      if(hedgeAdx > InpAdxHedgeThreshold && !g_isHedgeActive) OpenHedgePosition("ADX Hedge");
      else if(hedgeAdx < InpAdxHedgeExit && g_isHedgeActive) { 
          for(int i=PositionsTotal()-1; i>=0; i--) {
             ulong ticket = PositionGetTicket(i);
             if(ticket > 0 && PositionSelectByTicket(ticket) && PositionGetInteger(POSITION_MAGIC)==MAGIC_HEDGE) g_trade.PositionClose(ticket);
          }
          g_isHedgeActive = false;
      }
   }

   // --- [New] クールダウン制御 (Cool Down) ---
   if(InpUseCoolDown) {
      datetime latestTime = 0;
      for(int i=PositionsTotal()-1; i>=0; i--) {
         ulong ticket = PositionGetTicket(i);
         if(ticket > 0 && PositionSelectByTicket(ticket)) {
            long magic = PositionGetInteger(POSITION_MAGIC);
            if(magic == MAGIC_GRID || magic == MAGIC_TREND) {
                 datetime pt = (datetime)PositionGetInteger(POSITION_TIME);
                 if(pt > latestTime) latestTime = pt;
            }
         }
      }
      g_latestPositionTime = latestTime;

      // クールダウン中は注文を削除するが、アンカー(g_fixedAnchorPrice)は消さない
      if(g_latestPositionTime > 0 && (TimeCurrent() - g_latestPositionTime) < InpCoolDownMinutes * 60) {
          if(OrdersTotal() > 0) DeleteAllPendingOrders(-1);
          UpdateVisuals();
          return; 
      }
   }
   // ------------------------------------------

   // 3. 自動追尾 (Unit対応) - フリーズ時はスキップ
   if(!InpFreezeAndClearOrders) {
       double trackDist = GetAbsoluteDistance(InpSafetyUnit, InpRangeThreshold, g_gridCenterPrice);
       if(MathAbs(currentPrice - g_gridCenterPrice) > trackDist) {
          Print("🔄 Re-centering Grid...");
          g_fixedAnchorPrice = 0.0; // [Fix] 追尾時はアンカーを解除して更新
          g_fixedAnchorBuy = 0.0;
          g_fixedAnchorSell = 0.0;
          if(InpUseManualHedge && InpHedgeManualMode == HEDGE_ON_TRACKING) OpenHedgePosition("Tracking Hedge");
          PlaceGridOrders(true); // true = 強制リセット(追尾)
          g_isEmergencyStopped = false;
       }
   }

   // 4. グリッド維持 & リピート (Recycle)
   if(!InpFreezeAndClearOrders && !g_isEmergencyStopped) {
       
       // クールダウン中かどうかチェック
       bool inCoolDown = false;
       if(InpUseCoolDown && g_latestPositionTime > 0) {
           if((TimeCurrent() - g_latestPositionTime) < InpCoolDownMinutes * 60) inCoolDown = true;
       }

       if(!inCoolDown) {
           // ポジション数・オーダー数を確認
           int totalPos = 0;
           for(int i=0; i<PositionsTotal(); i++) {
               long magic = PositionGetInteger(POSITION_MAGIC);
               if(magic == MAGIC_GRID || magic == MAGIC_TREND) totalPos++;
           }
           int totalOrders = OrdersTotal();

           // A. 完全になくなった場合の再稼働 (全リセット)
           if(totalPos == 0 && totalOrders == 0) {
               // クールダウンOFF、またはアンカーがまだ生きていれば即座に次セットへ
               if(g_fixedAnchorPrice > 0) {
                   g_fixedAnchorPrice = 0.0; // 一旦クリア
                   g_fixedAnchorBuy = 0.0;
                   g_fixedAnchorSell = 0.0;
                   g_fixedSLBuy = 0.0;
                   g_fixedSLSell = 0.0;
               }
               PlaceGridOrders(true); // true = 強制リセット
           }
           // B. リピート機能 (欠けた歯を埋める)
           // 常時監視して、条件に応じてNormal/Trendを出し入れする
           else {
               // 強制リセットせず(false)、足りない番号だけ補充する
               PlaceGridOrders(false);
           }
       }
   }

   // 4.5 ブレイクイーブン (Pct Only) - 各モード独立対応
   // フリーズ時も実行する
   for(int i=PositionsTotal()-1; i>=0; i--) {
       ulong ticket = PositionGetTicket(i);
       if(ticket > 0 && PositionSelectByTicket(ticket) && PositionGetString(POSITION_SYMBOL) == _Symbol) {
           
           long magic = PositionGetInteger(POSITION_MAGIC);
           bool checkBE = false;
           double triggerPct = 0.0;
           double marginPct  = 0.0;

           // --- モードごとの設定値切り替え ---
           if(magic == MAGIC_GRID) {
               // 通常（レンジ）モード
               if(InpUseBreakEven) {
                   checkBE = true;
                   triggerPct = InpBreakEvenTrigger;
                   marginPct  = InpBreakEvenMargin;
               }
           }
           else if(magic == MAGIC_TREND) {
               // トレンドモード
               if(InpTrendUseBreakEven) {
                   checkBE = true;
                   triggerPct = InpTrendBreakEvenTrigger;
                   marginPct  = InpTrendBreakEvenMargin;
               }
           } 
           else if(magic == MAGIC_HEDGE) {
               // ヘッジモード
               if(InpHedgeUseBreakEven) {
                   checkBE = true;
                   triggerPct = InpHedgeBreakEvenTrigger;
                   marginPct  = InpHedgeBreakEvenMargin;
               }
           }
           // --------------------------------

           if(checkBE) {
               double openPrice = PositionGetDouble(POSITION_PRICE_OPEN);
               double currentSL = PositionGetDouble(POSITION_SL);
               double currentTP = PositionGetDouble(POSITION_TP);
               long type = PositionGetInteger(POSITION_TYPE);
               double curP = (type == POSITION_TYPE_BUY) ? SymbolInfoDouble(_Symbol, SYMBOL_BID) : SymbolInfoDouble(_Symbol, SYMBOL_ASK);
               
               // %から距離(Price)を計算
               double triggerDist = openPrice * (triggerPct / 100.0);
               double marginDist  = openPrice * (marginPct / 100.0);
               
               if(type == POSITION_TYPE_BUY) {
                   // 買い: 現在価格が (建値 + トリガー) を超えているか
                   if(curP >= openPrice + triggerDist) {
                       double newSL = NormalizePrice(openPrice + marginDist);
                       // 現在のSLがまだ建値確保ラインより下、または未設定の場合のみ変更
                       if(currentSL < newSL || currentSL == 0) {
                           g_trade.PositionModify(ticket, newSL, currentTP);
                           PrintFormat("BreakEven Triggered (%s): Ticket %d, Open %.5f -> SL %.5f", 
                               (magic==MAGIC_HEDGE?"Hedge":(magic==MAGIC_TREND?"Trend":"Grid")), ticket, openPrice, newSL);
                       }
                   }
               } 
               else if(type == POSITION_TYPE_SELL) {
                   // 売り: 現在価格が (建値 - トリガー) を下回っているか
                   if(curP <= openPrice - triggerDist) {
                       double newSL = NormalizePrice(openPrice - marginDist);
                       // 現在のSLがまだ建値確保ラインより上、または未設定の場合のみ変更
                       if(currentSL > newSL || currentSL == 0) {
                           g_trade.PositionModify(ticket, newSL, currentTP);
                           PrintFormat("BreakEven Triggered (%s): Ticket %d, Open %.5f -> SL %.5f", 
                               (magic==MAGIC_HEDGE?"Hedge":(magic==MAGIC_TREND?"Trend":"Grid")), ticket, openPrice, newSL);
                       }
                   }
               }
           }
       }
   }
   
   // 5. トレーリングストップ (Pct Only) - フリーズ時も実行する
   if(InpUseTrailingStop) {
       for(int i=PositionsTotal()-1; i>=0; i--) {
           ulong ticket = PositionGetTicket(i);
           if(ticket > 0 && PositionSelectByTicket(ticket)) {
               long magic = PositionGetInteger(POSITION_MAGIC);
               // NormalもTrendも同じ設定でTSをかける
               if((magic == MAGIC_GRID || magic == MAGIC_TREND) && PositionGetString(POSITION_SYMBOL) == _Symbol) {
                   double open = PositionGetDouble(POSITION_PRICE_OPEN);
                   double sl = PositionGetDouble(POSITION_SL);
                   double tp = PositionGetDouble(POSITION_TP);
                   long type = PositionGetInteger(POSITION_TYPE);
                   
                   // %から距離(Price)を計算
                   double start = open * (InpStartTrailingStop / 100.0);
                   double dist  = open * (InpTrailingDistance / 100.0);
                   double step  = open * (InpTrailingStep / 100.0);

                   double cur = (type == POSITION_TYPE_BUY) ? SymbolInfoDouble(_Symbol, SYMBOL_BID) : SymbolInfoDouble(_Symbol, SYMBOL_ASK);
                   
                   if(type == POSITION_TYPE_BUY) {
                       if(cur - open > start) {
                           // [Fix] NormalizePrice適用
                           double newSL = NormalizePrice(cur - dist);
                           if(sl == 0 || newSL > sl + step) {
                               g_trade.PositionModify(ticket, newSL, tp);
                           }
                       }
                   } else if(type == POSITION_TYPE_SELL) {
                       if(open - cur > start) {
                           // [Fix] NormalizePrice適用
                           double newSL = NormalizePrice(cur + dist);
                           if(sl == 0 || newSL < sl - step) {
                               g_trade.PositionModify(ticket, newSL, tp);
                           }
                       }
                   }
               }
           }
       }
   }
   
   // ---------------------------------------------------------
   // [Add] ZigZag SL アップデート (ベストポジションのみ)
   // ---------------------------------------------------------
   UpdateZigZagSL_BestPositionOnly();

   UpdateVisuals();
}

//+------------------------------------------------------------------+
//| 視覚化・ダッシュボード表示機能                                    |
//+------------------------------------------------------------------+
void UpdateVisuals()
{
   if(g_gridCenterPrice > 0)
   {
      double range = GetAbsoluteDistance(InpSafetyUnit, InpRangeThreshold, g_gridCenterPrice);
      
      DrawHLine("GT_Center", g_gridCenterPrice, clrDarkGray, STYLE_DOT, 1);
      DrawHLine("GT_UpperReset", g_gridCenterPrice + range, clrFireBrick, STYLE_DASH, 1);
      DrawHLine("GT_LowerReset", g_gridCenterPrice - range, clrFireBrick, STYLE_DASH, 1);
      
      // [ZigZag] アンカーの表示
      if(InpUseZigZagEntry && g_fixedAnchorBuy > 0) {
          DrawHLine("GT_AnchorB", g_fixedAnchorBuy, clrDeepSkyBlue, STYLE_DOT, 1);
          DrawHLine("GT_AnchorS", g_fixedAnchorSell, clrTomato, STYLE_DOT, 1);
      }
      
      // [ZigZag] SLの表示
      if(InpUseZigZagForSL && g_fixedSLBuy > 0) {
          DrawHLine("GT_SL_Buy", g_fixedSLBuy, clrMagenta, STYLE_DOT, 1);
          DrawHLine("GT_SL_Sell", g_fixedSLSell, clrMagenta, STYLE_DOT, 1);
      }
   }

   string text = "";
   int y = 20;
   int step = 18;

   string status = "🟢 稼働中 (Running)";
   color stColor = clrLime;
   
   // クールダウン判定表示
   if(InpUseCoolDown && g_latestPositionTime > 0) {
       long diff = TimeCurrent() - g_latestPositionTime;
       long cdSec = InpCoolDownMinutes * 60;
       if(diff < cdSec) {
           status = StringFormat("❄️ Cool Down (%d sec)", cdSec - diff);
           stColor = clrAqua;
       }
   }

   // [New] 除外日表示
   if(g_isTodayRestricted) {
       status = "⛔ Date Filter Active";
       stColor = clrRed;
   }
   
   // [New] DD保護停止表示
   if(g_isDDStopped) {
       long diff = TimeCurrent() - g_ddStopStartTime;
       long remain = (InpDDPauseHours * 3600) - diff;
       status = StringFormat("🛑 DD PROTECT (%s) %d min", 
                             (InpDDAction==DD_ACTION_CLOSE_ALL)?"CLOSE":"LOCK", remain/60);
       stColor = clrRed;
   }

   // フリーズモード
   if(InpFreezeAndClearOrders) { status = "🧊 FREEZE MODE (Orders Cleared)"; stColor = clrBlue; }

   if(g_isEmergencyStopped) { status = "🔴 緊急停止中 (Stopped)"; stColor = clrRed; }
   else if(g_isHedgeActive) { status = "🟠 ヘッジ稼働中 (Hedge)"; stColor = clrOrange; }
   
   DrawLabel("GT_Txt_Status", status, 20, y, stColor, 12, true); y += step + 5;

   // [Modified] 3つのADXフィルタを表示 (Enableのもののみ)
   double adxA = GetADXValue(g_filterAdxHandle_A);
   double adxB = GetADXValue(g_filterAdxHandle_B);
   double adxC = GetADXValue(g_filterAdxHandle_C);
   
   if(InpUseAdxFilter_A) {
       string strA = StringFormat("Filter A: %.1f%s", adxA, (adxA>InpFilterAdxThreshold_A)?" [STOP]":"");
       DrawLabel("GT_Txt_ADX_A", strA, 20, y, (adxA>InpFilterAdxThreshold_A)?clrRed:clrLime); y += step;
   } else {
       if(ObjectFind(0,"GT_Txt_ADX_A")>=0) ObjectDelete(0,"GT_Txt_ADX_A");
   }

   if(InpUseAdxFilter_B) {
       string strB = StringFormat("Filter B: %.1f%s", adxB, (adxB>InpFilterAdxThreshold_B)?" [STOP]":"");
       DrawLabel("GT_Txt_ADX_B", strB, 20, y, (adxB>InpFilterAdxThreshold_B)?clrRed:clrLime); y += step;
   } else {
       if(ObjectFind(0,"GT_Txt_ADX_B")>=0) ObjectDelete(0,"GT_Txt_ADX_B");
   }

   if(InpUseAdxFilter_C) {
       string strC = StringFormat("Filter C: %.1f%s", adxC, (adxC>InpFilterAdxThreshold_C)?" [STOP]":"");
       DrawLabel("GT_Txt_ADX_C", strC, 20, y, (adxC>InpFilterAdxThreshold_C)?clrRed:clrLime); y += step;
   } else {
       if(ObjectFind(0,"GT_Txt_ADX_C")>=0) ObjectDelete(0,"GT_Txt_ADX_C");
   }

   // Trend ADX
   if(InpSwitchToTrendOnADX) {
      double trendAdx = GetADXValue(g_trendAdxHandle);
      string tAdxStr = StringFormat("Trend ADX: %.1f", trendAdx);
      color tColor = clrWhite;
      
      if(g_currentGridIsTrend) {
          long heldTime = TimeCurrent() - g_trendLastHighTime;
          long holdTotal = InpTrendHoldMinutes * 60;
          if(trendAdx <= InpTrendAdxThreshold && heldTime < holdTotal) {
             tAdxStr += StringFormat(" [HOLD: %ds]", holdTotal - heldTime);
             tColor = clrYellow; // 維持中
          } else {
             tAdxStr += " [ACTIVE]";
             tColor = clrOrange;
          }
      } else {
          tAdxStr += " [Wait]";
          tColor = clrSilver;
      }
      DrawLabel("GT_Txt_ADX_T", tAdxStr, 20, y, tColor); y += step;
   }

   // [New] ヘッジ用ADX表示
   if(InpUseAdxHedge) {
      double hAdx = GetADXValue(g_hedgeAdxHandle);
      string hStr = StringFormat("Hedge ADX: %.1f", hAdx);
      color hClr = clrWhite;
      if(hAdx > InpAdxHedgeThreshold) hClr = clrOrange;
      DrawLabel("GT_Txt_ADX_H", hStr, 180, 20, hClr);
   }

   // --- 計算されたグリッド幅の表示 (Unit対応版) ---
   double point = SymbolInfoDouble(_Symbol, SYMBOL_POINT);
   
   // Activeな設定値で表示 (通常時ベース)
   double activeBase = InpGridStep;
   double baseDist = GetAbsoluteDistance(InpStepUnit, activeBase, g_gridCenterPrice);
   double calcStep = baseDist; 

   string modeInfo = (InpStepUnit==UNIT_PERCENT) ? "PctBase" : "FixBase";

   if(InpUseATRGrid) {
       double atr = GetATR(InpAtrStepTimeframe, InpAtrStepPeriod);
       double atrSize = atr * InpAtrStepMultiplier;
       if(atrSize > calcStep) { calcStep = atrSize; modeInfo += "+ATR"; }
   }
   // [Mod] Filter A for Grid Step
   if(InpUseADXGrid) {
       double adxVal = GetADXValue(g_filterAdxHandle_A); // Use A
       double adxFactor = 1.0 + (adxVal * InpAdxStepPower);
       calcStep = calcStep * adxFactor;
       modeInfo += "+ADX(A)";
   }
   if(calcStep < InpMinGridStep*point) calcStep = InpMinGridStep*point;
   
   // 表示はポイント単位に変換
   int displayPoint = (int)(calcStep / point);
   
   string stepStr = "Grid Step: " + IntegerToString(displayPoint) + " pt (" + modeInfo + ")";
   DrawLabel("GT_Txt_Step", stepStr, 20, y, clrGold); y += step;

   double currentBaseLot = GetCalculatedBaseLot();
   string lotStr = "Base Lot: " + DoubleToString(currentBaseLot, 2);
   if(InpUseAutoLot) lotStr += " (Auto)"; else lotStr += " (Fixed)";
   
   // [New] 分割数の表示
   if(InpEnableSplitEntry) {
      lotStr += StringFormat(" x%d Pos", GetSplitCount());
   }
   DrawLabel("GT_Txt_LotInfo", lotStr, 20, y, clrCyan); y += step;
   
   // [New] リピート状態表示
   if(InpEnableRecycle) {
      DrawLabel("GT_Txt_Recycle", "Recycle Mode: ON", 200, y-18, clrYellow);
   }

   bool buyOk = IsGridPlacementAllowed(true);
   bool sellOk = IsGridPlacementAllowed(false);
   
   string filterStr = "Entry Filter: ";
   DrawLabel("GT_Txt_FilterLbl", filterStr, 20, y, clrWhite);
   DrawLabel("GT_Txt_BuyFl",  buyOk  ? "[BUY OK]" : "[BUY NG]", 110, y, buyOk  ? clrLime : clrRed);
   DrawLabel("GT_Txt_SellFl", sellOk ? "[SELL OK]" : "[SELL NG]", 180, y, sellOk ? clrLime : clrRed);
   y += step;

   int buys=0, sells=0, orders=0;
   for(int i=0; i<PositionsTotal(); i++) {
      long magic = PositionGetInteger(POSITION_MAGIC);
      if(magic == MAGIC_GRID || magic == MAGIC_TREND) {
         if(PositionGetInteger(POSITION_TYPE)==POSITION_TYPE_BUY) buys++;
         else sells++;
      }
   }
   orders = OrdersTotal();
   string posStr = StringFormat("Pos: Buy(%d) Sell(%d) / Order(%d)", buys, sells, orders);
   DrawLabel("GT_Txt_Pos", posStr, 20, y, clrSilver); y += step;

   // TS表示 (Pct Only)
   if(InpUseTrailingStop) {
       string tsInfo = StringFormat("TrailingStop: ON (Start:%.1f%% / Dist:%.1f%%)", 
                                    InpStartTrailingStop, InpTrailingDistance);
       DrawLabel("GT_Txt_TS", tsInfo, 20, y, clrDeepSkyBlue);
       y += step;
   }

   // BE表示 (Pct Only)
   if(InpUseBreakEven) {
       string beInfo = StringFormat("BreakEven: ON (Trig:%.1f%% / Mrg:%.2f%%)", InpBreakEvenTrigger, InpBreakEvenMargin);
       DrawLabel("GT_Txt_BE", beInfo, 20, y, clrSpringGreen);
   }
}

void DrawLabel(string name, string text, int x, int y, color clr, int fontSize=10, bool bold=false)
{
   if(ObjectFind(0, name) < 0) {
      ObjectCreate(0, name, OBJ_LABEL, 0, 0, 0);
      ObjectSetInteger(0, name, OBJPROP_CORNER, CORNER_LEFT_UPPER);
      ObjectSetInteger(0, name, OBJPROP_FONTSIZE, fontSize);
   }
   ObjectSetString(0, name, OBJPROP_TEXT, text);
   ObjectSetInteger(0, name, OBJPROP_XDISTANCE, x);
   ObjectSetInteger(0, name, OBJPROP_YDISTANCE, y);
   ObjectSetInteger(0, name, OBJPROP_COLOR, clr);
   ObjectSetString(0, name, OBJPROP_FONT, bold ? "Arial Black" : "Arial");
}

void DrawHLine(string name, double price, color clr, ENUM_LINE_STYLE style, int width)
{
   if(ObjectFind(0, name) < 0) {
      ObjectCreate(0, name, OBJ_HLINE, 0, 0, 0);
   }
   ObjectSetDouble(0, name, OBJPROP_PRICE, price);
   ObjectSetInteger(0, name, OBJPROP_COLOR, clr);
   ObjectSetInteger(0, name, OBJPROP_STYLE, style);
   ObjectSetInteger(0, name, OBJPROP_WIDTH, width);
   ObjectSetInteger(0, name, OBJPROP_SELECTABLE, false);
   ObjectSetInteger(0, name, OBJPROP_HIDDEN, true);
}
//+------------------------------------------------------------------+
//| End of File                                                      |
//+------------------------------------------------------------------+
