
<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GeminiPWA</title>
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" id="theme-color-meta" content="#4a90e2">
    <style>
        :root {
            --bg-primary: #ffffff;
            --bg-secondary: #f0f2f5;
            --bg-tertiary: #fdfdfd;
            --bg-input: #ffffff;
            --bg-user-message: #dcf8c6;
            --bg-model-message: #e5e5ea;
            --bg-system-message: #f0f8ff;
            --bg-error-message: #ffebee;
            --bg-button: #4a90e2;
            --bg-button-hover: #357abd;
            --bg-button-disabled: #a0c3e8;
            --bg-button-action: #777777;
            --bg-button-action-hover: #555555;
            --bg-button-delete: #e53935;
            --bg-button-delete-hover: #c62828;
            --bg-button-retry: #43a047;
            --bg-button-retry-hover: #2e7d32;
            --bg-button-edit: #ff9800;
            --bg-button-edit-hover: #f57c00;
            --bg-button-duplicate: #546e7a;
            --bg-button-duplicate-hover: #37474f;
            --bg-button-export: #1e88e5;
            --bg-button-export-hover: #1565c0;
            --bg-button-save: #30d158;
            --bg-button-save-hover: #24a345;
            --bg-button-cancel: #f44336;
            --bg-button-cancel-hover: #d32f2f;
            --bg-button-update: #1976d2;
            --bg-button-update-hover: #115293;
            --bg-header: #4a90e2;
            --bg-message-actions: rgba(255, 255, 255, 0.8);
            --bg-overlay-light: rgba(255, 255, 255, 0.65);
            --bg-cascade-button: var(--bg-button-action);
            --bg-cascade-button-hover: var(--bg-button-action-hover);
            --bg-cascade-delete-button: var(--bg-button-delete);
            --bg-cascade-delete-button-hover: var(--bg-button-delete-hover);
            --text-cascade-indicator: var(--text-secondary);

            --text-primary: #333333;
            --text-secondary: #777777;
            --text-light: #ffffff;
            --text-disabled: #e0e0e0;
            --text-error: #c62828;
            --text-link: #4a90e2;
            --text-placeholder: #999999;
            --text-system: #555;

            --border-primary: #cccccc;
            --border-secondary: #dddddd;
            --border-tertiary: #eeeeee;
            --border-danger: #ffcdd2;
            --border-system: #add8e6;

            --shadow-primary: rgba(0, 0, 0, 0.1);
            --shadow-secondary: rgba(0,0,0,0.1);

            --message-max-width: 85%;

            --font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;

            --chat-background-image: none;
            
            --bg-dialog-file-item: var(--bg-tertiary);
            --border-dialog-file-item: var(--border-secondary);
            --text-dialog-file-name: var(--text-primary);
            --text-dialog-file-size: var(--text-secondary);
            --bg-dialog-button-select: var(--bg-button-action);
            --bg-dialog-button-select-hover: var(--bg-button-action-hover);
            --bg-dialog-button-confirm: var(--bg-button-save);
            --bg-dialog-button-confirm-hover: var(--bg-button-save-hover);
            --bg-dialog-button-cancel: var(--bg-button-cancel);
            --bg-dialog-button-cancel-hover: var(--bg-button-cancel-hover);

            --bg-attachment-details: rgba(0, 0, 0, 0.03);
            --border-attachment-details: var(--border-tertiary);
            --text-attachment-summary: var(--text-secondary);
            --text-attachment-filename: var(--text-primary);
            
            --badge-color: #ffcc00;
            --badge-size: 12px;
        }

        body.dark-mode {
            --bg-primary: #1a1a1a;
            --bg-secondary: #101010;
            --bg-tertiary: #252525;
            --bg-input: #303030;
            --bg-user-message: #056162;
            --bg-model-message: #3a3a3c;
            --bg-system-message: #2a3a4a;
            --bg-error-message: #5c1c1c;
            --bg-button: #007aff;
            --bg-button-hover: #005ecb;
            --bg-button-disabled: #4a5a70;
            --bg-button-action: #666666;
            --bg-button-action-hover: #888888;
            --bg-button-delete: #ff3b30;
            --bg-button-delete-hover: #d12c23;
            --bg-button-retry: #34c759;
            --bg-button-retry-hover: #249a41;
            --bg-button-edit: #ff9500;
            --bg-button-edit-hover: #d17d00;
            --bg-button-duplicate: #8e8e93;
            --bg-button-duplicate-hover: #6b6b70;
            --bg-button-export: #0a84ff;
            --bg-button-export-hover: #0069d1;
            --bg-button-save: #30d158;
            --bg-button-save-hover: #24a345;
            --bg-button-cancel: #ff453a;
            --bg-button-cancel-hover: #d1332b;
            --bg-button-update: #0a84ff;
            --bg-button-update-hover: #0069d1;
            --bg-header: #007aff;
            --bg-message-actions: rgba(50, 50, 50, 0.8);
            --bg-overlay-dark: rgba(30, 30, 30, 0.55);
            --bg-cascade-button: var(--bg-button-action);
            --bg-cascade-button-hover: var(--bg-button-action-hover);
            --bg-cascade-delete-button: var(--bg-button-delete);
            --bg-cascade-delete-button-hover: var(--bg-button-delete-hover);
            --text-cascade-indicator: var(--text-secondary);

            --text-primary: #e0e0e0;
            --text-secondary: #aaaaaa;
            --text-light: #ffffff;
            --text-disabled: #666666;
            --text-error: #ff8a80;
            --text-link: #00aaff;
            --text-placeholder: #777777;
            --text-system: #ccc;

            --border-primary: #444444;
            --border-secondary: #555555;
            --border-tertiary: #333333;
            --border-danger: #7a2e35;
            --border-system: #4682b4;

            --shadow-primary: rgba(255, 255, 255, 0.1);
            --shadow-secondary: rgba(0, 0, 0, 0.5);
            
            --bg-dialog-file-item: var(--bg-secondary);
            --border-dialog-file-item: var(--border-primary);
            --text-dialog-file-name: var(--text-primary);
            --text-dialog-file-size: var(--text-secondary);
            --bg-dialog-button-select: var(--bg-button-action);
            --bg-dialog-button-select-hover: var(--bg-button-action-hover);
            --bg-dialog-button-confirm: var(--bg-button-save);
            --bg-dialog-button-confirm-hover: var(--bg-button-save-hover);
            --bg-dialog-button-cancel: var(--bg-button-cancel);
            --bg-dialog-button-cancel-hover: var(--bg-button-cancel-hover);

            --bg-attachment-details: rgba(255, 255, 255, 0.05);
            --border-attachment-details: var(--border-primary);
            --text-attachment-summary: var(--text-secondary);
            --text-attachment-filename: var(--text-primary);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        html, body {
            height: 100%;
            font-family: var(--font-family);
            background-color: var(--bg-secondary);
            color: var(--text-primary);
            overscroll-behavior-y: contain;
            transition: background-color 0.3s ease, color 0.3s ease;
            overflow: hidden;
        }
        button {
            cursor: pointer;
            padding: 8px 15px;
            border-radius: 5px;
            border: none;
            font-size: 14px;
            background-color: var(--bg-button);
            color: var(--text-light);
            transition: background-color 0.2s ease, color 0.2s ease;
            line-height: 1.4;
        }
        button:hover:not(:disabled) {
            background-color: var(--bg-button-hover);
        }
        button:disabled {
            background-color: var(--bg-button-disabled);
            cursor: not-allowed;
            color: var(--text-disabled);
        }
        input[type="text"],
        input[type="password"],
        input[type="number"],
        select,
        textarea {
            width: 100%;
            padding: 10px;
            border: 1px solid var(--border-primary);
            border-radius: 5px;
            font-size: 14px;
            margin-bottom: 10px;
            background-color: var(--bg-input);
            color: var(--text-primary);
            transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;
        }
        textarea {
            min-height: 80px;
            resize: vertical;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            font-size: 14px;
            color: var(--text-primary);
        }
        ::placeholder { color: var(--text-placeholder); opacity: 1; }
        :-ms-input-placeholder { color: var(--text-placeholder); }
        ::-ms-input-placeholder { color: var(--text-placeholder); }
        .hidden { display: none !important; }

        .app-container {
            display: flex;
            position: relative;
            height: 100%;
            max-width: 800px;
            margin: 0 auto;
            background-color: var(--bg-primary);
            box-shadow: 0 0 10px var(--shadow-secondary);
            overflow: hidden;
            transition: background-color 0.3s ease;
        }

        .app-header {
            display: flex;
            align-items: center;
            padding: 10px 15px;
            background-color: var(--bg-header);
            color: var(--text-light);
            flex-shrink: 0;
            position: sticky;
            top: 0;
            z-index: 10;
            transition: background-color 0.3s ease;
            gap: 10px;
        }
        .app-header h1 {
            font-size: 18px;
            font-weight: bold;
            overflow: hidden;
            white-space: nowrap;
            text-overflow: ellipsis;
            text-align: left;
            margin: 0;
            margin-right: auto;
        }
        .header-button {
            background: none;
            border: none;
            color: var(--text-light);
            font-size: 20px;
            padding: 5px;
            line-height: 1;
            min-width: 30px;
            flex-shrink: 0;
        }
        #history-screen .app-header {
            flex-direction: row-reverse;
            justify-content: flex-start;
        }
        #history-screen .app-header h1#history-title {
            margin-right: 0;
            margin-left: auto;
            text-align: right;
        }
        #history-screen .app-header #back-to-chat-from-history {
            order: 1;
        }
        #history-screen .app-header #history-title {
            order: 2;
        }
        #history-screen .app-header #import-history-btn {
            order: 3;
            margin-right: 0;
        }

        .header-save-button {
            padding: 4px 12px;
            font-size: 13px;
            background-color: var(--bg-button-save);
            color: var(--text-light);
            border-radius: 5px;
            border: none;
            cursor: pointer;
            transition: background-color 0.2s ease;
            flex-shrink: 0;
        }
        .header-save-button:hover:not(:disabled) {
            background-color: var(--bg-button-save-hover);
        }
        body.dark-mode .header-save-button {
             background-color: var(--bg-button-save);
        }
        body.dark-mode .header-save-button:hover:not(:disabled) {
             background-color: var(--bg-button-save-hover);
        }
        .header-notice {
            font-size: 11px;
            font-weight: normal;
            color: rgba(255, 255, 255, 0.8);
            text-align: right;
            white-space: nowrap;
            flex-shrink: 0;
        }
        body.dark-mode .header-notice {
            color: rgba(255, 255, 255, 0.7);
        }
        .new-chat-button {
            font-size: 14px;
            padding: 5px 10px;
            background-color: var(--bg-button-save);
            color: var(--text-light);
            flex-shrink: 0;
            border-radius: 5px;
            border: none;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        .new-chat-button:hover {
            background-color: var(--bg-button-save-hover);
        }
        body.dark-mode .new-chat-button {
            background-color: var(--bg-button-save);
        }
        body.dark-mode .new-chat-button:hover {
            background-color: var(--bg-button-save-hover);
        }

        .main-content {
            flex-grow: 1;
            overflow-y: auto;
            padding: 15px;
            position: relative;
            z-index: 1;
            touch-action: pan-y;
        }

        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            transition: transform 0.3s ease-in-out;
            background-color: var(--bg-primary);
            z-index: 0;
        }
        .screen.active {
            transform: translateX(0);
            z-index: 1;
        }
        #chat-screen { transform: translateX(0); }
        #history-screen { transform: translateX(-100%); }
        #settings-screen { transform: translateX(100%); }


        #chat-screen {
            position: relative;
            z-index: 0;
            background-image: var(--chat-background-image);
            background-size: cover;
            background-position: center center;
            background-repeat: no-repeat;
            transition: background-image 0.3s ease, transform 0.3s ease-in-out;
        }

        #chat-screen::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--bg-overlay-light);
            z-index: 0;
            transition: background-color 0.3s ease;
            pointer-events: none;
        }
        body.dark-mode #chat-screen::before {
            background-color: var(--bg-overlay-dark);
        }

        #chat-screen .main-content {
            z-index: 1;
            background-color: transparent;
            overflow-y: scroll;
            overflow-x: auto;
            touch-action: pan-x pan-y pinch-zoom;
            flex-grow: 1;
        }
        #chat-screen .app-header { z-index: 2; }
        #chat-screen .chat-input-area {
            z-index: 2;
            background-color: var(--bg-secondary);
        }
        #history-screen .main-content,
        #settings-screen .main-content {
            touch-action: pan-y;
        }


        .system-prompt-area {
            padding: 10px 15px;
            margin-bottom: 15px;
            border: 1px solid var(--border-system);
            border-radius: 8px;
            background-color: var(--bg-system-message);
            color: var(--text-system);
            transition: background-color 0.3s ease, border-color 0.3s ease, color 0.3s ease, opacity 0.3s ease, visibility 0.3s ease, max-height 0.3s ease;
            position: relative;
            z-index: 1;
            overflow: hidden;
            max-height: 500px;
        }
        .system-prompt-area.hidden {
            padding-top: 0;
            padding-bottom: 0;
            margin-bottom: 0;
            border-width: 0;
            max-height: 0;
            opacity: 0;
            visibility: hidden;
        }
        .system-prompt-area details {
            width: 100%;
        }
        .system-prompt-area summary {
            font-weight: bold;
            cursor: pointer;
            font-size: 13px;
            color: var(--text-primary);
            list-style: none;
            display: flex;
            align-items: center;
            justify-content: space-between;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            outline: none;
            -webkit-tap-highlight-color: transparent;
        }
        .system-prompt-area summary::-webkit-details-marker { display: none; }
        .system-prompt-area summary::marker { display: none; }
        .system-prompt-area summary::after {
            content: 'â–¼';
            font-size: 10px;
            margin-left: 5px;
            transition: transform 0.2s ease;
        }
        .system-prompt-area details[open] summary::after {
            transform: rotate(180deg);
        }
        .system-prompt-content {
            margin-top: 10px;
        }
        .system-prompt-content textarea {
            width: 100%;
            min-height: 60px;
            max-height: 200px;
            margin-bottom: 8px;
            font-size: 13px;
            background-color: var(--bg-input);
            color: var(--text-primary);
            border-color: var(--border-primary);
        }
        .system-prompt-actions {
            display: flex;
            justify-content: flex-end;
            gap: 8px;
        }
        .system-prompt-actions button {
            padding: 4px 10px;
            font-size: 12px;
        }
        .system-prompt-actions .save-system-prompt-btn { background-color: var(--bg-button-save); }
        .system-prompt-actions .save-system-prompt-btn:hover { background-color: var(--bg-button-save-hover); }
        .system-prompt-actions .cancel-system-prompt-btn { background-color: var(--bg-button-cancel); }
        .system-prompt-actions .cancel-system-prompt-btn:hover { background-color: var(--bg-button-cancel-hover); }

        .message-container {
            display: flex;
            flex-direction: column;
            position: relative;
            z-index: 1;
        }
        .message {
            padding: 10px 15px;
            border-radius: 15px;
            max-width: var(--message-max-width);
            min-width: 30%;
            min-height: 40px;
            position: relative;
            word-wrap: break-word;
            margin-top: 35px;
            margin-bottom: 35px;
            color: var(--text-primary);
            transition: background-color 0.3s ease, color 0.3s ease;
            z-index: 1;
            box-shadow: 0 1px 2px var(--shadow-primary);
        }
        .message:first-child {
            margin-top: 0;
        }
        .message pre {
            white-space: pre-wrap;
            word-wrap: break-word;
            font-family: inherit;
            font-size: 14px;
            margin: 0;
            color: inherit;
            transition: opacity 0.2s ease;
        }
        .message.user {
            background-color: var(--bg-user-message);
            align-self: flex-end;
            border-bottom-right-radius: 5px;
            body:not(.dark-mode) & { color: #333; }
            body.dark-mode & { color: #e0e0e0; }
        }
        .message.model {
            background-color: var(--bg-model-message);
            align-self: flex-start;
            border-bottom-left-radius: 5px;
            max-width: 90%;
        }
        .message.error {
            background-color: var(--bg-error-message);
            color: var(--text-error);
            align-self: flex-start;
            border-bottom-left-radius: 5px;
            margin-top: 10px;
            margin-bottom: 10px;
        }

        .message-actions {
            position: absolute;
            bottom: -35px;
            display: none;
            flex-wrap: nowrap;
            gap: 5px;
            background: var(--bg-message-actions);
            padding: 10px 8px 5px 8px;
            border-radius: 5px;
            box-shadow: 0 1px 3px var(--shadow-primary);
            z-index: 2;
            transition: opacity 0.2s ease, background-color 0.3s ease;
        }
        .message:hover .message-actions {
            display: flex;
        }
        .message.user .message-actions {
            right: 0;
            left: auto;
            justify-content: flex-end;
        }
        .message.model .message-actions {
            left: 0;
            right: auto;
            justify-content: flex-start;
        }
        .message-actions button {
            background-color: var(--bg-button-action);
            color: var(--text-light);
            padding: 4px 10px;
            font-size: 12px;
            border-radius: 4px;
            white-space: nowrap;
            line-height: 1.5;
        }
        .message-actions button:hover {
            background-color: var(--bg-button-action-hover);
        }
        .message-actions .js-edit-btn { background-color: var(--bg-button-edit); }
        .message-actions .js-edit-btn:hover { background-color: var(--bg-button-edit-hover); }
        .message-actions .js-delete-btn { background-color: var(--bg-button-delete); }
        .message-actions .js-delete-btn:hover { background-color: var(--bg-button-delete-hover); }
        .message-actions .js-retry-btn { background-color: var(--bg-button-retry); }
        .message-actions .js-retry-btn:hover { background-color: var(--bg-button-retry-hover); }

        .message-cascade-controls {
            position: absolute;
            top: -35px;
            left: 0;
            display: none;
            align-items: center;
            flex-wrap: nowrap;
            gap: 5px;
            background: var(--bg-message-actions);
            padding: 5px 8px 10px 8px;
            border-radius: 5px;
            box-shadow: 0 -1px 3px var(--shadow-primary);
            z-index: 2;
            transition: opacity 0.2s ease, background-color 0.3s ease;
        }
        .message.model:hover .message-cascade-controls {
            display: flex;
        }
        .message-cascade-controls button {
            background-color: var(--bg-cascade-button);
            color: var(--text-light);
            padding: 4px 8px;
            font-size: 14px;
            border-radius: 4px;
            line-height: 1;
            min-width: 25px;
        }
        .message-cascade-controls button:hover:not(:disabled) {
            background-color: var(--bg-cascade-button-hover);
        }
        .message-cascade-controls button:disabled {
            background-color: var(--bg-button-disabled);
            cursor: not-allowed;
            opacity: 0.5;
        }
        .message-cascade-controls .cascade-indicator {
            font-size: 11px;
            color: var(--text-cascade-indicator);
            padding: 0 5px;
            white-space: nowrap;
            font-weight: 500;
        }
        .message-cascade-controls .cascade-delete-btn {
            background-color: var(--bg-cascade-delete-button);
            margin-left: 5px;
        }
        .message-cascade-controls .cascade-delete-btn:hover {
            background-color: var(--bg-cascade-delete-button-hover);
        }

        .message.editing pre {
            opacity: 0;
            height: 0;
            overflow: hidden;
            pointer-events: none;
        }
        .message.editing .message-actions,
        .message.editing .message-cascade-controls {
             opacity: 0;
             pointer-events: none;
             display: none !important;
        }
        .message-edit-area {
            margin-top: 5px;
        }
        .message-edit-area textarea {
            min-height: 60px;
            margin-bottom: 5px;
            width: 100%;
        }
        .message-edit-actions {
            display: flex;
            justify-content: flex-end;
            gap: 8px;
            margin-top: 5px;
        }
        .message-edit-actions button {
            padding: 4px 10px;
            font-size: 12px;
        }
        .message-edit-actions .save-edit-btn { background-color: var(--bg-button-save); }
        .message-edit-actions .save-edit-btn:hover { background-color: var(--bg-button-save-hover); }
        .message-edit-actions .cancel-edit-btn { background-color: var(--bg-button-cancel); }
        .message-edit-actions .cancel-edit-btn:hover { background-color: var(--bg-button-cancel-hover); }

        .chat-input-area {
            display: flex;
            align-items: flex-end;
            padding: 10px 15px;
            border-top: 1px solid var(--border-primary);
            flex-shrink: 0;
            box-sizing: border-box;
            transition: background-color 0.3s ease, border-color 0.3s ease;
            gap: 10px;
        }
        .chat-input-area button#attach-file-btn {
            height: 40px;
            width: 40px;
            padding: 0;
            font-size: 20px;
            font-weight: bold;
            flex-shrink: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: var(--bg-button-action);
            position: relative;
        }
        .attachment-badge {
            position: absolute;
            top: -4px;
            right: -4px;
            width: var(--badge-size);
            height: var(--badge-size);
            background-color: var(--badge-color);
            border-radius: 50%;
            border: 1px solid var(--bg-primary);
            display: none;
            pointer-events: none;
        }
        .chat-input-area button#attach-file-btn.has-attachments .attachment-badge {
            display: block;
        }
        .chat-input-area textarea {
            flex-grow: 1;
            min-height: 40px;
            max-height: 120px;
            height: 40px;
            resize: none;
            margin-bottom: 0;
            padding: 8px 10px;
            overflow-y: auto;
        }
        .chat-input-area button#send-button {
            height: 40px;
            width: 40px;
            padding: 0;
            font-size: 18px;
            font-weight: bold;
            flex-shrink: 0;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .chat-input-area button#send-button.sending {
            background-color: #ffc107;
            color: #333;
        }
        .chat-input-area button#send-button.sending:hover {
            background-color: #ffa000;
        }
        body.dark-mode .chat-input-area button#send-button.sending {
            background-color: #ffd60a;
            color: #1a1a1a;
        }
        body.dark-mode .chat-input-area button#send-button.sending:hover {
            background-color: #ffca28;
        }

        #loading-indicator {
            position: fixed;
            bottom: 65px;
            right: 20px;
            background-color: var(--bg-tertiary);
            color: var(--text-secondary);
            padding: 6px 12px;
            border-radius: 15px;
            font-size: 11px;
            font-style: normal;
            font-weight: 500;
            z-index: 3;
            box-shadow: 0 2px 5px var(--shadow-primary);
            transition: opacity 0.3s ease, transform 0.3s ease, visibility 0.3s ease;
            opacity: 0;
            visibility: hidden;
            transform: translateY(10px);
            pointer-events: none;
        }
        #loading-indicator:not(.hidden) {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }

        body.dark-mode #loading-indicator {
            background-color: var(--bg-input);
            color: var(--text-secondary);
            box-shadow: 0 2px 6px var(--shadow-secondary);
        }

        #history-screen {
             background-color: var(--bg-primary);
             transition: transform 0.3s ease-in-out;
        }
        #history-screen .main-content {
             background-color: transparent;
        }

        .history-list {
            list-style: none;
            padding: 0;
        }
        .history-item {
            padding: 12px;
            border: 1px solid var(--border-secondary);
            border-radius: 8px;
            margin-bottom: 10px;
            background-color: var(--bg-primary);
            transition: background-color 0.2s ease, border-color 0.3s ease;
            cursor: pointer;
        }
        .history-item:hover {
            background-color: var(--bg-tertiary);
        }
        .history-item-details {
            overflow: hidden;
            min-width: 0;
            width: 100%;
            margin-bottom: 8px;
        }
        .history-item-title {
            font-size: 15px;
            font-weight: bold;
            margin-bottom: 0px;
            overflow: hidden;
            white-space: nowrap;
            text-overflow: ellipsis;
            display: block;
            color: var(--text-primary);
        }
        .history-item-bottom-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 10px;
        }
        .history-item-dates {
            font-size: 9px;
            color: var(--text-secondary);
            flex-shrink: 0;
            line-height: 1.3;
            text-align: left;
        }
        .history-item-dates span {
            display: block;
            white-space: nowrap;
        }
        .history-item-actions {
            display: flex;
            gap: 8px;
            flex-shrink: 0;
            flex-wrap: nowrap;
            cursor: default;
        }
        .history-item-actions button {
             cursor: pointer;
        }
        .history-item-actions .js-edit-title-btn {
            background-color: var(--bg-button-edit);
            font-size: 16px;
            padding: 6px 8px;
        }
        .history-item-actions .js-edit-title-btn:hover { background-color: var(--bg-button-edit-hover); }
        .history-item-actions .js-delete-btn { background-color: var(--bg-button-delete); }
        .history-item-actions .js-delete-btn:hover { background-color: var(--bg-button-delete-hover); }
        .history-item-actions .js-duplicate-btn { background-color: var(--bg-button-duplicate); }
        .history-item-actions .js-duplicate-btn:hover { background-color: var(--bg-button-duplicate-hover); }
        .history-item-actions .js-export-btn { background-color: var(--bg-button-export); }
        .history-item-actions .js-export-btn:hover { background-color: var(--bg-button-export-hover); }

        .js-history-item-template {
             display: none !important;
        }
        #no-history-message {
            text-align: center;
            color: var(--text-secondary);
            margin-top: 20px;
        }

        #settings-screen {
             background-color: var(--bg-primary);
             transition: transform 0.3s ease-in-out;
        }
         #settings-screen .main-content {
             background-color: transparent;
        }

        .settings-group {
            margin-bottom: 25px;
            padding: 15px;
            border: 1px solid var(--border-tertiary);
            border-radius: 8px;
            background-color: var(--bg-tertiary);
            transition: background-color 0.3s ease, border-color 0.3s ease;
        }
        .settings-group h3 {
            margin-bottom: 15px;
            font-size: 16px;
            color: var(--text-link);
            border-bottom: 1px solid var(--border-tertiary);
            padding-bottom: 5px;
            transition: color 0.3s ease, border-color 0.3s ease;
        }
        .settings-actions {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid var(--border-tertiary);
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .settings-actions.bottom {
            margin-bottom: 20px;
        }
        .settings-actions button {
            width: 100%;
        }
        .danger-zone {
            margin-top: 30px;
            padding-top: 20px;
            border-top: 2px solid var(--border-danger);
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .danger-zone button {
            width: 100%;
        }
        #update-app-btn {
            background-color: var(--bg-button-update);
        }
        #update-app-btn:hover {
            background-color: var(--bg-button-update-hover);
        }
        #clear-data-btn {
            background-color: var(--bg-button-delete);
        }
        #clear-data-btn:hover {
            background-color: var(--bg-button-delete-hover);
        }
        .checkbox-label {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 10px;
            cursor: pointer;
            color: var(--text-primary);
        }
        .checkbox-label input[type="checkbox"] {
            width: auto;
            margin-bottom: 0;
            cursor: pointer;
        }
        .param-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 15px;
        }

        .image-upload-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }
        .settings-action-button {
            background-color: var(--bg-button-action);
            padding: 8px 15px;
            border-radius: 5px;
            border: none;
            font-size: 14px;
            color: var(--text-light);
            cursor: pointer;
        }
        .settings-action-button:hover {
            background-color: var(--bg-button-action-hover);
        }
        .settings-delete-button {
            background-color: var(--bg-button-delete);
            padding: 8px 15px;
            border-radius: 5px;
            border: none;
            font-size: 14px;
            color: var(--text-light);
            cursor: pointer;
            margin-left: auto;
        }
        .settings-delete-button:hover {
            background-color: var(--bg-button-delete-hover);
        }
        .background-thumbnail {
            max-width: 100px;
            max-height: 60px;
            border-radius: 4px;
            border: 1px solid var(--border-tertiary);
            object-fit: cover;
            vertical-align: middle;
        }

        @media (prefers-color-scheme: dark) {
          body:not(.light-mode-forced) {
            --bg-primary: #1a1a1a;
            --bg-secondary: #101010;
            --bg-tertiary: #252525;
            --bg-input: #303030;
            --bg-user-message: #056162;
            --bg-model-message: #3a3a3c;
            --bg-system-message: #2a3a4a;
            --bg-error-message: #5c1c1c;
            --bg-button: #007aff;
            --bg-button-hover: #005ecb;
            --bg-button-disabled: #4a5a70;
            --bg-button-action: #666666;
            --bg-button-action-hover: #888888;
            --bg-button-delete: #ff3b30;
            --bg-button-delete-hover: #d12c23;
            --bg-button-retry: #34c759;
            --bg-button-retry-hover: #249a41;
            --bg-button-edit: #ff9500;
            --bg-button-edit-hover: #d17d00;
            --bg-button-duplicate: #8e8e93;
            --bg-button-duplicate-hover: #6b6b70;
            --bg-button-export: #0a84ff;
            --bg-button-export-hover: #0069d1;
            --bg-button-save: #30d158;
            --bg-button-save-hover: #24a345;
            --bg-button-cancel: #ff453a;
            --bg-button-cancel-hover: #d1332b;
            --bg-button-update: #0a84ff;
            --bg-button-update-hover: #0069d1;
            --bg-header: #007aff;
            --bg-message-actions: rgba(50, 50, 50, 0.8);
            --bg-cascade-button: var(--bg-button-action);
            --bg-cascade-button-hover: var(--bg-button-action-hover);
            --bg-cascade-delete-button: var(--bg-button-delete);
            --bg-cascade-delete-button-hover: var(--bg-button-delete-hover);
            --text-cascade-indicator: var(--text-secondary);

            --text-primary: #e0e0e0;
            --text-secondary: #aaaaaa;
            --text-light: #ffffff;
            --text-disabled: #666666;
            --text-error: #ff8a80;
            --text-link: #00aaff;
            --text-placeholder: #777777;
            --text-system: #ccc;

            --border-primary: #444444;
            --border-secondary: #555555;
            --border-tertiary: #333333;
            --border-danger: #7a2e35;
            --border-system: #4682b4;

            --shadow-primary: rgba(255, 255, 255, 0.1);
            --shadow-secondary: rgba(0, 0, 0, 0.5);
          }
        }

        .message-content {
            font-size: 14px;
            line-height: 1.6;
            color: inherit;
            word-wrap: break-word;
            overflow-wrap: break-word;
            position: relative;
            z-index: 1;
        }
        .message-content > *:first-child { margin-top: 0; }
        .message-content > *:last-child { margin-bottom: 0; }
        .message-content h1, .message-content h2, .message-content h3, .message-content h4, .message-content h5, .message-content h6 {
            margin-top: 1.2em;
            margin-bottom: 0.6em;
            font-weight: bold;
            line-height: 1.3;
            color: inherit;
        }
        .message-content h1 { font-size: 1.8em; }
        .message-content h2 { font-size: 1.5em; }
        .message-content h3 { font-size: 1.3em; }
        .message-content h4 { font-size: 1.1em; }
        .message-content p {
            margin-bottom: 0.8em;
        }
        .message-content ul, .message-content ol {
            margin-bottom: 0.8em;
            padding-left: 2em;
        }
        .message-content li {
            margin-bottom: 0.3em;
        }
        .message-content li > ul, .message-content li > ol {
             margin-top: 0.3em;
             margin-bottom: 0.3em;
        }
        .message-content pre {
            background-color: var(--bg-secondary);
            padding: 10px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 1em 0;
            font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
            font-size: 13px;
            border: 1px solid var(--border-tertiary);
            color: var(--text-secondary);
        }
        .message.user .message-content pre {
             background-color: transparent;
             padding: 0;
             margin: 0;
             border: none;
             border-radius: 0;
             color: inherit;
             font-family: inherit;
             font-size: inherit;
             line-height: inherit;
             white-space: pre-wrap;
             word-wrap: break-word;
             overflow-x: visible;
        }
        .message-content code:not(pre > code) {
            background-color: var(--bg-secondary);
            padding: 0.2em 0.4em;
            border-radius: 3px;
            font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
            font-size: 0.9em;
            border: 1px solid var(--border-tertiary);
            color: var(--text-secondary);
        }
        .message-content blockquote {
            margin: 1em 0;
            padding-left: 1em;
            border-left: 4px solid var(--border-primary);
            color: var(--text-secondary);
        }
        .message-content blockquote > *:first-child { margin-top: 0; }
        .message-content blockquote > *:last-child { margin-bottom: 0; }
        .message-content a {
            color: var(--text-link);
            text-decoration: underline;
        }
        .message-content strong {
            font-weight: bold;
        }
        .message-content em {
            font-style: italic;
        }
        .message-content table {
            border-collapse: collapse;
            margin: 1em 0;
            width: auto;
            border: 1px solid var(--border-secondary);
        }
        .message-content th, .message-content td {
            border: 1px solid var(--border-secondary);
            padding: 6px 10px;
            text-align: left;
        }
        .message-content th {
            background-color: var(--bg-tertiary);
            font-weight: bold;
        }
        .message-content hr {
            border: none;
            border-top: 1px solid var(--border-secondary);
            margin: 1.5em 0;
        }

        .message:hover .message-actions,
        .message.show-actions .message-actions,
        .message:hover .message-cascade-controls,
        .message.show-actions .message-cascade-controls {
            display: flex;
        }

        .message.editing.show-actions .message-actions,
        .message.editing.show-actions .message-cascade-controls {
            display: none !important;
        }
        .message.retrying-hidden {
            display: none !important;
        }
        body.dark-mode .message-content pre {
            background-color: var(--bg-tertiary);
            border-color: var(--border-primary);
            color: var(--text-secondary);
        }
         body.dark-mode .message-content code:not(pre > code) {
            background-color: var(--bg-tertiary);
            border-color: var(--border-primary);
            color: var(--text-secondary);
        }
        body.dark-mode .message-content blockquote {
            border-left-color: var(--border-primary);
            color: var(--text-secondary);
        }
         body.dark-mode .message-content a {
            color: var(--text-link);
         }
        body.dark-mode .message-content table,
        body.dark-mode .message-content th,
        body.dark-mode .message-content td {
            border-color: var(--border-primary);
        }
        body.dark-mode .message-content th {
            background-color: var(--bg-secondary);
        }
        body.dark-mode .message-content hr {
            border-top-color: var(--border-primary);
        }
        
        .message-actions .token-count-display {
            font-size: 0.8rem;
            color: var(--text-secondary);
            vertical-align: middle;
            line-height: 1.5;
            white-space: nowrap;
        }
        
        .custom-dialog {
            border: 1px solid var(--border-secondary);
            border-radius: 8px;
            padding: 25px;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            box-shadow: 0 5px 20px var(--shadow-secondary);
            min-width: 280px;
            max-width: 500px;
            width: fit-content;
            box-sizing: border-box;
            margin-left: auto;
            margin-right: auto;
            transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;
            position: relative;
            z-index: 100;
        }
        .custom-dialog::backdrop {
            background-color: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(3px);
            transition: background-color 0.3s ease;
            z-index: 99;
        }

        body.dark-mode .custom-dialog::backdrop {
            background-color: rgba(30, 30, 30, 0.7);
        }
        .custom-dialog[open] {
            animation: dialog-fade-in 0.3s ease forwards;
        }
        @keyframes dialog-fade-in {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .custom-dialog .dialog-message {
            margin: 0 0 20px 0;
            font-size: 15px;
            line-height: 1.6;
            display: block;
            text-align: left;
        }
        .custom-dialog .dialog-input {
            width: 100%;
            padding: 8px 10px;
            margin-bottom: 20px;
            border: 1px solid var(--border-primary);
            border-radius: 4px;
            font-size: 14px;
            background-color: var(--bg-input);
            color: var(--text-primary);
        }
        .custom-dialog .dialog-actions {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            margin-top: 15px;
        }
        .custom-dialog button {
            padding: 8px 18px;
            font-weight: 500;
            min-width: 80px;
        }
        .custom-dialog .dialog-ok-btn {
            background-color: var(--bg-button);
            color: var(--text-light);
        }
        .custom-dialog .dialog-ok-btn:hover:not(:disabled) {
            background-color: var(--bg-button-hover);
        }
         .custom-dialog .dialog-cancel-btn {
            background-color: var(--bg-button-action);
            color: var(--text-light);
        }
        .custom-dialog .dialog-cancel-btn:hover:not(:disabled) {
            background-color: var(--bg-button-action-hover);
        }
        .thought-summary-details {
            margin-bottom: 10px;
            font-size: 13px;
            border: 1px solid var(--border-tertiary);
            border-radius: 5px;
            background-color: var(--bg-tertiary);
            transition: background-color 0.3s ease, border-color 0.3s ease;
        }
        .thought-summary-details summary {
            cursor: pointer;
            font-weight: 500;
            color: var(--text-secondary);
            list-style: none;
            padding: 6px 10px;
            outline: none;
            -webkit-tap-highlight-color: transparent;
            display: flex;
            align-items: center;
            gap: 5px;
            user-select: none;
        }
        .thought-summary-details summary::-webkit-details-marker { display: none; }
        .thought-summary-details summary::marker { display: none; }
        .thought-summary-details summary::before {
            content: 'ðŸ§ ';
            font-size: 14px;
            display: inline-block;
        }
        .thought-summary-details[open] summary {
            border-bottom: 1px solid var(--border-tertiary);
        }
        .thought-summary-content {
            padding: 8px 10px;
            font-size: 13px;
            line-height: 1.5;
            color: var(--text-primary);
            word-wrap: break-word;
            overflow-wrap: break-word;
        }
        .thought-summary-content > *:first-child { margin-top: 0; }
        .thought-summary-content > *:last-child { margin-bottom: 0; }
        .thought-summary-content ul,
        .thought-summary-content ol { margin-left: 1em;}
        body.dark-mode .thought-summary-details {
            border-color: var(--border-primary);
            background-color: var(--bg-secondary);
        }
        body.dark-mode .thought-summary-details summary {
            color: var(--text-secondary);
        }
        body.dark-mode .thought-summary-details[open] summary {
            border-bottom-color: var(--border-primary);
        }
        body.dark-mode .thought-summary-content {
            color: var(--text-primary);
        }
        .thought-summary-content pre {
            background-color: var(--bg-secondary);
            padding: 8px;
            border-radius: 4px;
            overflow-x: auto;
            margin: 0.8em 0;
            font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
            font-size: 12px;
            border: 1px solid var(--border-tertiary);
            color: var(--text-secondary);
        }
        body.dark-mode .thought-summary-content pre {
            background-color: var(--bg-tertiary);
            border-color: var(--border-primary);
            color: var(--text-secondary);
        }
        .thought-summary-content code:not(pre > code) {
            background-color: var(--bg-secondary);
            padding: 0.1em 0.3em;
            border-radius: 3px;
            font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
            font-size: 0.85em;
            border: 1px solid var(--border-tertiary);
            color: var(--text-secondary);
        }
        body.dark-mode .thought-summary-content code:not(pre > code) {
            background-color: var(--bg-tertiary);
            border-color: var(--border-primary);
            color: var(--text-secondary);
        }
        .citation-details {
            margin-top: 10px;
            font-size: 12px;
            border-top: 1px dashed var(--border-secondary);
            padding-top: 8px;
        }
        .citation-details summary {
            cursor: pointer;
            font-weight: normal;
            color: var(--text-secondary);
            list-style: none;
            display: inline-block;
            outline: none;
            -webkit-tap-highlight-color: transparent;
        }
        .citation-details summary::-webkit-details-marker { display: none; }
        .citation-details summary::marker { display: none; }
        .citation-details summary:hover {
            text-decoration: underline;
        }
        .citation-list {
            list-style: none;
            padding-left: 0;
            margin-top: 8px;
            margin-bottom: 0;
        }
        .citation-list li {
            margin-bottom: 5px;
            overflow-wrap: break-word;
        }
        .citation-list li a {
            color: var(--text-link);
            text-decoration: none;
            display: block;
        }
        .citation-list li a:hover {
            text-decoration: underline;
        }
        body.dark-mode .citation-details {
            border-top-color: var(--border-primary);
        }
        body.dark-mode .citation-details summary {
            color: var(--text-secondary);
        }
        body.dark-mode .citation-list li a {
            color: var(--text-link);
        }
        .attachment-details {
            margin-top: 10px;
            font-size: 12px;
            border: 1px solid var(--border-attachment-details);
            border-radius: 5px;
            background-color: var(--bg-attachment-details);
            transition: background-color 0.3s ease, border-color 0.3s ease;
        }
        .attachment-details summary {
            cursor: pointer;
            font-weight: normal;
            color: var(--text-attachment-summary);
            list-style: none;
            padding: 5px 10px;
            outline: none;
            -webkit-tap-highlight-color: transparent;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .attachment-details summary::-webkit-details-marker { display: none; }
        .attachment-details summary::marker { display: none; }
        .attachment-details summary::before {
            content: 'ðŸ“Ž';
            font-size: 14px;
            display: inline-block;
        }
        .attachment-details[open] summary {
            border-bottom: 1px solid var(--border-attachment-details);
        }
        .attachment-list {
            list-style: none;
            padding: 8px 10px 5px 10px;
            margin: 0;
        }
        .attachment-list li {
            margin-bottom: 4px;
            font-size: 10px;
            color: var(--text-attachment-filename);
            overflow-wrap: break-word;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            line-height: 1.4;
        }

        #fileUploadDialog {
            min-width: 320px;
            max-width: 600px;
            width: 90%;
        }
        .dialog-content {
            margin-bottom: 20px;
        }
        .file-upload-area {
            margin-bottom: 15px;
            text-align: center;
        }
        .file-upload-area .dialog-button {
            padding: 10px 20px;
            font-size: 14px;
        }
        .file-upload-area #select-files-btn {
            background-color: var(--bg-dialog-button-select);
        }
        .file-upload-area #select-files-btn:hover {
            background-color: var(--bg-dialog-button-select-hover);
        }
        #selected-files-list {
            list-style: none;
            padding: 0;
            margin: 0;
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid var(--border-secondary);
            border-radius: 5px;
            background-color: var(--bg-secondary);
            transition: background-color 0.3s ease, border-color 0.3s ease;
        }
        .selected-file-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            border-bottom: 1px solid var(--border-dialog-file-item);
            background-color: var(--bg-dialog-file-item);
            transition: background-color 0.3s ease, border-color 0.3s ease;
        }
        .selected-file-item:last-child {
            border-bottom: none;
        }
        .selected-file-info {
            flex-grow: 1;
            overflow: hidden;
            margin-right: 10px;
        }
        .selected-file-name {
            display: block;
            font-size: 14px;
            color: var(--text-dialog-file-name);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .selected-file-size {
            display: block;
            font-size: 11px;
            color: var(--text-dialog-file-size);
        }
        .remove-file-btn {
            background-color: var(--bg-button-delete);
            color: var(--text-light);
            border: none;
            border-radius: 15%;
            width: 22px;
            height: 22px;
            min-width: 0 !important;
            font-size: 14px;
            line-height: 1;
            padding: 0;
            cursor: pointer;
            flex-shrink: 0;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .remove-file-btn:hover {
            background-color: var(--bg-button-delete-hover);
        }
        #file-upload-notice {
            font-size: 11px;
            color: var(--text-secondary);
            margin-top: 10px;
            text-align: center;
        }
        #fileUploadDialog .dialog-actions {
            margin-top: 20px;
        }
        #fileUploadDialog .dialog-actions #confirm-attach-btn {
            background-color: var(--bg-dialog-button-confirm);
        }
        #fileUploadDialog .dialog-actions #confirm-attach-btn:hover:not(:disabled) {
            background-color: var(--bg-dialog-button-confirm-hover);
        }
        #fileUploadDialog .dialog-actions #cancel-attach-btn {
            background-color: var(--bg-dialog-button-cancel);
        }
        #fileUploadDialog .dialog-actions #cancel-attach-btn:hover:not(:disabled) {
            background-color: var(--bg-button-cancel-hover);
        }
    </style>
    <script src="marked.js"></script>
</head>
<body>
    <div class="app-container">

        <div id="chat-screen" class="screen active">
            <header class="app-header">
                <button id="goto-history-btn" class="header-button" aria-label="å±¥æ­´ä¸€è¦§ã¸">â˜°</button>
                <h1 id="chat-title">æ–°è¦ãƒãƒ£ãƒƒãƒˆ</h1>
                <button id="new-chat-btn" class="new-chat-button" title="æ–°è¦ãƒãƒ£ãƒƒãƒˆã‚’é–‹å§‹">æ–°è¦</button>
                <button id="goto-settings-btn" class="header-button" aria-label="è¨­å®šã¸">âš™</button>
            </header>
            <main class="main-content">
                <div id="system-prompt-area" class="system-prompt-area">
                    <details id="system-prompt-details">
                        <summary>ã‚·ã‚¹ãƒ†ãƒ ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ</summary>
                        <div class="system-prompt-content">
                            <textarea id="system-prompt-editor" aria-label="ã‚·ã‚¹ãƒ†ãƒ ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆç·¨é›†"></textarea>
                            <div class="system-prompt-actions">
                                <button id="cancel-system-prompt-btn" class="cancel-system-prompt-btn">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
                                <button id="save-system-prompt-btn" class="save-system-prompt-btn">ä¿å­˜</button>
                            </div>
                        </div>
                    </details>
                </div>
                <div id="message-container" class="message-container">
                </div>
                <div id="loading-indicator" class="loading-indicator hidden" aria-live="polite">å¿œç­”ä¸­</div>
            </main>
            <footer class="chat-input-area">
                <textarea id="user-input" placeholder="ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å…¥åŠ›..." rows="1" aria-label="ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å…¥åŠ›"></textarea>
                <button id="attach-file-btn" title="ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ·»ä»˜">+<span class="attachment-badge"></span></button>
                <button id="send-button" title="é€ä¿¡">é€</button>
            </footer>
        </div>

        <div id="history-screen" class="screen">
            <header class="app-header">
                <button id="back-to-chat-from-history" class="header-button" aria-label="ãƒãƒ£ãƒƒãƒˆã¸æˆ»ã‚‹">ï¼ž</button>
                <h1 id="history-title">å±¥æ­´ä¸€è¦§</h1>
                <button id="import-history-btn" class="header-save-button" title="å±¥æ­´ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆ">ã‚¤ãƒ³ãƒãƒ¼ãƒˆ</button>
                <input type="file" id="import-history-input" accept=".txt" class="hidden">
            </header>
            <main class="main-content">
                <ul id="history-list" class="history-list">
                    <li class="js-history-item-template history-item">
                        <div class="history-item-details">
                            <span class="history-item-title"></span>
                        </div>
                        <div class="history-item-bottom-row">
                            <div class="history-item-dates">
                                <span class="created-date"></span>
                                <span class="updated-date"></span>
                            </div>
                            <div class="history-item-actions">
                                <button class="js-edit-title-btn" title="ã‚¿ã‚¤ãƒˆãƒ«ç·¨é›†">âœŽ</button>
                                <button class="js-export-btn" title="å‡ºåŠ›">å‡ºåŠ›</button>
                                <button class="js-duplicate-btn" title="è¤‡è£½">è¤‡è£½</button>
                                <button class="js-delete-btn" title="å‰Šé™¤">å‰Šé™¤</button>
                            </div>
                        </div>
                    </li>
                </ul>
                 <p id="no-history-message" class="hidden" style="text-align: center; color: var(--text-secondary); margin-top: 20px;">ãƒãƒ£ãƒƒãƒˆå±¥æ­´ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚</p>
            </main>
        </div>

        <div id="settings-screen" class="screen">
            <header class="app-header">
                 <button id="back-to-chat-from-settings" class="header-button" aria-label="ãƒãƒ£ãƒƒãƒˆã¸æˆ»ã‚‹">ï¼œ</button>
                 <h1>è¨­å®š</h1>
                 <span id="settings-save-notice" class="header-notice">â€»åæ˜ ã«ã¯ä¿å­˜ãŒå¿…è¦</span>
                 <button class="js-save-settings-btn header-save-button" title="è¨­å®šã‚’ä¿å­˜">è¨­å®šã‚’ä¿å­˜</button>
            </header>
            <main class="main-content">
                <div class="settings-group">
                    <h3>åŸºæœ¬è¨­å®š</h3>
                    <label for="api-key">Gemini APIã‚­ãƒ¼:</label>
                    <input type="password" id="api-key" placeholder="APIã‚­ãƒ¼ã‚’å…¥åŠ›" aria-label="Gemini APIã‚­ãƒ¼">

                    <label for="model-name">ãƒ¢ãƒ‡ãƒ«å:</label>
                    <select id="model-name" aria-label="ãƒ¢ãƒ‡ãƒ«å">
                        <optgroup label="ç„¡æ–™">
                            <option value="gemini-2.0-flash">gemini-2.0-flash</option>
                            <option value="gemini-2.5-flash-preview-04-17">gemini-2.5-flash-preview-04-17</option>
                            <option value="gemini-2.5-flash-preview-05-20">gemini-2.5-flash-preview-05-20</option>
                            <option value="gemini-2.5-pro-exp-03-25">gemini-2.5-pro-exp-03-25</option>
                        </optgroup>
                        <optgroup label="æœ‰æ–™">
                            <option value="gemini-2.5-pro-preview-03-25">gemini-2.5-pro-preview-03-25</option>
                            <option value="gemini-2.5-pro-preview-05-06">gemini-2.5-pro-preview-05-06</option>
                        </optgroup>
                        <optgroup label="ãƒ¦ãƒ¼ã‚¶ãƒ¼æŒ‡å®š" id="user-defined-models-group">
                        </optgroup>
                    </select>

                    <label class="checkbox-label">
                        <input type="checkbox" id="streaming-output">
                        ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°å‡ºåŠ›ã‚’ä½¿ç”¨ã™ã‚‹
                    </label>
                    <label for="streaming-speed">æ–‡å­—é€ã‚Šé€Ÿåº¦ (ãƒŸãƒªç§’/æ–‡å­—):</label>
                    <input type="number" id="streaming-speed" min="0" step="1" placeholder="ä¾‹: 30 (0ã§ç„¡åŠ¹)" aria-label="æ–‡å­—é€ã‚Šé€Ÿåº¦">
                </div>

                <div class="settings-group">
                    <h3>ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿</h3>
                    <label for="system-prompt-default">ã‚·ã‚¹ãƒ†ãƒ ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ):</label>
                    <textarea id="system-prompt-default" placeholder="ä¾‹: ã‚ãªãŸã¯è¦ªåˆ‡ãªã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆã§ã™ã€‚æ–°è¦ãƒãƒ£ãƒƒãƒˆä½œæˆæ™‚ã«é©ç”¨ã•ã‚Œã¾ã™ã€‚" aria-label="ã‚·ã‚¹ãƒ†ãƒ ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ)"></textarea>

                    <div class="param-grid">
                        <div>
                            <label for="max-tokens">Max Tokens:</label>
                            <input type="number" id="max-tokens" step="1" min="1" placeholder="ä¾‹:1024" aria-label="Max Tokens">
                        </div>
                        <div>
                            <label for="temperature">Temperature:</label>
                            <input type="number" id="temperature" step="0.1" min="0" max="2" placeholder="ä¾‹:0.9(0.0-2.0)" aria-label="Temperature">
                        </div>
                        <div>
                            <label for="top-k">Top K:</label>
                            <input type="number" id="top-k" step="1" min="1" placeholder="ä¾‹:40(1-40)" aria-label="Top K">
                        </div>
                        <div>
                            <label for="top-p">Top P:</label>
                            <input type="number" id="top-p" step="0.01" min="0" max="1" placeholder="ä¾‹:0.95(0.0 - 1.0)" aria-label="Top P">
                        </div>
                    </div>
                    
                    <details style="margin-top: 15px;">
                        <summary style="cursor: pointer; font-weight: normal; font-size: 14px; color: var(--text-link); margin-bottom: 10px;">ãã®ä»–ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿</summary>
                        <div class="param-grid">
                             <div>
                                <label for="presence-penalty">Presence Penalty:</label>
                                <input type="number" id="presence-penalty" step="0.1" min="-2.0" max="1.9" placeholder="ä¾‹:0.0 (-2.0ï½ž2.0æœªæº€)" aria-label="Presence Penalty">
                             </div>
                             <div>
                                <label for="frequency-penalty">Frequency Penalty:</label>
                                <input type="number" id="frequency-penalty" step="0.1" min="-2.0" max="1.9" placeholder="ä¾‹:0.0 (-2.0ï½ž2.0æœªæº€)" aria-label="Frequency Penalty">
                            </div>
                        </div>
                        <p style="font-size: 11px; color: var(--text-secondary); margin-top: 8px;">
                            â€» Presence/Frequency Penaltyã¯ä¸€éƒ¨ãƒ¢ãƒ‡ãƒ«ã§ã¯éžå¯¾å¿œã€APIã‚¨ãƒ©ãƒ¼ã¨ãªã‚‹å ´åˆã‚ã‚Š
                        </p>
                        <p style="height:16px;"></p>
                        <div class="param-grid">
                            <div>
                                <label for="thinking-budget">Thinking Budget:</label>
                                <input type="number" id="thinking-budget" step="1" min="0" placeholder="ä¾‹: 5000 (0ï½ž24576æ•´æ•°)" aria-label="Thinking Budget">
                            </div>
                        </div>
                        <p style="font-size: 11px; color: var(--text-secondary); margin-top: 8px;">
                            â€» Thinking Budgetã¯æ–°ã—ã„Geminiãƒ¢ãƒ‡ãƒ«ã®ã¿å¯¾å¿œã€‚0æ˜Žç¤ºã§thinkingã‚’OFFã€‚<br>
                            â€» 1ï½ž1024æŒ‡å®šæ™‚ã¯å›ºå®šã§1024ã«ãªã‚‹
                        </p>
                        <label class="checkbox-label" style="margin-top: 15px;">
                            <input type="checkbox" id="include-thoughts-toggle">
                            Include Thoughts
                        </label>
                        <p style="font-size: 11px; color: var(--text-secondary); margin-top: -5px; margin-bottom: 10px;">
                            â€» ãƒã‚§ãƒƒã‚¯æ™‚ã€ãƒ¢ãƒ‡ãƒ«ã®æ€è€ƒãƒ—ãƒ­ã‚»ã‚¹ã®è¦ç´„ãŒè¿”ã‚‹ã€‚<br>
                            â€» thinkingConfigãŒæœ‰åŠ¹ãªãƒ¢ãƒ‡ãƒ«ã§ã®ã¿æ©Ÿèƒ½ã€‚
                        </p>
                    </details>
                </div>

                <div class="settings-group">
                   <h3>ã‚¢ãƒ‰ãƒãƒ³ã‚¹ãƒ‰</h3>
                   <label for="dummy-user">ãƒ€ãƒŸãƒ¼ User ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ (é€ä¿¡æ™‚ã®ã¿è¿½åŠ ):</label>
                   <textarea id="dummy-user" placeholder="APIé€ä¿¡ç›´å‰ã« user ãƒ­ãƒ¼ãƒ«ã¨ã—ã¦å±¥æ­´æœ«å°¾ã«è¿½åŠ ã•ã‚Œã¾ã™" aria-label="ãƒ€ãƒŸãƒ¼ User ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ"></textarea>

                   <label for="dummy-model">ãƒ€ãƒŸãƒ¼ Model ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ (é€ä¿¡æ™‚ã®ã¿è¿½åŠ ):</label>
                   <textarea id="dummy-model" placeholder="APIé€ä¿¡ç›´å‰ã« model ãƒ­ãƒ¼ãƒ«ã¨ã—ã¦å±¥æ­´æœ€æœ«å°¾ã«è¿½åŠ ã•ã‚Œã¾ã™" aria-label="ãƒ€ãƒŸãƒ¼ Model ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ"></textarea>

                   <label class="checkbox-label">
                       <input type="checkbox" id="concat-dummy-model">
                       ãƒ€ãƒŸãƒ¼ãƒ¢ãƒ‡ãƒ«ã¨å›žç­”ã‚’é€£çµ
                   </label>
                   <p style="font-size: 11px; color: var(--text-secondary); margin-top: -5px; margin-bottom: 10px;">
                       â€»ãƒã‚§ãƒƒã‚¯æ™‚ã€ãƒ¢ãƒ‡ãƒ«å¿œç­”ã®å…ˆé ­ã«ä¸Šè¨˜ãƒ€ãƒŸãƒ¼Modelã®å†…å®¹ã‚’ä»˜ä¸Žã€‚
                   </p>

                   <label class="checkbox-label">
                       <input type="checkbox" id="pseudo-streaming">
                       ç–‘ä¼¼ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°ã‚’ä½¿ç”¨<br> (ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°ONæ™‚ã®ã¿æœ‰åŠ¹)
                   </label>
                   <p style="font-size: 11px; color: var(--text-secondary); margin-top: -5px; margin-bottom: 10px;">
                       â€»å®Ÿéš›ã«ã¯ä¸€æ‹¬ç”Ÿæˆã‚’å‘¼ã³ã€å¿œç­”ã¯ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°å†ç”Ÿã‚’è¡Œã†ã€‚<br>
                       æ™®é€šã®ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°ã‚ˆã‚Šç”Ÿæˆå¾…ã¡æ™‚é–“ã¯é•·ããªã‚‹ã€‚
                   </p>
                </div>
                <div class="settings-group">
                    <h3>æ¤œç´¢</h3>
                    <label class="checkbox-label">
                        <input type="checkbox" id="enable-grounding-toggle">
                        ãƒãƒƒãƒˆã‹ã‚‰æƒ…å ±ã‚’å–å¾—ã•ã›ã‚‹ (Google Search)
                    </label>
                    <p style="font-size: 11px; color: var(--text-secondary); margin-top: -5px; margin-bottom: 10px;">
                        â€» ãƒã‚§ãƒƒã‚¯æ™‚ã€ãƒ¢ãƒ‡ãƒ«ã¯å›žç­”ç”Ÿæˆã®ãŸã‚ã«Webæ¤œç´¢ã‚’è¡Œã†ã€‚<br>
                        â€» 2.0ä»¥é™ã§ã®ã¿å¯¾å¿œ(1.5ä»¥å‰ã¯äº’æ›ãªã—ã€‚ã‚¨ãƒ©ãƒ¼ã«ãªã‚‹)<br>
                        â€» æŽ¨è«–ãƒ¢ãƒ‡ãƒ«ã¯æŽ¨è«–å†…ã§æ¤œç´¢ã™ã‚‹å ´åˆãŒã‚ã‚Šã€å¼•ç”¨ãƒ‡ãƒ¼ã‚¿ãŒå¸°ã‚‰ãªã„å ´åˆãŒã‚ã‚‹ã€‚
                    </p>
                </div>
                <div class="settings-group">
                    <h3>ã‚¤ãƒ¡ãƒ¼ã‚¸ç”»åƒ</h3>
                    <label>ãƒãƒ£ãƒƒãƒˆç”»é¢ã®èƒŒæ™¯ç”»åƒ:</label>
                    <div class="image-upload-controls">
                        <input type="file" id="background-image-input" accept="image/jpeg, image/png, image/gif, image/webp" class="hidden">
                        <button id="upload-background-btn" class="settings-action-button" type="button">ç”»åƒã‚’é¸æŠž...</button>
                        <img id="background-thumbnail" src="" alt="èƒŒæ™¯ç”»åƒãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼" class="background-thumbnail hidden">
                        <button id="delete-background-btn" class="settings-delete-button hidden" type="button">ç”»åƒã‚’å‰Šé™¤</button>
                    </div>
                     <p style="font-size: 11px; color: var(--text-secondary); margin-top: 8px;">
                       â€» ç”»åƒã¯ãƒ–ãƒ©ã‚¦ã‚¶å†…ã®ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã«ä¿å­˜ã€‚<br>
                       â€» å¯èª­æ€§ã®ãŸã‚ç”»åƒã®ä¸Šã«åŠé€æ˜Žã®ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’è¡¨ç¤ºã€‚
                     </p>
                </div>

                <div class="settings-group">
                   <h3>ãã®ä»–è¨­å®š</h3>
                    <label class="checkbox-label">
                       <input type="checkbox" id="enter-to-send">
                       Enterã‚­ãƒ¼ã§é€ä¿¡ã™ã‚‹
                   </label>
                   <p style="height:10px"></p>
                   <label class="checkbox-label">
                       <input type="checkbox" id="swipe-navigation-toggle">
                       ãƒãƒ£ãƒƒãƒˆç”»é¢ã‹ã‚‰å·¦å³ã‚¹ãƒ¯ã‚¤ãƒ—ã§ç”»é¢ç§»å‹•
                   </label>
                   <p style="height:10px"></p>
                   <label class="checkbox-label">
                       <input type="checkbox" id="dark-mode-toggle">
                       ãƒ€ãƒ¼ã‚¯ãƒ¢ãƒ¼ãƒ‰ã‚’ä½¿ç”¨ã™ã‚‹
                   </label>
                   <p style="height:10px"></p>
                   <label class="checkbox-label">
                       <input type="checkbox" id="hide-system-prompt-toggle">
                       ã‚·ã‚¹ãƒ†ãƒ ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆéžè¡¨ç¤º
                   </label>
                   <p style="font-size: 11px; color: var(--text-secondary); margin-top: -5px; margin-bottom: 10px;">
                       â€» æ²¡å…¥æ„Ÿã‚’é«˜ã‚ãŸã„å ´åˆã«ã€‚éžè¡¨ç¤ºã§ã‚‚æ©Ÿèƒ½ã¯æœ‰åŠ¹ã€‚
                   </p>
                   <label for="history-sort-order">å±¥æ­´ã®ã‚½ãƒ¼ãƒˆé †:</label>
                   <select id="history-sort-order" aria-label="å±¥æ­´ã®ã‚½ãƒ¼ãƒˆé †">
                       <option value="updatedAt">æ›´æ–°æ—¥æ™‚ (æ–°ã—ã„é †)</option>
                       <option value="createdAt">ä½œæˆæ—¥æ™‚ (æ–°ã—ã„é †)</option>
                   </select>
                   <label for="font-family-input">ã‚¢ãƒ—ãƒªã®ãƒ•ã‚©ãƒ³ãƒˆ:</label>
                   <input type="text" id="font-family-input" placeholder="ä¾‹: 'Meiryo', sans-serif" aria-label="ã‚¢ãƒ—ãƒªå…¨ä½“ã®ãƒ•ã‚©ãƒ³ãƒˆ">
                   <p style="font-size: 11px; color: var(--text-secondary); margin-top: -5px; margin-bottom: 10px;">
                       â€» ç«¯æœ«ã¾ãŸã¯PCã«ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã•ã‚Œã¦ã„ã‚‹ãƒ•ã‚©ãƒ³ãƒˆåã‚’æŒ‡å®šã€‚
                   </p>
                   <label for="additional-models">è¿½åŠ ãƒ¢ãƒ‡ãƒ« (ã‚«ãƒ³ãƒžåŒºåˆ‡ã‚Š):</label>
                   <textarea id="additional-models" placeholder="ä¾‹: gemini-2.0-pro,gemini-2.0-flash-lite" aria-label="è¿½åŠ ãƒ¢ãƒ‡ãƒ«"></textarea>
                   <p style="font-size: 11px; color: var(--text-secondary); margin-top: -5px; margin-bottom: 10px;">
                       â€» è¿½åŠ å¾Œã¯è¨­å®šã‚’ä¿å­˜ã®ä¸Šã€ãƒšãƒ¼ã‚¸ã‚’ãƒªãƒ­ãƒ¼ãƒ‰ã€‚
                   </p>
                </div>

                <div class="danger-zone">
                     <p style="text-align: center; color: var(--text-secondary); font-size: 12px; margin-bottom: 10px;">
                         ãƒãƒ¼ã‚¸ãƒ§ãƒ³: <span id="app-version"></span>
                     </p>
                     <button id="update-app-btn">ã‚¢ãƒ—ãƒªã‚’æ›´æ–° (ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚¯ãƒªã‚¢)</button>
                     <p style="font-size: 11px; color: var(--text-secondary); margin-top: -5px; margin-bottom: 10px; text-align:center;">
                         â€» ã‚µãƒ¼ãƒãƒ¼å´ã®htmlãƒ•ã‚¡ã‚¤ãƒ«ãªã©ã¯ãƒ–ãƒ©ã‚¦ã‚¶ã«ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã•ã‚Œã‚‹ãŸã‚ã€<BR>
                         ã“ã®ãƒœã‚¿ãƒ³ã§æ˜Žç¤ºçš„ã«ã‚µãƒ¼ãƒãƒ¼ãŒã‹ã‚‰å†å–å¾—ã—ãªã„é™ã‚Šæ›´æ–°ã•ã‚Œãªã„ã€‚
                     </p>
                     <details style="text-align:center;">
                         <summary style="cursor: pointer; font-weight: normal; font-size: 14px; color: var(--text-link); margin-bottom: 10px;">â€»å–ã‚Šæ‰±ã„æ³¨æ„é …ç›®â€»</summary>
                         <button id="clear-data-btn">å…¨ãƒ‡ãƒ¼ã‚¿ã‚¯ãƒªã‚¢ (å±¥æ­´ã¨è¨­å®š)</button>
                         <p style="font-size: 11px; color: var(--text-secondary); margin-top:5px; margin-bottom: 10px;">
                             â€» ãƒ–ãƒ©ã‚¦ã‚¶ã«ä¿å­˜ã•ã‚Œã¦ã„ã‚‹è¨­å®šã‚„å±¥æ­´ã‚’å…¨ã¦å‰Šé™¤ã€‚<BR>
                             ï¼ï¼é–“é•ãˆã¦æŠ¼ãã†ã¨ã—ã¦ã„ãªã„ã‹æ³¨æ„ï¼ï¼
                         </p>
                     </details>
                </div>
            </main>
        </div>
    </div>

    <dialog id="alertDialog" class="custom-dialog">
        <p class="dialog-message"></p>
        <div class="dialog-actions">
            <button value="ok" class="dialog-ok-btn">OK</button>
        </div>
    </dialog>

    <dialog id="confirmDialog" class="custom-dialog">
        <p class="dialog-message"></p>
        <div class="dialog-actions">
            <button value="cancel" class="dialog-cancel-btn">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
            <button value="ok" class="dialog-ok-btn">OK</button>
        </div>
    </dialog>

    <dialog id="promptDialog" class="custom-dialog">
        <label class="dialog-message" for="promptInput"></label>
        <input type="text" id="promptInput" class="dialog-input">
        <div class="dialog-actions">
            <button value="cancel" class="dialog-cancel-btn">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
            <button value="ok" class="dialog-ok-btn">OK</button>
        </div>
    </dialog>

    <dialog id="fileUploadDialog" class="custom-dialog">
        <div class="dialog-content">
            <div class="file-upload-area">
                <input type="file" id="file-input" multiple accept="image/*,text/*,application/pdf,video/*,audio/*" class="hidden">
                <button id="select-files-btn" class="dialog-button">ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠž</button>
            </div>
            <ul id="selected-files-list">
            </ul>
            <p id="file-upload-notice">ç”»åƒã€ãƒ†ã‚­ã‚¹ãƒˆã€PDFã€å‹•ç”»ã€éŸ³å£°ãªã©ã‚’æ·»ä»˜å¯èƒ½</p>
        </div>
        <div class="dialog-actions">
            <button id="cancel-attach-btn" value="cancel" class="dialog-cancel-btn">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
            <button id="confirm-attach-btn" value="ok" class="dialog-ok-btn" disabled>æ·»ä»˜ã—ã¦é–‰ã˜ã‚‹</button>
        </div>
    </dialog>

    <script>
        const DB_NAME = 'GeminiPWA_DB';
        const DB_VERSION = 8;
        const SETTINGS_STORE = 'settings';
        const CHATS_STORE = 'chats';
        const CHAT_UPDATEDAT_INDEX = 'updatedAtIndex';
        const CHAT_CREATEDAT_INDEX = 'createdAtIndex';
        const DEFAULT_MODEL = 'gemini-2.0-flash';
        const DEFAULT_STREAMING_SPEED = 12;
        const DEFAULT_TEMPERATURE = 0.5;
        const DEFAULT_MAX_TOKENS = 4000;
        const DEFAULT_TOP_K = 40;
        const DEFAULT_TOP_P = 0.95;
        const DEFAULT_FONT_FAMILY = '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif';
        const CHAT_TITLE_LENGTH = 15;
        const TEXTAREA_MAX_HEIGHT = 120;
        const GEMINI_API_BASE_URL = 'https://generativelanguage.googleapis.com/v1beta/models/';
        const DUPLICATE_SUFFIX = ' (ã‚³ãƒ”ãƒ¼)';
        const IMPORT_PREFIX = '(å–è¾¼) ';
        const LIGHT_THEME_COLOR = '#4a90e2';
        const DARK_THEME_COLOR = '#007aff';
        const APP_VERSION = "0.26";
        const SWIPE_THRESHOLD = 50;
        const ZOOM_THRESHOLD = 1.01;
        const MAX_FILE_SIZE = 10 * 1024 * 1024;
        const MAX_TOTAL_ATTACHMENT_SIZE = 50 * 1024 * 1024;

        const extensionToMimeTypeMap = {
            'pdf': 'application/pdf',
            'js': 'text/javascript',
            'py': 'text/x-python',
            'txt': 'text/plain',
            'html': 'text/html',
            'htm': 'text/html',
            'css': 'text/css',
            'md': 'text/md',
            'csv': 'text/csv',
            'xml': 'text/xml',
            'rtf': 'text/rtf',
            'png': 'image/png',
            'jpg': 'image/jpeg',
            'jpeg': 'image/jpeg',
            'webp': 'image/webp',
            'heic': 'image/heic',
            'heif': 'image/heif',
            'mp4': 'video/mp4',
            'mpeg': 'video/mpeg',
            'mov': 'video/mov',
            'avi': 'video/avi',
            'flv': 'video/x-flv',
            'mpg': 'video/mpg',
            'webm': 'video/webm',
            'wmv': 'video/wmv',
            '3gp': 'video/3gpp',
            '3gpp': 'video/3gpp',
            'wav': 'audio/wav',
            'mp3': 'audio/mp3',
            'aiff': 'audio/aiff',
            'aac': 'audio/aac',
            'ogg': 'audio/ogg',
            'flac': 'audio/flac',
        };
        
        const elements = {
            appContainer: document.querySelector('.app-container'),
            chatScreen: document.getElementById('chat-screen'),
            historyScreen: document.getElementById('history-screen'),
            settingsScreen: document.getElementById('settings-screen'),
            chatTitle: document.getElementById('chat-title'),
            messageContainer: document.getElementById('message-container'),
            userInput: document.getElementById('user-input'),
            sendButton: document.getElementById('send-button'),
            loadingIndicator: document.getElementById('loading-indicator'),
            historyList: document.getElementById('history-list'),
            historyTitle: document.getElementById('history-title'),
            noHistoryMessage: document.getElementById('no-history-message'),
            historyItemTemplate: document.querySelector('.js-history-item-template'),
            themeColorMeta: document.getElementById('theme-color-meta'),
            systemPromptArea: document.getElementById('system-prompt-area'),
            systemPromptDetails: document.getElementById('system-prompt-details'),
            systemPromptEditor: document.getElementById('system-prompt-editor'),
            saveSystemPromptBtn: document.getElementById('save-system-prompt-btn'),
            cancelSystemPromptBtn: document.getElementById('cancel-system-prompt-btn'),
            apiKeyInput: document.getElementById('api-key'),
            modelNameSelect: document.getElementById('model-name'),
            userDefinedModelsGroup: document.getElementById('user-defined-models-group'),
            streamingOutputCheckbox: document.getElementById('streaming-output'),
            streamingSpeedInput: document.getElementById('streaming-speed'),
            systemPromptDefaultTextarea: document.getElementById('system-prompt-default'),
            temperatureInput: document.getElementById('temperature'),
            maxTokensInput: document.getElementById('max-tokens'),
            topKInput: document.getElementById('top-k'),
            topPInput: document.getElementById('top-p'),
            presencePenaltyInput: document.getElementById('presence-penalty'),
            frequencyPenaltyInput: document.getElementById('frequency-penalty'),
            thinkingBudgetInput: document.getElementById('thinking-budget'),
            includeThoughtsToggle: document.getElementById('include-thoughts-toggle'),
            dummyUserInput: document.getElementById('dummy-user'),
            dummyModelInput: document.getElementById('dummy-model'),
            concatDummyModelCheckbox: document.getElementById('concat-dummy-model'),
            additionalModelsTextarea: document.getElementById('additional-models'),
            pseudoStreamingCheckbox: document.getElementById('pseudo-streaming'),
            enterToSendCheckbox: document.getElementById('enter-to-send'),
            historySortOrderSelect: document.getElementById('history-sort-order'),
            darkModeToggle: document.getElementById('dark-mode-toggle'),
            fontFamilyInput: document.getElementById('font-family-input'),
            hideSystemPromptToggle: document.getElementById('hide-system-prompt-toggle'),
            enableGroundingToggle: document.getElementById('enable-grounding-toggle'),
            appVersionSpan: document.getElementById('app-version'),
            backgroundImageInput: document.getElementById('background-image-input'),
            uploadBackgroundBtn: document.getElementById('upload-background-btn'),
            backgroundThumbnail: document.getElementById('background-thumbnail'),
            deleteBackgroundBtn: document.getElementById('delete-background-btn'),
            gotoHistoryBtn: document.getElementById('goto-history-btn'),
            gotoSettingsBtn: document.getElementById('goto-settings-btn'),
            backToChatFromHistoryBtn: document.getElementById('back-to-chat-from-history'),
            backToChatFromSettingsBtn: document.getElementById('back-to-chat-from-settings'),
            newChatBtn: document.getElementById('new-chat-btn'),
            saveSettingsBtns: document.querySelectorAll('.js-save-settings-btn'),
            updateAppBtn: document.getElementById('update-app-btn'),
            clearDataBtn: document.getElementById('clear-data-btn'),
            importHistoryBtn: document.getElementById('import-history-btn'),
            importHistoryInput: document.getElementById('import-history-input'),
            alertDialog: document.getElementById('alertDialog'),
            alertMessage: document.getElementById('alertDialog').querySelector('.dialog-message'),
            alertOkBtn: document.getElementById('alertDialog').querySelector('.dialog-ok-btn'),
            confirmDialog: document.getElementById('confirmDialog'),
            confirmMessage: document.getElementById('confirmDialog').querySelector('.dialog-message'),
            confirmOkBtn: document.getElementById('confirmDialog').querySelector('.dialog-ok-btn'),
            confirmCancelBtn: document.getElementById('confirmDialog').querySelector('.dialog-cancel-btn'),
            promptDialog: document.getElementById('promptDialog'),
            promptMessage: document.getElementById('promptDialog').querySelector('.dialog-message'),
            promptInput: document.getElementById('promptDialog').querySelector('.dialog-input'),
            promptOkBtn: document.getElementById('promptDialog').querySelector('.dialog-ok-btn'),
            promptCancelBtn: document.getElementById('promptDialog').querySelector('.dialog-cancel-btn'),
            swipeNavigationToggle: document.getElementById('swipe-navigation-toggle'),
            attachFileBtn: document.getElementById('attach-file-btn'),
            fileUploadDialog: document.getElementById('fileUploadDialog'),
            fileInput: document.getElementById('file-input'),
            selectFilesBtn: document.getElementById('select-files-btn'),
            selectedFilesList: document.getElementById('selected-files-list'),
            confirmAttachBtn: document.getElementById('confirm-attach-btn'),
            cancelAttachBtn: document.getElementById('cancel-attach-btn'),
        };

        const state = {
            db: null,
            currentChatId: null,
            currentMessages: [],
            currentSystemPrompt: '',
            settings: {
                apiKey: '',
                modelName: DEFAULT_MODEL,
                streamingOutput: true,
                streamingSpeed: DEFAULT_STREAMING_SPEED,
                systemPrompt: '',
                temperature: null,
                maxTokens: null,
                topK: null,
                topP: null,
                presencePenalty: null,
                frequencyPenalty: null,
                thinkingBudget: null,
                includeThoughts: true,
                dummyUser: '',
                dummyModel: '',
                concatDummyModel: false,
                additionalModels: '',
                pseudoStreaming: false,
                enterToSend: true,
                historySortOrder: 'updatedAt',
                darkMode: false,
                backgroundImageBlob: null,
                fontFamily: '',
                hideSystemPromptInChat: false,
                enableGrounding: false,
                enableSwipeNavigation: true,
            },
            backgroundImageUrl: null,
            isSending: false,
            abortController: null,
            partialStreamContent: '',
            partialThoughtStreamContent: '',
            editingMessageIndex: null,
            isEditingSystemPrompt: false,
            touchStartX: 0,
            touchStartY: 0,
            touchEndX: 0,
            touchEndY: 0,
            isSwiping: false,
            isZoomed: false,
            currentScreen: 'chat',
            selectedFilesForUpload: [],
            pendingAttachments: [],
        };

        function updateMessageMaxWidthVar() {
            const container = elements.messageContainer;
            if (!container) return;
            let maxWidthPx = container.clientWidth * 0.8;
            document.documentElement.style.setProperty('--message-max-width', `${maxWidthPx}px`);
        }

        let resizeTimer;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimer);
            resizeTimer = setTimeout(updateMessageMaxWidthVar, 150);
        });

        const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        function fileToBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => {
                    const base64String = reader.result.split(',')[1];
                    resolve(base64String);
                };
                reader.onerror = error => reject(error);
                reader.readAsDataURL(file);
            });
        }
        
        function registerServiceWorker() {
            if ('serviceWorker' in navigator) {
                window.addEventListener('load', () => {
                    navigator.serviceWorker.register('./sw.js')
                        .then(registration => {
                            console.log('ServiceWorkerç™»éŒ²æˆåŠŸ ã‚¹ã‚³ãƒ¼ãƒ—: ', registration.scope);
                            navigator.serviceWorker.addEventListener('message', event => {
                                if (event.data && event.data.action === 'reloadPage') {
                                    alert('ã‚¢ãƒ—ãƒªãŒæ›´æ–°ã•ã‚Œã¾ã—ãŸã€‚ãƒšãƒ¼ã‚¸ã‚’ãƒªãƒ­ãƒ¼ãƒ‰ã—ã¾ã™ã€‚');
                                    window.location.reload();
                                }
                            });
                        })
                        .catch(err => {
                            console.error('ServiceWorkerç™»éŒ²å¤±æ•—: ', err);
                        });
                });
            } else {
                console.warn('ã“ã®ãƒ–ãƒ©ã‚¦ã‚¶ã¯Service Workerã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã›ã‚“ã€‚');
            }
        }

        const dbUtils = {
            openDB() {
                return new Promise((resolve, reject) => {
                    if (state.db) {
                        resolve(state.db);
                        return;
                    }
                    const request = indexedDB.open(DB_NAME, DB_VERSION);

                    request.onerror = (event) => {
                        console.error("IndexedDBã‚¨ãƒ©ãƒ¼:", event.target.error);
                        reject(`IndexedDBã‚¨ãƒ©ãƒ¼: ${event.target.error}`);
                    };

                    request.onsuccess = (event) => {
                        state.db = event.target.result;
                        console.log("IndexedDBã‚ªãƒ¼ãƒ—ãƒ³æˆåŠŸ");
                        state.db.onerror = (event) => {
                            console.error(`ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚¨ãƒ©ãƒ¼: ${event.target.error}`);
                        };
                        resolve(state.db);
                    };

                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        const transaction = event.target.transaction;
                        console.log(`IndexedDBã‚’ãƒãƒ¼ã‚¸ãƒ§ãƒ³ ${event.oldVersion} ã‹ã‚‰ ${event.newVersion} ã¸ã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰ä¸­...`);

                        if (!db.objectStoreNames.contains(SETTINGS_STORE)) {
                            db.createObjectStore(SETTINGS_STORE, { keyPath: 'key' });
                            console.log(`ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚¹ãƒˆã‚¢ ${SETTINGS_STORE} ä½œæˆ`);
                        }

                        let chatStore;
                        if (!db.objectStoreNames.contains(CHATS_STORE)) {
                            chatStore = db.createObjectStore(CHATS_STORE, { keyPath: 'id', autoIncrement: true });
                            console.log(`ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚¹ãƒˆã‚¢ ${CHATS_STORE} ä½œæˆ`);
                        } else {
                             if (transaction) {
                                try { chatStore = transaction.objectStore(CHATS_STORE); } catch (e) { console.error("ãƒãƒ£ãƒƒãƒˆã‚¹ãƒˆã‚¢ã®å–å¾—ä¸­ã«ã‚¨ãƒ©ãƒ¼(ã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰):", e); return; }
                            } else { console.warn("ãƒãƒ£ãƒƒãƒˆã‚¹ãƒˆã‚¢ã®ã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰ç”¨ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³å–å¾—å¤±æ•—"); }
                        }

                        if (chatStore && !chatStore.indexNames.contains(CHAT_UPDATEDAT_INDEX)) {
                            chatStore.createIndex(CHAT_UPDATEDAT_INDEX, 'updatedAt', { unique: false });
                            console.log(`ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ ${CHAT_UPDATEDAT_INDEX} ã‚’ ${CHATS_STORE} ã«ä½œæˆ`);
                        }
                        if (chatStore && !chatStore.indexNames.contains(CHAT_CREATEDAT_INDEX)) {
                            chatStore.createIndex(CHAT_CREATEDAT_INDEX, 'createdAt', { unique: false });
                            console.log(`ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ ${CHAT_CREATEDAT_INDEX} ã‚’ ${CHATS_STORE} ã«ä½œæˆ`);
                        }
                        if (event.oldVersion < 8) {
                            console.log("DBã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰: æ–°ã—ã„ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒ•ãƒ©ã‚°ã¯å‹•çš„ã«å‡¦ç†ã•ã‚Œã¾ã™ã€‚");
                        }
                    };
                });
            },

            _getStore(storeName, mode = 'readonly') {
                if (!state.db) throw new Error("ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ãŒé–‹ã‹ã‚Œã¦ã„ã¾ã›ã‚“");
                const transaction = state.db.transaction([storeName], mode);
                return transaction.objectStore(storeName);
            },

            async saveSetting(key, value) {
                await this.openDB();
                return new Promise((resolve, reject) => {
                     try {
                        const store = this._getStore(SETTINGS_STORE, 'readwrite');
                        const request = store.put({ key, value });
                        request.onsuccess = () => {
                             resolve();
                        };
                        request.onerror = (event) => {
                             console.error(`è¨­å®š ${key} ã®ä¿å­˜ã‚¨ãƒ©ãƒ¼:`, event.target.error);
                             reject(`è¨­å®š ${key} ã®ä¿å­˜ã‚¨ãƒ©ãƒ¼: ${event.target.error}`);
                        };
                    } catch (error) {
                        console.error(`è¨­å®š ${key} ä¿å­˜ã®ãŸã‚ã®ã‚¹ãƒˆã‚¢ã‚¢ã‚¯ã‚»ã‚¹ã‚¨ãƒ©ãƒ¼:`, error);
                        reject(`è¨­å®š ${key} ä¿å­˜ã®ãŸã‚ã®ã‚¹ãƒˆã‚¢ã‚¢ã‚¯ã‚»ã‚¹ã‚¨ãƒ©ãƒ¼: ${error}`);
                    }
                });
            },

            async loadSettings() {
                await this.openDB();
                return new Promise((resolve, reject) => {
                    const store = this._getStore(SETTINGS_STORE);
                    const request = store.getAll();

                    request.onsuccess = (event) => {
                        const settingsArray = event.target.result;
                        const loadedSettings = {};
                        settingsArray.forEach(item => {
                            loadedSettings[item.key] = item.value;
                        });

                        const defaultSettings = { ...state.settings };
                        state.settings = { ...defaultSettings };

                        for (const key in loadedSettings) {
                             if (key in defaultSettings) {
                                const loadedValue = loadedSettings[key];
                                const defaultValue = defaultSettings[key];

                                if (key === 'backgroundImageBlob') {
                                    if (loadedValue instanceof Blob) {
                                         state.settings[key] = loadedValue;
                                    } else {
                                         if (loadedValue !== null) console.warn(`èª­ã¿è¾¼ã‚“ã  'backgroundImageBlob' ãŒBlobã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚nullã«è¨­å®šã—ã¾ã™ã€‚åž‹: ${typeof loadedValue}`);
                                         state.settings[key] = null;
                                    }
                                } else if (key === 'hideSystemPromptInChat') {
                                    state.settings[key] = loadedValue === true;
                                } else if (key === 'enableGrounding') {
                                    state.settings[key] = loadedValue === true;
                                } else if (key === 'enableSwipeNavigation') {
                                    state.settings[key] = loadedValue === true;
                                } else if (key === 'darkMode' || key === 'streamingOutput' || key === 'pseudoStreaming' || key === 'enterToSend' || key === 'concatDummyModel') {
                                     state.settings[key] = loadedValue === true;
                                } else if (key === 'thinkingBudget') {
                                    const num = parseInt(loadedValue, 10);
                                    if (isNaN(num) || num < 0) {
                                        state.settings[key] = null;
                                    } else {
                                        state.settings[key] = num;
                                    }
                                } else if (typeof defaultValue === 'number' || defaultValue === null) {
                                     let num;
                                     if (key === 'temperature' || key === 'topP' || key === 'presencePenalty' || key === 'frequencyPenalty') {
                                         num = parseFloat(loadedValue);
                                     } else {
                                         num = parseInt(loadedValue, 10);
                                     }
                                     if (isNaN(num)) {
                                         if ((key === 'temperature' || key === 'maxTokens' || key === 'topK' || key === 'topP' || key === 'presencePenalty' || key === 'frequencyPenalty') && (loadedValue === null || loadedValue === '')) {
                                              state.settings[key] = null;
                                         } else {
                                              state.settings[key] = defaultValue;
                                         }
                                     } else {
                                          if (key === 'temperature' && (num < 0 || num > 2)) num = defaultValue;
                                          if (key === 'maxTokens' && num < 1) num = defaultValue;
                                          if (key === 'topK' && num < 1) num = defaultValue;
                                          if (key === 'topP' && (num < 0 || num > 1)) num = defaultValue;
                                          if (key === 'streamingSpeed' && num < 0) num = defaultValue;
                                          if ((key === 'presencePenalty' || key === 'frequencyPenalty') && (num < -2.0 || num > 2.0)) num = defaultValue;
                                          state.settings[key] = num;
                                     }
                                } else if (typeof defaultValue === 'string') {
                                     state.settings[key] = typeof loadedValue === 'string' ? loadedValue : defaultValue;
                                } else {
                                    console.warn(`äºˆæœŸã—ãªã„è¨­å®šã‚¿ã‚¤ãƒ— ã‚­ãƒ¼: ${key}`);
                                    state.settings[key] = loadedValue;
                                }
                            } else {
                                console.warn(`DBã‹ã‚‰èª­ã¿è¾¼ã‚“ã æœªçŸ¥ã®è¨­å®šã‚’ç„¡è¦–: ${key}`);
                            }
                        }

                        if (state.settings.darkMode !== true && window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                             console.log("OSã®ãƒ€ãƒ¼ã‚¯ãƒ¢ãƒ¼ãƒ‰è¨­å®šã‚’åˆæœŸé©ç”¨");
                             state.settings.darkMode = true;
                        }

                        console.log("è¨­å®šèª­ã¿è¾¼ã¿å®Œäº†:", { ...state.settings, backgroundImageBlob: state.settings.backgroundImageBlob ? '[Blob]' : null });
                        resolve(state.settings);
                    };
                    request.onerror = (event) => reject(`è¨­å®šèª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼: ${event.target.error}`);
                });
            },

            async saveChat(optionalTitle = null) {
                await this.openDB();
                if ((!state.currentMessages || state.currentMessages.length === 0) && !state.currentSystemPrompt) {
                    if(state.currentChatId) console.log(`saveChat: æ—¢å­˜ãƒãƒ£ãƒƒãƒˆ ${state.currentChatId} ã«ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚‚ã‚·ã‚¹ãƒ†ãƒ ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚‚ãªã„ãŸã‚ä¿å­˜ã›ãš`);
                    else console.log("saveChat: æ–°è¦ãƒãƒ£ãƒƒãƒˆã«ä¿å­˜ã™ã‚‹ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚‚ã‚·ã‚¹ãƒ†ãƒ ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚‚ãªã—");
                    return Promise.resolve(state.currentChatId);
                }

                return new Promise((resolve, reject) => {
                    const store = this._getStore(CHATS_STORE, 'readwrite');
                    const now = Date.now();
                    const messagesToSave = state.currentMessages.map(msg => ({
                        role: msg.role,
                        content: msg.content,
                        timestamp: msg.timestamp,
                        thoughtSummary: msg.thoughtSummary || null,
                        ...(msg.finishReason && { finishReason: msg.finishReason }),
                        ...(msg.safetyRatings && { safetyRatings: msg.safetyRatings }),
                        ...(msg.error && { error: msg.error }),
                        ...(msg.isCascaded !== undefined && { isCascaded: msg.isCascaded }),
                        ...(msg.isSelected !== undefined && { isSelected: msg.isSelected }),
                        ...(msg.siblingGroupId !== undefined && { siblingGroupId: msg.siblingGroupId }),
                        ...(msg.groundingMetadata && { groundingMetadata: msg.groundingMetadata }),
                        ...(msg.attachments && msg.attachments.length > 0 && { attachments: msg.attachments }),
                        ...(msg.usageMetadata && { usageMetadata: msg.usageMetadata }),
                    }));

                    const determineTitleAndSave = (existingChatData = null) => {
                        let title;
                        if (optionalTitle !== null) {
                            title = optionalTitle;
                        } else if (existingChatData && existingChatData.title) {
                            title = existingChatData.title;
                        } else {
                            const firstUserMessage = state.currentMessages.find(m => m.role === 'user');
                            title = firstUserMessage ? firstUserMessage.content.substring(0, 50) : "ç„¡é¡Œã®ãƒãƒ£ãƒƒãƒˆ";
                        }

                        const chatIdForOperation = existingChatData ? existingChatData.id : state.currentChatId;
                        const chatData = {
                            messages: messagesToSave,
                            systemPrompt: state.currentSystemPrompt,
                            updatedAt: now,
                            createdAt: existingChatData ? existingChatData.createdAt : now,
                            title: title,
                        };
                        if (chatIdForOperation) {
                            chatData.id = chatIdForOperation;
                        }

                        const request = store.put(chatData);
                        request.onsuccess = (event) => {
                            const savedId = event.target.result;
                            if (!state.currentChatId && savedId) {
                                state.currentChatId = savedId;
                            }
                            console.log(`ãƒãƒ£ãƒƒãƒˆ ${state.currentChatId ? 'æ›´æ–°' : 'ä¿å­˜'} å®Œäº† ID:`, state.currentChatId || savedId);
                            if ((state.currentChatId || savedId) === (chatIdForOperation || savedId)) {
                                uiUtils.updateChatTitle(chatData.title);
                            }
                            resolve(state.currentChatId || savedId);
                        };
                        request.onerror = (event) => reject(`ãƒãƒ£ãƒƒãƒˆä¿å­˜ã‚¨ãƒ©ãƒ¼: ${event.target.error}`);
                    };

                    if (state.currentChatId) {
                        const getRequest = store.get(state.currentChatId);
                        getRequest.onsuccess = (event) => {
                            const existingChat = event.target.result;
                             if (!existingChat) {
                                 console.warn(`ID ${state.currentChatId} ã®ãƒãƒ£ãƒƒãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“(ä¿å­˜æ™‚)ã€‚æ–°è¦ã¨ã—ã¦ä¿å­˜ã—ã¾ã™ã€‚`);
                                 state.currentChatId = null;
                                 determineTitleAndSave(null);
                            } else {
                                determineTitleAndSave(existingChat);
                            }
                        };
                        getRequest.onerror = (event) => {
                            console.error("æ—¢å­˜ãƒãƒ£ãƒƒãƒˆã®å–å¾—ã‚¨ãƒ©ãƒ¼(æ›´æ–°ç”¨):", event.target.error);
                            console.warn("æ—¢å­˜ãƒãƒ£ãƒƒãƒˆå–å¾—ã‚¨ãƒ©ãƒ¼ã®ãŸã‚ã€æ–°è¦ã¨ã—ã¦ä¿å­˜ã‚’è©¦ã¿ã¾ã™ã€‚");
                            state.currentChatId = null;
                            determineTitleAndSave(null);
                        };
                    } else {
                        determineTitleAndSave(null);
                    }

                    store.transaction.onerror = (event) => {
                        console.error("ãƒãƒ£ãƒƒãƒˆä¿å­˜ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³å¤±æ•—:", event.target.error);
                        reject(`ãƒãƒ£ãƒƒãƒˆä¿å­˜ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³å¤±æ•—: ${event.target.error}`);
                    };
                });
            },

            async updateChatTitleDb(id, newTitle) {
                await this.openDB();
                return new Promise((resolve, reject) => {
                    const store = this._getStore(CHATS_STORE, 'readwrite');
                    const getRequest = store.get(id);
                    getRequest.onsuccess = (event) => {
                        const chatData = event.target.result;
                        if (chatData) {
                            chatData.title = newTitle;
                            chatData.updatedAt = Date.now();
                            const putRequest = store.put(chatData);
                            putRequest.onsuccess = () => resolve();
                            putRequest.onerror = (event) => reject(`ã‚¿ã‚¤ãƒˆãƒ«æ›´æ–°ã‚¨ãƒ©ãƒ¼: ${event.target.error}`);
                        } else {
                            reject(`ãƒãƒ£ãƒƒãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: ${id}`);
                        }
                    };
                    getRequest.onerror = (event) => reject(`ã‚¿ã‚¤ãƒˆãƒ«æ›´æ–°ç”¨ãƒãƒ£ãƒƒãƒˆå–å¾—ã‚¨ãƒ©ãƒ¼: ${event.target.error}`);
                    store.transaction.onerror = (event) => reject(`ã‚¿ã‚¤ãƒˆãƒ«æ›´æ–°ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³å¤±æ•—: ${event.target.error}`);
                });
            },

            async getChat(id) {
                await this.openDB();
                return new Promise((resolve, reject) => {
                    const store = this._getStore(CHATS_STORE);
                    const request = store.get(id);
                    request.onsuccess = (event) => resolve(event.target.result);
                    request.onerror = (event) => reject(`ãƒãƒ£ãƒƒãƒˆ ${id} å–å¾—ã‚¨ãƒ©ãƒ¼: ${event.target.error}`);
                });
            },

            async getAllChats(sortBy = 'updatedAt') {
                await this.openDB();
                return new Promise((resolve, reject) => {
                    const store = this._getStore(CHATS_STORE);
                    const indexName = sortBy === 'createdAt' ? CHAT_CREATEDAT_INDEX : CHAT_UPDATEDAT_INDEX;
                    if (!store.indexNames.contains(indexName)) {
                         console.error(`ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ "${indexName}" ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚ä¸»ã‚­ãƒ¼é †ã§ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã—ã¾ã™ã€‚`);
                         const getAllRequest = store.getAll();
                         getAllRequest.onsuccess = (event) => resolve(event.target.result.reverse());
                         getAllRequest.onerror = (event) => reject(`å…¨ãƒãƒ£ãƒƒãƒˆå–å¾—ã‚¨ãƒ©ãƒ¼(ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯): ${event.target.error}`);
                         return;
                    }
                    const index = store.index(indexName);
                    const request = index.openCursor(null, 'prev');
                    const chats = [];
                    request.onsuccess = (event) => {
                        const cursor = event.target.result;
                        if (cursor) {
                            chats.push(cursor.value);
                            cursor.continue();
                        } else {
                            resolve(chats);
                        }
                    };
                    request.onerror = (event) => reject(`å…¨ãƒãƒ£ãƒƒãƒˆå–å¾—ã‚¨ãƒ©ãƒ¼ (${sortBy}é †): ${event.target.error}`);
                });
            },

            async deleteChat(id) {
                await this.openDB();
                return new Promise((resolve, reject) => {
                    const store = this._getStore(CHATS_STORE, 'readwrite');
                    const request = store.delete(id);
                    request.onsuccess = () => { console.log("ãƒãƒ£ãƒƒãƒˆå‰Šé™¤:", id); resolve(); };
                    request.onerror = (event) => reject(`ãƒãƒ£ãƒƒãƒˆ ${id} å‰Šé™¤ã‚¨ãƒ©ãƒ¼: ${event.target.error}`);
                });
            },

            async clearAllData() {
                await this.openDB();
                return new Promise((resolve, reject) => {
                    const transaction = state.db.transaction([SETTINGS_STORE, CHATS_STORE], 'readwrite');
                    let storesCleared = 0;
                    const totalStores = 2;

                    const onComplete = () => {
                        if (++storesCleared === totalStores) {
                            console.log("IndexedDBã®å…¨ãƒ‡ãƒ¼ã‚¿å‰Šé™¤å®Œäº†");
                            resolve();
                        }
                    };
                    const onError = (storeName, event) => reject(`${storeName} ã‚¯ãƒªã‚¢ã‚¨ãƒ©ãƒ¼: ${event.target.error}`);

                    const settingsStore = transaction.objectStore(SETTINGS_STORE);
                    const chatsStore = transaction.objectStore(CHATS_STORE);

                    const clearSettingsReq = settingsStore.clear();
                    const clearChatsReq = chatsStore.clear();

                    clearSettingsReq.onsuccess = onComplete;
                    clearSettingsReq.onerror = (e) => onError(SETTINGS_STORE, e);
                    clearChatsReq.onsuccess = onComplete;
                    clearChatsReq.onerror = (e) => onError(CHATS_STORE, e);

                    transaction.onerror = (event) => reject(`ãƒ‡ãƒ¼ã‚¿ã‚¯ãƒªã‚¢ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³å¤±æ•—: ${event.target.error}`);
                });
            }
        };

        const uiUtils = {
            renderChatMessages() {
                if (state.editingMessageIndex !== null) {
                    const messageElement = elements.messageContainer.querySelector(`.message[data-index="${state.editingMessageIndex}"]`);
                    if(messageElement) appLogic.cancelEditMessage(state.editingMessageIndex, messageElement);
                    else state.editingMessageIndex = null;
                }
                elements.messageContainer.innerHTML = '';

                let currentSiblingGroupId = null;
                let siblingsInGroup = [];
                let siblingIndex = 0;

                for (let i = 0; i < state.currentMessages.length; i++) {
                    const msg = state.currentMessages[i];

                    if (msg.role === 'model' && msg.isCascaded && msg.siblingGroupId) {
                        if (msg.siblingGroupId !== currentSiblingGroupId) {
                            currentSiblingGroupId = msg.siblingGroupId;
                            siblingsInGroup = state.currentMessages.filter(m => m.role === 'model' && m.isCascaded && m.siblingGroupId === currentSiblingGroupId);
                            siblingIndex = 0;
                        }

                        const currentIndexInGroup = siblingsInGroup.findIndex(m => m === msg);
                        if (currentIndexInGroup !== -1) {
                            siblingIndex = currentIndexInGroup + 1;
                        }

                        if (msg.isSelected) {
                            this.appendMessage(msg.role, msg.content, i, false, {
                                currentIndex: siblingIndex,
                                total: siblingsInGroup.length,
                                siblingGroupId: currentSiblingGroupId
                            }, msg.attachments);
                        } else {
                            console.log(`Skipping render for non-selected cascaded message index ${i}`);
                        }
                    } else {
                        currentSiblingGroupId = null;
                        siblingsInGroup = [];
                        this.appendMessage(msg.role, msg.content, i, false, null, msg.attachments);
                    }
                }
            },

            appendMessage(role, content, index, isStreamingPlaceholder = false, cascadeInfo = null, attachments = null) {
                const messageDiv = document.createElement('div');
                messageDiv.classList.add('message', role);
                messageDiv.dataset.index = index;

                const messageData = state.currentMessages[index];
                
                if (role === 'model' && messageData && messageData.thoughtSummary) {
                    const thoughtDetails = document.createElement('details');
                    thoughtDetails.classList.add('thought-summary-details');

                    const thoughtSummaryElem = document.createElement('summary');
                    thoughtSummaryElem.textContent = 'æ€è€ƒãƒ—ãƒ­ã‚»ã‚¹';
                    thoughtDetails.appendChild(thoughtSummaryElem);

                    const thoughtContentDiv = document.createElement('div');
                    thoughtContentDiv.classList.add('thought-summary-content');
                    if (isStreamingPlaceholder) {
                        thoughtContentDiv.id = `streaming-thought-summary-${index}`;
                        thoughtContentDiv.innerHTML = '';
                    } else {
                        try {
                            thoughtContentDiv.innerHTML = marked.parse(messageData.thoughtSummary || '');
                        } catch (e) {
                            console.error("Thought Summary Markdownãƒ‘ãƒ¼ã‚¹ã‚¨ãƒ©ãƒ¼:", e);
                            thoughtContentDiv.textContent = messageData.thoughtSummary || '';
                        }
                    }
                    thoughtDetails.appendChild(thoughtContentDiv);
                    messageDiv.appendChild(thoughtDetails);
                }

                const contentDiv = document.createElement('div');
                contentDiv.classList.add('message-content');
                
                if (role === 'user' && attachments && attachments.length > 0) {
                    const details = document.createElement('details');
                    details.classList.add('attachment-details');

                    const summary = document.createElement('summary');
                    summary.textContent = `æ·»ä»˜ãƒ•ã‚¡ã‚¤ãƒ« (${attachments.length}ä»¶)`;
                    details.appendChild(summary);

                    const list = document.createElement('ul');
                    list.classList.add('attachment-list');
                    attachments.forEach(att => {
                        const listItem = document.createElement('li');
                        listItem.textContent = att.name;
                        listItem.title = `${att.name} (${att.mimeType})`;
                        list.appendChild(listItem);
                    });
                    details.appendChild(list);
                    contentDiv.appendChild(details);

                    if (content && content.trim() !== '') {
                        const pre = document.createElement('pre');
                        pre.textContent = content;
                        pre.style.marginTop = '8px';
                        contentDiv.appendChild(pre);
                    }
                } else {
                    try {
                        if (role === 'model' && !isStreamingPlaceholder && typeof marked !== 'undefined') {
                            contentDiv.innerHTML = marked.parse(content || '');
                        } else if (role === 'user') {
                            const pre = document.createElement('pre'); pre.textContent = content; contentDiv.appendChild(pre);
                        } else if (role === 'error') {
                             const p = document.createElement('p'); p.textContent = content; contentDiv.appendChild(p);
                        } else if (isStreamingPlaceholder) {
                            contentDiv.innerHTML = '';
                        } else {
                            const pre = document.createElement('pre'); pre.textContent = content; contentDiv.appendChild(pre);
                        }
                    } catch (e) {
                         console.error("Markdownãƒ‘ãƒ¼ã‚¹ã‚¨ãƒ©ãƒ¼:", e);
                         const pre = document.createElement('pre'); pre.textContent = content; contentDiv.innerHTML = ''; contentDiv.appendChild(pre);
                    }
                }
                messageDiv.appendChild(contentDiv);
                
                if (role === 'model' && messageData && messageData.groundingMetadata &&
                    ( (messageData.groundingMetadata.groundingChunks && messageData.groundingMetadata.groundingChunks.length > 0) ||
                      (messageData.groundingMetadata.webSearchQueries && messageData.groundingMetadata.webSearchQueries.length > 0) )
                   )
                {
                    try {
                        const details = document.createElement('details');
                        details.classList.add('citation-details');

                        const summary = document.createElement('summary');
                        summary.textContent = 'å¼•ç”¨å…ƒ/æ¤œç´¢ã‚¯ã‚¨ãƒª';
                        details.appendChild(summary);

                        let detailsHasContent = false;

                        if (messageData.groundingMetadata.groundingChunks && messageData.groundingMetadata.groundingChunks.length > 0) {
                            const citationList = document.createElement('ul');
                            citationList.classList.add('citation-list');

                            const citationMap = new Map();
                            let displayIndexCounter = 1;
                            if (messageData.groundingMetadata.groundingSupports) {
                                messageData.groundingMetadata.groundingSupports.forEach(support => {
                                    if (support.groundingChunkIndices) {
                                        support.groundingChunkIndices.forEach(chunkIndex => {
                                            if (!citationMap.has(chunkIndex) && chunkIndex >= 0 && chunkIndex < messageData.groundingMetadata.groundingChunks.length) {
                                                const chunk = messageData.groundingMetadata.groundingChunks[chunkIndex];
                                                if (chunk?.web?.uri) {
                                                    citationMap.set(chunkIndex, {
                                                        uri: chunk.web.uri,
                                                        title: chunk.web.title || 'ã‚¿ã‚¤ãƒˆãƒ«ä¸æ˜Ž',
                                                        displayIndex: displayIndexCounter++
                                                    });
                                                }
                                            }
                                        });
                                    }
                                });
                            }

                            const sortedCitations = Array.from(citationMap.entries())
                                                        .sort(([, a], [, b]) => a.displayIndex - b.displayIndex);

                            sortedCitations.forEach(([chunkIndex, citationInfo]) => {
                                const listItem = document.createElement('li');
                                const link = document.createElement('a');
                                link.href = citationInfo.uri;
                                link.textContent = `[${citationInfo.displayIndex}] ${citationInfo.title}`;
                                link.title = citationInfo.title;
                                link.target = '_blank';
                                link.rel = 'noopener noreferrer';
                                listItem.appendChild(link);
                                citationList.appendChild(listItem);
                            });

                            if (sortedCitations.length === 0) {
                                 messageData.groundingMetadata.groundingChunks.forEach((chunk, idx) => {
                                     if (chunk?.web?.uri) {
                                         const listItem = document.createElement('li');
                                         const link = document.createElement('a');
                                         link.href = chunk.web.uri;
                                         link.textContent = chunk.web.title || `ã‚½ãƒ¼ã‚¹ ${idx + 1}`;
                                         link.title = chunk.web.title || 'ã‚¿ã‚¤ãƒˆãƒ«ä¸æ˜Ž';
                                         link.target = '_blank';
                                         link.rel = 'noopener noreferrer';
                                         listItem.appendChild(link);
                                         citationList.appendChild(listItem);
                                     }
                                 });
                            }

                            if (citationList.hasChildNodes()) {
                                details.appendChild(citationList);
                                detailsHasContent = true;
                            }
                        }

                        if (messageData.groundingMetadata.webSearchQueries && messageData.groundingMetadata.webSearchQueries.length > 0) {
                            if (detailsHasContent) {
                                const separator = document.createElement('hr');
                                separator.style.marginTop = '10px';
                                separator.style.marginBottom = '8px';
                                separator.style.border = 'none';
                                separator.style.borderTop = '1px dashed var(--border-tertiary)';
                                details.appendChild(separator);
                            }

                            const queryHeader = document.createElement('div');
                            queryHeader.textContent = 'æ¤œç´¢ã«ä½¿ç”¨ã•ã‚ŒãŸã‚¯ã‚¨ãƒª:';
                            queryHeader.style.fontWeight = '500';
                            queryHeader.style.marginTop = detailsHasContent ? '0' : '8px';
                            queryHeader.style.marginBottom = '4px';
                            queryHeader.style.fontSize = '11px';
                            queryHeader.style.color = 'var(--text-secondary)';
                            details.appendChild(queryHeader);

                            const queryList = document.createElement('ul');
                            queryList.classList.add('search-query-list');
                            queryList.style.listStyle = 'none';
                            queryList.style.paddingLeft = '0';
                            queryList.style.margin = '0';
                            queryList.style.fontSize = '11px';
                            queryList.style.color = 'var(--text-secondary)';

                            messageData.groundingMetadata.webSearchQueries.forEach(query => {
                                const queryItem = document.createElement('li');
                                queryItem.textContent = `â€¢ ${query}`;
                                queryItem.style.marginBottom = '3px';
                                queryList.appendChild(queryItem);
                            });
                            details.appendChild(queryList);
                            detailsHasContent = true;
                        }

                        if (detailsHasContent) {
                            contentDiv.appendChild(details);
                        }

                    } catch (e) {
                        console.error(`å¼•ç”¨å…ƒ/æ¤œç´¢ã‚¯ã‚¨ãƒªè¡¨ç¤ºã®ç”Ÿæˆä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ (index: ${index}):`, e);
                    }
                }

                const editArea = document.createElement('div');
                editArea.classList.add('message-edit-area', 'hidden');
                messageDiv.appendChild(editArea);

                if (role === 'model' && cascadeInfo && cascadeInfo.total > 1) {
                    const cascadeControlsDiv = document.createElement('div');
                    cascadeControlsDiv.classList.add('message-cascade-controls');

                    const prevButton = document.createElement('button');
                    prevButton.textContent = 'ï¼œ';
                    prevButton.title = 'å‰ã®å¿œç­”';
                    prevButton.classList.add('cascade-prev-btn');
                    prevButton.disabled = cascadeInfo.currentIndex <= 1;
                    prevButton.onclick = () => appLogic.navigateCascade(index, 'prev');
                    cascadeControlsDiv.appendChild(prevButton);

                    const indicatorSpan = document.createElement('span');
                    indicatorSpan.classList.add('cascade-indicator');
                    indicatorSpan.textContent = `${cascadeInfo.currentIndex}/${cascadeInfo.total}`;
                    cascadeControlsDiv.appendChild(indicatorSpan);

                    const nextButton = document.createElement('button');
                    nextButton.textContent = 'ï¼ž';
                    nextButton.title = 'æ¬¡ã®å¿œç­”';
                    nextButton.classList.add('cascade-next-btn');
                    nextButton.disabled = cascadeInfo.currentIndex >= cascadeInfo.total;
                    nextButton.onclick = () => appLogic.navigateCascade(index, 'next');
                    cascadeControlsDiv.appendChild(nextButton);

                    const deleteCascadeButton = document.createElement('button');
                    deleteCascadeButton.textContent = 'âœ•';
                    deleteCascadeButton.title = 'ã“ã®å¿œç­”ã‚’å‰Šé™¤';
                    deleteCascadeButton.classList.add('cascade-delete-btn');
                    deleteCascadeButton.onclick = () => appLogic.confirmDeleteCascadeResponse(index);
                    cascadeControlsDiv.appendChild(deleteCascadeButton);

                    messageDiv.appendChild(cascadeControlsDiv);
                }

                if (role !== 'error') {
                    const actionsDiv = document.createElement('div');
                    actionsDiv.classList.add('message-actions');
                    
                    const editButton = document.createElement('button');
                    editButton.textContent = 'ç·¨é›†'; editButton.title = 'ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ç·¨é›†'; editButton.classList.add('js-edit-btn');
                    editButton.onclick = () => appLogic.startEditMessage(index, messageDiv);
                    actionsDiv.appendChild(editButton);

                    const deleteButton = document.createElement('button');
                    deleteButton.textContent = 'å‰Šé™¤'; deleteButton.title = 'ã“ã®ä¼šè©±ã‚¿ãƒ¼ãƒ³ã‚’å‰Šé™¤'; deleteButton.classList.add('js-delete-btn');
                    deleteButton.onclick = () => appLogic.deleteMessage(index);
                    actionsDiv.appendChild(deleteButton);

                    if (role === 'user') {
                        const retryButton = document.createElement('button');
                        retryButton.textContent = 'ãƒªãƒˆãƒ©ã‚¤'; retryButton.title = 'ã“ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‹ã‚‰å†ç”Ÿæˆ'; retryButton.classList.add('js-retry-btn');
                        retryButton.onclick = () => appLogic.retryFromMessage(index);
                        actionsDiv.appendChild(retryButton);
                    }
                    
                    if (role === 'model' && messageData?.usageMetadata &&
                        typeof messageData.usageMetadata.candidatesTokenCount === 'number' &&
                        typeof messageData.usageMetadata.totalTokenCount === 'number')
                    {
                        const usage = messageData.usageMetadata;
                        const tokenSpan = document.createElement('span');
                        tokenSpan.classList.add('token-count-display');
                        let finalTotalTokenCount = usage.totalTokenCount;
                        if (typeof messageData.usageMetadata.thoughtsTokenCount === 'number') {
                            finalTotalTokenCount -= messageData.usageMetadata.thoughtsTokenCount;
                        }
                        const formattedCandidates = usage.candidatesTokenCount.toLocaleString('en-US');
                        const formattedTotal = finalTotalTokenCount.toLocaleString('en-US');
                        tokenSpan.textContent = `${formattedCandidates} / ${formattedTotal}`;
                        tokenSpan.title = `Candidate Tokens / Total Tokens`;

                        actionsDiv.appendChild(tokenSpan);
                    }

                    messageDiv.appendChild(actionsDiv);
                }

                if (isStreamingPlaceholder) {
                    messageDiv.id = `streaming-message-${index}`;
                }
                elements.messageContainer.appendChild(messageDiv);
            },

            updateStreamingMessage(index, newChar, isThoughtSummary = false) {
                const messageDiv = document.getElementById(`streaming-message-${index}`);
                if (messageDiv && typeof marked !== 'undefined') {
                    let targetContentDiv;
                    let streamContent;

                    if (isThoughtSummary) {
                        targetContentDiv = messageDiv.querySelector(`#streaming-thought-summary-${index}`);
                        streamContent = state.partialThoughtStreamContent;
                    } else {
                        targetContentDiv = messageDiv.querySelector('.message-content');
                        streamContent = state.partialStreamContent;
                    }

                    if (targetContentDiv) {
                        try {
                            targetContentDiv.innerHTML = marked.parse(streamContent || '');
                        } catch (e) {
                            console.error(`ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°æ›´æ–°ä¸­ã®Markdownãƒ‘ãƒ¼ã‚¹ã‚¨ãƒ©ãƒ¼ (${isThoughtSummary ? 'Thought' : 'Content'}):`, e);
                            targetContentDiv.textContent = streamContent;
                        }
                    }
                    if (!isThoughtSummary) {
                        this.scrollToBottom();
                    }
                }
            },

            finalizeStreamingMessage(index) {
                const messageDiv = document.getElementById(`streaming-message-${index}`);
                if (messageDiv) {
                    const finalMessageData = state.currentMessages[index];
                    if (!finalMessageData) return;

                    if (finalMessageData.thoughtSummary) {
                        const thoughtContentDiv = messageDiv.querySelector(`#streaming-thought-summary-${index}`);
                        if (thoughtContentDiv && typeof marked !== 'undefined') {
                            try {
                                thoughtContentDiv.innerHTML = marked.parse(finalMessageData.thoughtSummary || '');
                            } catch (e) {
                                console.error("Thought Summary ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°å®Œäº†æ™‚ã®Markdownãƒ‘ãƒ¼ã‚¹ã‚¨ãƒ©ãƒ¼:", e);
                                thoughtContentDiv.textContent = finalMessageData.thoughtSummary || '';
                            }
                            thoughtContentDiv.removeAttribute('id');
                        } else if (thoughtContentDiv) {
                            thoughtContentDiv.textContent = finalMessageData.thoughtSummary || '';
                            thoughtContentDiv.removeAttribute('id');
                        }
                    }

                    const contentDiv = messageDiv.querySelector('.message-content');
                    const finalRawContent = finalMessageData.content || '';
                    if (contentDiv && typeof marked !== 'undefined') {
                         try {
                             contentDiv.innerHTML = marked.parse(finalRawContent);
                         } catch (e) {
                             console.error("ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°å®Œäº†æ™‚ã®Markdownãƒ‘ãƒ¼ã‚¹ã‚¨ãƒ©ãƒ¼:", e);
                             contentDiv.textContent = finalRawContent;
                         }
                    } else if (contentDiv) {
                        contentDiv.textContent = finalRawContent;
                    }
                    messageDiv.removeAttribute('id');

                    const msgData = state.currentMessages[index];
                    if (msgData && msgData.role === 'model' && msgData.isCascaded) {
                        const siblings = appLogic.getCascadedSiblings(index);
                        if (siblings.length > 1) {
                            this.renderChatMessages();
                        }
                    }
                }
                this.scrollToBottom();
            },

            displayError(message, isApiError = false) {
                console.error("ã‚¨ãƒ©ãƒ¼è¡¨ç¤º:", message);
                const errorIndex = state.currentMessages.length;
                this.appendMessage('error', `ã‚¨ãƒ©ãƒ¼: ${message}`, errorIndex);
                elements.loadingIndicator.classList.add('hidden');
                this.setSendingState(false);
            },

            scrollToBottom() {
                requestAnimationFrame(() => {
                    const mainContent = elements.chatScreen.querySelector('.main-content');
                    if (mainContent) {
                        mainContent.scrollTop = mainContent.scrollHeight;
                    }
                });
            },

            updateChatTitle(definitiveTitle = null) {
                let titleText = 'æ–°è¦ãƒãƒ£ãƒƒãƒˆ';
                let baseTitle = '';
                let isNewChat = !state.currentChatId;

                if (state.currentChatId) {
                    isNewChat = false;
                    if (definitiveTitle !== null) {
                        baseTitle = definitiveTitle;
                    } else {
                        const firstUserMessage = state.currentMessages.find(m => m.role === 'user');
                        if (firstUserMessage) {
                            baseTitle = firstUserMessage.content;
                        } else if (state.currentMessages.length > 0) {
                            baseTitle = "ãƒãƒ£ãƒƒãƒˆå±¥æ­´";
                        }
                    }
                    if(baseTitle) {
                        const displayBase = baseTitle.startsWith(IMPORT_PREFIX) ? baseTitle.substring(IMPORT_PREFIX.length) : baseTitle;
                        const truncated = displayBase.substring(0, CHAT_TITLE_LENGTH);
                        titleText = truncated + (displayBase.length > CHAT_TITLE_LENGTH ? '...' : '');
                        if (baseTitle.startsWith(IMPORT_PREFIX)) {
                            titleText = IMPORT_PREFIX + titleText;
                        }
                    } else if(state.currentMessages.length > 0) {
                        titleText = 'ãƒãƒ£ãƒƒãƒˆå±¥æ­´';
                    }
                    if (titleText === 'æ–°è¦ãƒãƒ£ãƒƒãƒˆ' && state.currentMessages.length > 0) {
                        titleText = 'ãƒãƒ£ãƒƒãƒˆå±¥æ­´';
                    }
                }
                const displayTitle = isNewChat ? titleText : `: ${titleText}`;
                elements.chatTitle.textContent = displayTitle;
                document.title = `GeminiPWA - ${titleText}`;
            },

            formatDate(timestamp) {
                if (!timestamp) return '';
                try {
                    return new Intl.DateTimeFormat('ja-JP', { year: '2-digit', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit', hour12: false }).format(new Date(timestamp));
                } catch (e) {
                    console.warn("Intl.DateTimeFormatã‚¨ãƒ©ãƒ¼:", e);
                    const d = new Date(timestamp);
                    return `${String(d.getFullYear()).slice(-2)}/${String(d.getMonth() + 1).padStart(2, '0')}/${String(d.getDate()).padStart(2, '0')} ${String(d.getHours()).padStart(2, '0')}:${String(d.getMinutes()).padStart(2, '0')}`;
                }
            },

            async renderHistoryList() {
                try {
                    const chats = await dbUtils.getAllChats(state.settings.historySortOrder);
                    elements.historyList.querySelectorAll('.history-item:not(.js-history-item-template)').forEach(item => item.remove());

                    if (chats && chats.length > 0) {
                        elements.noHistoryMessage.classList.add('hidden');
                        const sortOrderText = state.settings.historySortOrder === 'createdAt' ? 'ä½œæˆé †' : 'æ›´æ–°é †';
                        elements.historyTitle.textContent = `å±¥æ­´ä¸€è¦§ (${sortOrderText})`;

                        chats.forEach(chat => {
                            const li = elements.historyItemTemplate.cloneNode(true);
                            li.classList.remove('js-history-item-template');
                            li.dataset.chatId = chat.id;

                            const titleText = chat.title || `å±¥æ­´ ${chat.id}`;
                            const titleEl = li.querySelector('.history-item-title');
                            titleEl.textContent = titleText;
                            titleEl.title = titleText;

                            li.querySelector('.created-date').textContent = `ä½œæˆ: ${this.formatDate(chat.createdAt)}`;
                            li.querySelector('.updated-date').textContent = `æ›´æ–°: ${this.formatDate(chat.updatedAt)}`;

                            li.onclick = (event) => {
                                if (!event.target.closest('.history-item-actions button')) {
                                    appLogic.loadChat(chat.id);
                                    this.showScreen('chat');
                                }
                            };

                            li.querySelector('.js-edit-title-btn').onclick = (e) => { e.stopPropagation(); appLogic.editHistoryTitle(chat.id, titleEl); };
                            li.querySelector('.js-export-btn').onclick = (e) => { e.stopPropagation(); appLogic.exportChat(chat.id, titleText); };
                            li.querySelector('.js-duplicate-btn').onclick = (e) => { e.stopPropagation(); appLogic.duplicateChat(chat.id); };
                            li.querySelector('.js-delete-btn').onclick = (e) => { e.stopPropagation(); appLogic.confirmDeleteChat(chat.id, titleText); };

                            elements.historyList.appendChild(li);
                        });
                    } else {
                        elements.noHistoryMessage.classList.remove('hidden');
                        elements.historyTitle.textContent = 'å±¥æ­´ä¸€è¦§';
                    }
                } catch (error) {
                    console.error("å±¥æ­´ãƒªã‚¹ãƒˆã®ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã‚¨ãƒ©ãƒ¼:", error);
                    elements.noHistoryMessage.textContent = "å±¥æ­´ã®èª­ã¿è¾¼ã¿ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚";
                    elements.noHistoryMessage.classList.remove('hidden');
                    elements.historyTitle.textContent = 'å±¥æ­´ä¸€è¦§';
                }
            },

            revokeExistingObjectUrl() {
                if (state.backgroundImageUrl) {
                    try {
                        URL.revokeObjectURL(state.backgroundImageUrl);
                        console.log("ä»¥å‰ã®èƒŒæ™¯URLã‚’ç ´æ£„:", state.backgroundImageUrl);
                    } catch (e) {
                        console.error("ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆURLã®ç ´æ£„ã‚¨ãƒ©ãƒ¼:", e);
                    }
                    state.backgroundImageUrl = null;
                }
            },
            updateBackgroundSettingsUI() {
                if (!elements.backgroundThumbnail || !elements.deleteBackgroundBtn) return;
                if (state.backgroundImageUrl) {
                    elements.backgroundThumbnail.src = state.backgroundImageUrl;
                    elements.backgroundThumbnail.classList.remove('hidden');
                    elements.deleteBackgroundBtn.classList.remove('hidden');
                } else {
                    elements.backgroundThumbnail.src = '';
                    elements.backgroundThumbnail.classList.add('hidden');
                    elements.deleteBackgroundBtn.classList.add('hidden');
                }
            },

            applySettingsToUI() {
                elements.apiKeyInput.value = state.settings.apiKey || '';
                elements.modelNameSelect.value = state.settings.modelName || DEFAULT_MODEL;
                elements.streamingOutputCheckbox.checked = state.settings.streamingOutput;
                elements.streamingSpeedInput.value = state.settings.streamingSpeed ?? DEFAULT_STREAMING_SPEED;
                elements.systemPromptDefaultTextarea.value = state.settings.systemPrompt || '';
                elements.temperatureInput.value = state.settings.temperature === null ? '' : state.settings.temperature;
                elements.maxTokensInput.value = state.settings.maxTokens === null ? '' : state.settings.maxTokens;
                elements.topKInput.value = state.settings.topK === null ? '' : state.settings.topK;
                elements.topPInput.value = state.settings.topP === null ? '' : state.settings.topP;
                elements.presencePenaltyInput.value = state.settings.presencePenalty === null ? '' : state.settings.presencePenalty;
                elements.frequencyPenaltyInput.value = state.settings.frequencyPenalty === null ? '' : state.settings.frequencyPenalty;
                elements.thinkingBudgetInput.value = state.settings.thinkingBudget === null ? '' : state.settings.thinkingBudget;
                elements.includeThoughtsToggle.checked = state.settings.includeThoughts;
                elements.dummyUserInput.value = state.settings.dummyUser || '';
                elements.dummyModelInput.value = state.settings.dummyModel || '';
                elements.concatDummyModelCheckbox.checked = state.settings.concatDummyModel;
                elements.additionalModelsTextarea.value = state.settings.additionalModels || '';
                elements.pseudoStreamingCheckbox.checked = state.settings.pseudoStreaming;
                elements.enterToSendCheckbox.checked = state.settings.enterToSend;
                elements.historySortOrderSelect.value = state.settings.historySortOrder || 'updatedAt';
                elements.darkModeToggle.checked = state.settings.darkMode;
                elements.fontFamilyInput.value = state.settings.fontFamily || '';
                elements.hideSystemPromptToggle.checked = state.settings.hideSystemPromptInChat;
                elements.enableGroundingToggle.checked = state.settings.enableGrounding;
                elements.swipeNavigationToggle.checked = state.settings.enableSwipeNavigation;

                this.updateUserModelOptions();
                this.updateBackgroundSettingsUI();
                this.applyDarkMode();
                this.applyFontFamily();
                this.toggleSystemPromptVisibility();
            },

            updateUserModelOptions() {
                const group = elements.userDefinedModelsGroup;
                group.innerHTML = '';
                const models = (state.settings.additionalModels || '')
                    .split(',')
                    .map(m => m.trim())
                    .filter(m => m !== '');

                if (models.length > 0) {
                    group.disabled = false;
                    models.forEach(modelId => {
                        const option = document.createElement('option');
                        option.value = modelId;
                        option.textContent = modelId;
                        group.appendChild(option);
                    });
                    if (models.includes(state.settings.modelName)) {
                        elements.modelNameSelect.value = state.settings.modelName;
                    }
                } else {
                    group.disabled = true;
                }
            },

            applyDarkMode() {
                const isDark = state.settings.darkMode;
                document.body.classList.toggle('dark-mode', isDark);
                document.body.classList.toggle('light-mode-forced', !isDark);
                elements.themeColorMeta.content = isDark ? DARK_THEME_COLOR : LIGHT_THEME_COLOR;
                console.log(`ãƒ€ãƒ¼ã‚¯ãƒ¢ãƒ¼ãƒ‰ ${isDark ? 'æœ‰åŠ¹' : 'ç„¡åŠ¹'}. ãƒ†ãƒ¼ãƒžã‚«ãƒ©ãƒ¼: ${elements.themeColorMeta.content}`);
            },

            applyFontFamily() {
                const customFont = state.settings.fontFamily?.trim();
                const fontFamilyToApply = customFont ? customFont : DEFAULT_FONT_FAMILY;
                document.documentElement.style.setProperty('--font-family', fontFamilyToApply);
                console.log(`ãƒ•ã‚©ãƒ³ãƒˆé©ç”¨: ${fontFamilyToApply}`);
            },

            updateSystemPromptUI() {
                elements.systemPromptEditor.value = state.currentSystemPrompt;
                if (!state.isEditingSystemPrompt) {
                    elements.systemPromptDetails.removeAttribute('open');
                }
                this.adjustTextareaHeight(elements.systemPromptEditor, 200);
                this.toggleSystemPromptVisibility();
            },
            toggleSystemPromptVisibility() {
                const shouldHide = state.settings.hideSystemPromptInChat;
                elements.systemPromptArea.classList.toggle('hidden', shouldHide);
                console.log(`ã‚·ã‚¹ãƒ†ãƒ ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆè¡¨ç¤ºã‚¨ãƒªã‚¢ ${shouldHide ? 'éžè¡¨ç¤º' : 'è¡¨ç¤º'}`);
            },

            showScreen(screenName, fromPopState = false) {
                if (state.editingMessageIndex !== null) {
                     const messageElement = elements.messageContainer.querySelector(`.message[data-index="${state.editingMessageIndex}"]`);
                     if (messageElement) {
                        appLogic.cancelEditMessage(state.editingMessageIndex, messageElement);
                     } else {
                        state.editingMessageIndex = null;
                     }
                }
                if (state.isEditingSystemPrompt) {
                    appLogic.cancelEditSystemPrompt();
                }

                if (screenName === state.currentScreen) {
                    return;
                }

                const allScreens = [elements.chatScreen, elements.historyScreen, elements.settingsScreen];
                let activeScreen = null;

                if (!fromPopState) {
                    if (screenName === 'history' || screenName === 'settings') {
                        history.pushState({ screen: screenName }, '', `#${screenName}`);
                        console.log(`Pushed state: ${screenName}`);
                    } else if (screenName === 'chat') {
                        history.replaceState({ screen: 'chat' }, '', '#chat');
                        console.log(`Replaced state: ${screenName}`);
                    }
                } else {
                    console.log(`showScreen called from popstate for ${screenName}`);
                }

                allScreens.forEach(screen => {
                    screen.classList.remove('active');
                    screen.inert = true;
                });

                if (screenName === 'chat') {
                    activeScreen = elements.chatScreen;
                    elements.chatScreen.style.transform = 'translateX(0)';
                    elements.historyScreen.style.transform = 'translateX(-100%)';
                    elements.settingsScreen.style.transform = 'translateX(100%)';
                    requestAnimationFrame(() => {
                        this.updateSystemPromptUI();
                        this.adjustTextareaHeight();
                        this.scrollToBottom();
                    });
                } else if (screenName === 'history') {
                    activeScreen = elements.historyScreen;
                    elements.chatScreen.style.transform = 'translateX(100%)';
                    elements.historyScreen.style.transform = 'translateX(0)';
                    elements.settingsScreen.style.transform = 'translateX(200%)';
                    this.renderHistoryList();
                } else if (screenName === 'settings') {
                    activeScreen = elements.settingsScreen;
                    elements.chatScreen.style.transform = 'translateX(-100%)';
                    elements.historyScreen.style.transform = 'translateX(-200%)';
                    elements.settingsScreen.style.transform = 'translateX(0)';
                    this.applySettingsToUI();
                }

                requestAnimationFrame(() => {
                    allScreens.forEach(screen => {
                        screen.style.transition = 'transform 0.3s ease-in-out';
                    });
                    if (activeScreen) {
                        activeScreen.inert = false;
                        activeScreen.classList.add('active');
                    }
                });

                state.currentScreen = screenName;
                console.log(`Navigated to screen: ${screenName}`);
            },

            setSendingState(sending) {
                state.isSending = sending;
                if (sending) {
                    elements.sendButton.textContent = 'æ­¢';
                    elements.sendButton.classList.add('sending');
                    elements.sendButton.title = "åœæ­¢";
                    elements.sendButton.disabled = false;
                    elements.userInput.disabled = true;
                    elements.attachFileBtn.disabled = true;
                    elements.loadingIndicator.classList.remove('hidden');
                    elements.loadingIndicator.setAttribute('aria-live', 'polite');
                    elements.systemPromptDetails.style.pointerEvents = 'none';
                    elements.systemPromptDetails.style.opacity = '0.7';
                } else {
                    elements.sendButton.textContent = 'é€';
                    elements.sendButton.classList.remove('sending');
                    elements.sendButton.title = "é€ä¿¡";
                    elements.sendButton.disabled = elements.userInput.value.trim() === '';
                    elements.userInput.disabled = false;
                    elements.attachFileBtn.disabled = false;
                    elements.loadingIndicator.classList.add('hidden');
                    elements.loadingIndicator.removeAttribute('aria-live');
                    elements.systemPromptDetails.style.pointerEvents = '';
                    elements.systemPromptDetails.style.opacity = '';
                }
            },

            adjustTextareaHeight(textarea = elements.userInput, maxHeight = TEXTAREA_MAX_HEIGHT) {
                textarea.style.height = 'auto';
                const scrollHeight = textarea.scrollHeight;
                textarea.style.height = Math.min(scrollHeight, maxHeight) + 'px';
                if (textarea === elements.userInput && !state.isSending) {
                    elements.sendButton.disabled = textarea.value.trim() === '';
                }
            },

            showCustomDialog(dialogElement, focusElement) {
                return new Promise((resolve) => {
                    const closeListener = () => {
                        dialogElement.removeEventListener('close', closeListener);
                        resolve(dialogElement.returnValue);
                    };
                    dialogElement.addEventListener('close', closeListener);
                    dialogElement.showModal();
                    if (focusElement) {
                        requestAnimationFrame(() => { focusElement.focus(); });
                    }
                });
            },
            async showCustomAlert(message) {
                elements.alertMessage.textContent = message;
                 const newOkBtn = elements.alertOkBtn.cloneNode(true);
                 elements.alertOkBtn.parentNode.replaceChild(newOkBtn, elements.alertOkBtn);
                 elements.alertOkBtn = newOkBtn;
                elements.alertOkBtn.onclick = () => elements.alertDialog.close('ok');
                await this.showCustomDialog(elements.alertDialog, elements.alertOkBtn);
            },
            async showCustomConfirm(message) {
                elements.confirmMessage.textContent = message;
                 const newOkBtn = elements.confirmOkBtn.cloneNode(true);
                 elements.confirmOkBtn.parentNode.replaceChild(newOkBtn, elements.confirmOkBtn);
                 elements.confirmOkBtn = newOkBtn;
                 const newCancelBtn = elements.confirmCancelBtn.cloneNode(true);
                 elements.confirmCancelBtn.parentNode.replaceChild(newCancelBtn, elements.confirmCancelBtn);
                 elements.confirmCancelBtn = newCancelBtn;

                elements.confirmOkBtn.onclick = () => elements.confirmDialog.close('ok');
                elements.confirmCancelBtn.onclick = () => elements.confirmDialog.close('cancel');
                const result = await this.showCustomDialog(elements.confirmDialog, elements.confirmOkBtn);
                return result === 'ok';
            },
            async showCustomPrompt(message, defaultValue = '') {
                elements.promptMessage.textContent = message;
                elements.promptInput.value = defaultValue;
                 const newOkBtn = elements.promptOkBtn.cloneNode(true);
                 elements.promptOkBtn.parentNode.replaceChild(newOkBtn, elements.promptOkBtn);
                 elements.promptOkBtn = newOkBtn;
                 const newCancelBtn = elements.promptCancelBtn.cloneNode(true);
                 elements.promptCancelBtn.parentNode.replaceChild(newCancelBtn, elements.promptCancelBtn);
                 elements.promptCancelBtn = newCancelBtn;
                 const newPromptInput = elements.promptInput.cloneNode(true);
                 elements.promptInput.parentNode.replaceChild(newPromptInput, elements.promptInput);
                 elements.promptInput = newPromptInput;

                const enterHandler = (event) => {
                    if (event.key === 'Enter') {
                        event.preventDefault();
                        elements.promptOkBtn.click();
                    }
                };
                elements.promptInput.addEventListener('keypress', enterHandler);

                elements.promptOkBtn.onclick = () => elements.promptDialog.close(elements.promptInput.value);
                elements.promptCancelBtn.onclick = () => elements.promptDialog.close('');

                const closeHandler = () => {
                    elements.promptInput.removeEventListener('keypress', enterHandler);
                    elements.promptDialog.removeEventListener('close', closeHandler);
                };
                 elements.promptDialog.addEventListener('close', closeHandler);

                const result = await this.showCustomDialog(elements.promptDialog, elements.promptInput);
                return result;
            },

            updateAttachmentBadgeVisibility() {
                const hasAttachments = state.pendingAttachments.length > 0;
                elements.attachFileBtn.classList.toggle('has-attachments', hasAttachments);
            },

            showFileUploadDialog() {
                if (state.pendingAttachments.length > 0) {
                    state.selectedFilesForUpload = state.pendingAttachments.map(att => ({ file: att.file }));
                    console.log("é€ä¿¡å¾…ã¡ã®æ·»ä»˜ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã«å¾©å…ƒ:", state.selectedFilesForUpload.map(item => item.file.name));
                } else {
                    state.selectedFilesForUpload = [];
                }

                this.updateSelectedFilesUI();
                elements.fileUploadDialog.showModal();
                this.updateAttachmentBadgeVisibility();
            },

            updateSelectedFilesUI() {
                elements.selectedFilesList.innerHTML = '';
                let totalSize = 0;
                state.selectedFilesForUpload.forEach((item, index) => {
                    const li = document.createElement('li');
                    li.classList.add('selected-file-item');
                    li.dataset.fileIndex = index;

                    const infoDiv = document.createElement('div');
                    infoDiv.classList.add('selected-file-info');

                    const nameSpan = document.createElement('span');
                    nameSpan.classList.add('selected-file-name');
                    nameSpan.textContent = item.file.name;
                    nameSpan.title = item.file.name;

                    const sizeSpan = document.createElement('span');
                    sizeSpan.classList.add('selected-file-size');
                    sizeSpan.textContent = formatFileSize(item.file.size);

                    infoDiv.appendChild(nameSpan);
                    infoDiv.appendChild(sizeSpan);

                    const removeBtn = document.createElement('button');
                    removeBtn.classList.add('remove-file-btn');
                    removeBtn.title = 'å‰Šé™¤';
                    removeBtn.textContent = 'Ã—';
                    removeBtn.onclick = () => appLogic.removeSelectedFile(index);

                    li.appendChild(infoDiv);
                    li.appendChild(removeBtn);
                    elements.selectedFilesList.appendChild(li);

                    totalSize += item.file.size;
                });

                if (totalSize > MAX_TOTAL_ATTACHMENT_SIZE) {
                    elements.confirmAttachBtn.disabled = true;
                } else {
                    elements.confirmAttachBtn.disabled = false;
                }
            },
        };

        const apiUtils = {
            async callGeminiApi(messagesForApi, generationConfig, systemInstruction) {
                if (!state.settings.apiKey) {
                    throw new Error("APIã‚­ãƒ¼ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚");
                }
                state.abortController = new AbortController();
                const { signal } = state.abortController;

                const useStreaming = state.settings.streamingOutput;
                const usePseudo = state.settings.pseudoStreaming;
                const model = state.settings.modelName || DEFAULT_MODEL;
                const apiKey = state.settings.apiKey;

                let endpointMethod = useStreaming
                    ? (usePseudo ? 'generateContent?alt=sse&' : 'streamGenerateContent?alt=sse&')
                    : 'generateContent?';
                console.log(`ä½¿ç”¨ãƒ¢ãƒ¼ãƒ‰: ${useStreaming ? (usePseudo ? 'ç–‘ä¼¼ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°' : 'ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°') : 'éžã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°'}`);

                const endpoint = `${GEMINI_API_BASE_URL}${model}:${endpointMethod}key=${apiKey}`;
                
                const finalGenerationConfig = { ...generationConfig };
                if (state.settings.presencePenalty !== null) finalGenerationConfig.presencePenalty = state.settings.presencePenalty;
                if (state.settings.frequencyPenalty !== null) finalGenerationConfig.frequencyPenalty = state.settings.frequencyPenalty;
                
                if (state.settings.thinkingBudget !== null || state.settings.includeThoughts) {
                    finalGenerationConfig.thinkingConfig = finalGenerationConfig.thinkingConfig || {};
                    if (state.settings.thinkingBudget !== null && Number.isInteger(state.settings.thinkingBudget) && state.settings.thinkingBudget >= 0) {
                        finalGenerationConfig.thinkingConfig.thinkingBudget = state.settings.thinkingBudget;
                        console.log(`Thinking Budget (${state.settings.thinkingBudget}) ã‚’æœ‰åŠ¹ã«ã—ã¦APIã‚’å‘¼ã³å‡ºã—ã¾ã™ã€‚`);
                    }
                    if (state.settings.includeThoughts) {
                        finalGenerationConfig.thinkingConfig.includeThoughts = true;
                        console.log("Include Thoughts ã‚’æœ‰åŠ¹ã«ã—ã¦APIã‚’å‘¼ã³å‡ºã—ã¾ã™ã€‚");
                    }
                    if (Object.keys(finalGenerationConfig.thinkingConfig).length === 0) {
                        delete finalGenerationConfig.thinkingConfig;
                    }
                }

                const requestBody = {
                    contents: messagesForApi,
                    ...(Object.keys(finalGenerationConfig).length > 0 && { generationConfig: finalGenerationConfig }),
                    ...(systemInstruction && systemInstruction.parts && systemInstruction.parts.length > 0 && systemInstruction.parts[0].text && { systemInstruction }),
                     safetySettings : [
                         { category: 'HARM_CATEGORY_HARASSMENT', threshold: 'BLOCK_NONE' },
                         { category: 'HARM_CATEGORY_HATE_SPEECH', threshold: 'BLOCK_NONE' },
                         { category: 'HARM_CATEGORY_SEXUALLY_EXPLICIT', threshold: 'BLOCK_NONE' },
                         { category: 'HARM_CATEGORY_DANGEROUS_CONTENT', threshold: 'BLOCK_NONE' }
                     ]
                };
                
                const tools = [];

                if (state.settings.enableGrounding) {
                    tools.push({ "google_search": {} });
                    console.log("ã‚°ãƒ©ã‚¦ãƒ³ãƒ‡ã‚£ãƒ³ã‚° (Google Search) ã‚’æœ‰åŠ¹ã«ã—ã¦APIã‚’å‘¼ã³å‡ºã—ã¾ã™ã€‚");
                }
                
                if (tools.length > 0) {
                    requestBody.tools = tools;
                }

                console.log("Geminiã¸ã®é€ä¿¡ãƒ‡ãƒ¼ã‚¿:", JSON.stringify(requestBody, (key, value) => {
                    if (key === 'data' && typeof value === 'string' && value.length > 100) {
                        return value.substring(0, 50) + '...[çœç•¥]...' + value.substring(value.length - 20);
                    }
                    return value;
                }, 2));
                console.log("ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ:", endpoint);

                try {
                    const response = await fetch(endpoint, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(requestBody),
                        signal
                    });

                    if (!response.ok) {
                        let errorMsg = `APIã‚¨ãƒ©ãƒ¼ (${response.status}): ${response.statusText}`;
                        try {
                            const errorData = await response.json();
                            console.error("APIã‚¨ãƒ©ãƒ¼ãƒ¬ã‚¹ãƒãƒ³ã‚¹ãƒœãƒ‡ã‚£:", errorData);
                            if (errorData.error && errorData.error.message) {
                                errorMsg = `APIã‚¨ãƒ©ãƒ¼ (${response.status}): ${errorData.error.message}`;
                            }
                        } catch (e) {
                            console.error("APIã‚¨ãƒ©ãƒ¼ãƒ¬ã‚¹ãƒãƒ³ã‚¹ãƒœãƒ‡ã‚£ã®ãƒ‘ãƒ¼ã‚¹å¤±æ•—:", e);
                        }
                        throw new Error(errorMsg);
                    }
                    return response;
                } catch (error) {
                    if (error.name === 'AbortError') {
                        throw new Error("ãƒªã‚¯ã‚¨ã‚¹ãƒˆãŒã‚­ãƒ£ãƒ³ã‚»ãƒ«ã•ã‚Œã¾ã—ãŸã€‚");
                    } else {
                        throw error;
                    }
                }
            },

            async *handleStreamingResponse(response) {
                 if (!response.body) {
                     throw new Error("ãƒ¬ã‚¹ãƒãƒ³ã‚¹ãƒœãƒ‡ã‚£ãŒã‚ã‚Šã¾ã›ã‚“ã€‚");
                 }
                 const reader = response.body.pipeThrough(new TextDecoderStream()).getReader();
                 let buffer = '';
                 let lastCandidateInfo = null;
                 let isCancelled = false;
                 let groundingMetadata = null;
                 let finalUsageMetadata = null;
                 let isProcessingThought = false;
                 let hasProcessedThoughtInCurrentBlock = false;

                 try {
                     while (true) {
                         if (state.abortController?.signal.aborted && !isCancelled) {
                             isCancelled = true;
                             console.log("ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°ä¸­ã«ä¸­æ–­ã‚·ã‚°ãƒŠãƒ«ã‚’æ¤œå‡º");
                             await reader.cancel("User aborted");
                             throw new Error("ãƒªã‚¯ã‚¨ã‚¹ãƒˆãŒã‚­ãƒ£ãƒ³ã‚»ãƒ«ã•ã‚Œã¾ã—ãŸã€‚");
                         }

                         let readResult;
                         try {
                             readResult = await reader.read();
                         } catch (readError) {
                             if (readError.name === 'AbortError' || readError.message === "User aborted" || readError.message.includes("aborted")) {
                                 if (!isCancelled) {
                                     isCancelled = true;
                                     throw new Error("ãƒªã‚¯ã‚¨ã‚¹ãƒˆãŒã‚­ãƒ£ãƒ³ã‚»ãƒ«ã•ã‚Œã¾ã—ãŸã€‚");
                                 }
                                 break;
                             }
                             throw readError;
                         }

                         const { value, done } = readResult;

                         if (done) {
                             console.log("ã‚¹ãƒˆãƒªãƒ¼ãƒ çµ‚äº† (done)");
                             if (buffer.trim()) {
                                 const finalData = parseSseDataForYield(buffer.trim().substring(6));
                                 if (finalData) {
                                    if (finalData.thoughtText) isProcessingThought = true;
                                    yield finalData;
                                    if (finalData.thoughtText) hasProcessedThoughtInCurrentBlock = true;
                                    if (finalData.contentText && isProcessingThought && hasProcessedThoughtInCurrentBlock) {
                                        isProcessingThought = false;
                                        hasProcessedThoughtInCurrentBlock = false;
                                    }
                                 }
                             }
                             break;
                         }

                         buffer += value;
                         let remainingBuffer = buffer;
                         while (true) {
                             const newlineIndex = remainingBuffer.indexOf('\n');
                             if (newlineIndex === -1) {
                                 buffer = remainingBuffer;
                                 break;
                             }
                             const line = remainingBuffer.substring(0, newlineIndex).trim();
                             remainingBuffer = remainingBuffer.substring(newlineIndex + 1);

                             if (line.startsWith('data: ')) {
                                 const chunkData = parseSseDataForYield(line.substring(6));
                                 if (chunkData) {
                                     if (chunkData.groundingMetadata) groundingMetadata = chunkData.groundingMetadata;
                                     if (chunkData.usageMetadata) finalUsageMetadata = chunkData.usageMetadata;

                                     if (chunkData.thoughtText) {
                                        isProcessingThought = true;
                                        yield chunkData;
                                        hasProcessedThoughtInCurrentBlock = true;
                                     } else if (chunkData.contentText) {
                                        if (isProcessingThought && hasProcessedThoughtInCurrentBlock) {
                                            isProcessingThought = false;
                                            hasProcessedThoughtInCurrentBlock = false;
                                        }
                                        if (!isProcessingThought) {
                                            yield chunkData;
                                        } else {
                                        }
                                     } else {
                                        yield chunkData;
                                     }
                                 }
                             } else if (line !== '') {
                                 console.warn("ãƒ‡ãƒ¼ã‚¿ä»¥å¤–ã®SSEè¡Œã‚’ç„¡è¦–:", line);
                             }
                             if (remainingBuffer === '') {
                                buffer = '';
                                break;
                             }
                         }
                     }
                     const finishReason = lastCandidateInfo?.finishReason;
                     const safetyRatings = lastCandidateInfo?.safetyRatings;

                     yield {
                         type: 'metadata',
                         finishReason: isCancelled ? 'ABORTED' : finishReason,
                         safetyRatings,
                         groundingMetadata: groundingMetadata,
                         usageMetadata: finalUsageMetadata
                     };

                 } catch (error) {
                     console.error("ã‚¹ãƒˆãƒªãƒ¼ãƒ ã®èª­ã¿å–ã‚Š/å‡¦ç†ã‚¨ãƒ©ãƒ¼:", error);
                     throw new Error(`ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°å‡¦ç†ã‚¨ãƒ©ãƒ¼: ${error.message || error}`, { cause: { originalError: error } });
                 } finally {
                     if (!reader.closed && !isCancelled) {
                         console.warn("ãƒªãƒ¼ãƒ€ãƒ¼ãŒãƒ«ãƒ¼ãƒ—å¾Œã«é–‰ã˜ã¦ã„ã¾ã›ã‚“ã€‚ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã‚’è©¦ã¿ã¾ã™ã€‚");
                         try { await reader.cancel("Cleanup cancellation"); } catch(e) { console.error("ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ã‚­ãƒ£ãƒ³ã‚»ãƒ«ä¸­ã®ã‚¨ãƒ©ãƒ¼:", e); }
                     }
                 }

                 function parseSseDataForYield(jsonString) {
                     try {
                         const chunkJson = JSON.parse(jsonString);
                         if (chunkJson.error) {
                             console.error("ã‚¹ãƒˆãƒªãƒ¼ãƒ å†…ã®ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸:", chunkJson.error);
                             const errorMsg = `ãƒ¢ãƒ‡ãƒ«ã‚¨ãƒ©ãƒ¼: ${chunkJson.error.message || JSON.stringify(chunkJson.error)}`;
                             lastCandidateInfo = { error: chunkJson.error, finishReason: 'ERROR' };
                             return { type: 'error', error: chunkJson.error, message: errorMsg };
                         }

                         let contentText = null;
                         let thoughtText = null;
                         let currentGroundingMetadata = null;
                         let currentUsageMetadata = null;

                         if (chunkJson.candidates && chunkJson.candidates.length > 0) {
                             lastCandidateInfo = chunkJson.candidates[0];
                             if (lastCandidateInfo?.content?.parts) {
                                 lastCandidateInfo.content.parts.forEach(part => {
                                     if (typeof part.text === 'string') {
                                         if (part.thought === true) {
                                             thoughtText = (thoughtText || '') + part.text;
                                         } else {
                                             contentText = (contentText || '') + part.text;
                                         }
                                     }
                                 });
                             }
                             if (lastCandidateInfo.groundingMetadata) {
                                 currentGroundingMetadata = lastCandidateInfo.groundingMetadata;
                             }
                         } else if (chunkJson.promptFeedback) {
                             console.warn("ã‚¹ãƒˆãƒªãƒ¼ãƒ å†…ã®ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯:", chunkJson.promptFeedback);
                             lastCandidateInfo = { finishReason: 'SAFETY', safetyRatings: chunkJson.promptFeedback.safetyRatings };
                             return null;
                         }

                         if (chunkJson.usageMetadata) {
                             currentUsageMetadata = chunkJson.usageMetadata;
                         }

                         if (contentText !== null || thoughtText !== null || currentGroundingMetadata || currentUsageMetadata) {
                             return {
                                 type: 'chunk',
                                 contentText,
                                 thoughtText,
                                 groundingMetadata: currentGroundingMetadata,
                                 usageMetadata: currentUsageMetadata
                             };
                         }
                         return null;
                     } catch (parseError) {
                         console.warn("ã‚¹ãƒˆãƒªãƒ¼ãƒ å†…ã®ä¸æ­£ãªJSONã‚’ã‚¹ã‚­ãƒƒãƒ—:", jsonString, parseError);
                         return null;
                     }
                 }
            }
        };

        const appLogic = {
            async initializeApp() {
                if (typeof marked !== 'undefined') {
                    marked.setOptions({
                        breaks: true,
                        gfm: true,
                        sanitize: true,
                        smartypants: false
                    });
                    console.log("Marked.jsè¨­å®šå®Œäº†");
                } else {
                    console.error("Marked.jsãƒ©ã‚¤ãƒ–ãƒ©ãƒªãŒèª­ã¿è¾¼ã¾ã‚Œã¦ã„ã¾ã›ã‚“ï¼");
                }
                elements.appVersionSpan.textContent = APP_VERSION;
                window.addEventListener('beforeinstallprompt', (event) => {
                    event.preventDefault();
                    console.log('beforeinstallpromptã‚¤ãƒ™ãƒ³ãƒˆã‚’æŠ‘åˆ¶ã—ã¾ã—ãŸã€‚');
                });

                uiUtils.showScreen('chat');

                registerServiceWorker();

                try {
                    await dbUtils.openDB();
                    await dbUtils.loadSettings();

                    uiUtils.applyDarkMode();
                    uiUtils.applyFontFamily();

                    if (state.settings.backgroundImageBlob instanceof Blob) {
                        uiUtils.revokeExistingObjectUrl();
                        try {
                             state.backgroundImageUrl = URL.createObjectURL(state.settings.backgroundImageBlob);
                             document.documentElement.style.setProperty('--chat-background-image', `url(${state.backgroundImageUrl})`);
                             console.log("èª­ã¿è¾¼ã‚“ã Blobã‹ã‚‰èƒŒæ™¯ç”»åƒã‚’é©ç”¨ã—ã¾ã—ãŸã€‚");
                        } catch (e) {
                             console.error("èƒŒæ™¯ç”»åƒã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆURLä½œæˆã‚¨ãƒ©ãƒ¼:", e);
                             document.documentElement.style.setProperty('--chat-background-image', 'none');
                        }
                    } else {
                        document.documentElement.style.setProperty('--chat-background-image', 'none');
                    }

                    uiUtils.applySettingsToUI();

                    const chats = await dbUtils.getAllChats(state.settings.historySortOrder);
                    if (chats && chats.length > 0) {
                        await this.loadChat(chats[0].id);
                    } else {
                        this.startNewChat();
                    }

                    history.replaceState({ screen: 'chat' }, '', '#chat');
                    state.currentScreen = 'chat';
                    console.log("Initial history state set to #chat");

                } catch (error) {
                    console.error("åˆæœŸåŒ–å¤±æ•—:", error);
                    await uiUtils.showCustomAlert(`ã‚¢ãƒ—ãƒªã®åˆæœŸåŒ–ã«å¤±æ•—ã—ã¾ã—ãŸ: ${error}`);
                    elements.appContainer.innerHTML = `<p style="padding: 20px; text-align: center; color: red;">ã‚¢ãƒ—ãƒªã®èµ·å‹•ã«å¤±æ•—ã—ã¾ã—ãŸã€‚</p>`;
                } finally {
                    updateMessageMaxWidthVar();
                    this.setupEventListeners();
                    this.updateZoomState();
                    uiUtils.adjustTextareaHeight();
                    uiUtils.setSendingState(false);
                    uiUtils.scrollToBottom();
                }
            },

            setupEventListeners() {
                elements.gotoHistoryBtn.addEventListener('click', () => uiUtils.showScreen('history'));
                elements.gotoSettingsBtn.addEventListener('click', () => uiUtils.showScreen('settings'));
                elements.backToChatFromHistoryBtn.addEventListener('click', () => history.back());
                elements.backToChatFromSettingsBtn.addEventListener('click', () => history.back());

                elements.newChatBtn.addEventListener('click', async () => {
                    const confirmed = await uiUtils.showCustomConfirm("ç¾åœ¨ã®ãƒãƒ£ãƒƒãƒˆã‚’ä¿å­˜ã—ã¦æ–°è¦ãƒãƒ£ãƒƒãƒˆã‚’é–‹å§‹ã—ã¾ã™ã‹ï¼Ÿ");
                    if (confirmed) this.confirmStartNewChat();
                });
                elements.sendButton.addEventListener('click', () => {
                    if (state.isSending) this.abortRequest();
                    else this.handleSend();
                });
                elements.userInput.addEventListener('input', () => uiUtils.adjustTextareaHeight());
                elements.userInput.addEventListener('keypress', (e) => {
                    if (state.settings.enterToSend && e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        if (!elements.sendButton.disabled) this.handleSend();
                    }
                });

                elements.systemPromptDetails.addEventListener('toggle', (event) => {
                    if (event.target.open) {
                        this.startEditSystemPrompt();
                    } else if (state.isEditingSystemPrompt) {
                        this.cancelEditSystemPrompt();
                    }
                });
                elements.saveSystemPromptBtn.addEventListener('click', () => this.saveCurrentSystemPrompt());
                elements.cancelSystemPromptBtn.addEventListener('click', () => this.cancelEditSystemPrompt());
                elements.systemPromptEditor.addEventListener('input', () => {
                    uiUtils.adjustTextareaHeight(elements.systemPromptEditor, 200);
                });

                elements.importHistoryBtn.addEventListener('click', () => elements.importHistoryInput.click());
                elements.importHistoryInput.addEventListener('change', (event) => {
                    const file = event.target.files[0];
                    if (file) this.handleHistoryImport(file);
                    event.target.value = null;
                });

                elements.saveSettingsBtns.forEach(button => {
                    button.addEventListener('click', () => this.saveSettings());
                });
                elements.updateAppBtn.addEventListener('click', () => this.updateApp());
                elements.clearDataBtn.addEventListener('click', () => this.confirmClearAllData());

                elements.darkModeToggle.addEventListener('change', () => {
                    state.settings.darkMode = elements.darkModeToggle.checked;
                    uiUtils.applyDarkMode();
                });

                elements.uploadBackgroundBtn.addEventListener('click', () => elements.backgroundImageInput.click());
                elements.backgroundImageInput.addEventListener('change', (event) => {
                    const file = event.target.files[0];
                    if (file) this.handleBackgroundImageUpload(file);
                    event.target.value = null;
                });
                elements.deleteBackgroundBtn.addEventListener('click', () => this.confirmDeleteBackgroundImage());

                elements.hideSystemPromptToggle.addEventListener('change', () => {
                    state.settings.hideSystemPromptInChat = elements.hideSystemPromptToggle.checked;
                    uiUtils.toggleSystemPromptVisibility();
                });
                
                elements.messageContainer.addEventListener('click', (event) => {
                    const clickedMessage = event.target.closest('.message');

                    if (event.target.closest('.message-actions button, .message-cascade-controls button')) {
                        return;
                    }

                    if (clickedMessage) {
                        const currentlyShown = elements.messageContainer.querySelector('.message.show-actions');
                        if (currentlyShown && currentlyShown !== clickedMessage) {
                            currentlyShown.classList.remove('show-actions');
                        }

                        if (!clickedMessage.classList.contains('editing')) {
                            clickedMessage.classList.toggle('show-actions');
                        }
                    } else {
                        const currentlyShown = elements.messageContainer.querySelector('.message.show-actions');
                        if (currentlyShown) {
                            currentlyShown.classList.remove('show-actions');
                        }
                    }
                });

                document.body.addEventListener('click', (event) => {
                    if (!elements.messageContainer.contains(event.target)) {
                        const currentlyShown = elements.messageContainer.querySelector('.message.show-actions');
                        if (currentlyShown) {
                            currentlyShown.classList.remove('show-actions');
                        }
                    }
                }, true); 

                elements.chatScreen.addEventListener('touchstart', this.handleTouchStart.bind(this), { passive: true });
                elements.chatScreen.addEventListener('touchmove', this.handleTouchMove.bind(this), { passive: false });
                elements.chatScreen.addEventListener('touchend', this.handleTouchEnd.bind(this));

                if ('visualViewport' in window) {
                    window.visualViewport.addEventListener('resize', this.updateZoomState.bind(this));
                    window.visualViewport.addEventListener('scroll', this.updateZoomState.bind(this));
                } else {
                    console.warn("VisualViewport API is not supported in this browser.");
                }

                window.addEventListener('popstate', this.handlePopState.bind(this));
                console.log("popstate listener added.");
                
                elements.attachFileBtn.addEventListener('click', () => uiUtils.showFileUploadDialog());
                elements.selectFilesBtn.addEventListener('click', () => elements.fileInput.click());
                elements.fileInput.addEventListener('change', (event) => {
                    this.handleFileSelection(event.target.files);
                    event.target.value = null;
                });
                elements.confirmAttachBtn.addEventListener('click', () => this.confirmAttachment());
                elements.cancelAttachBtn.addEventListener('click', () => this.cancelAttachment());
                elements.fileUploadDialog.addEventListener('close', () => {
                    if (elements.fileUploadDialog.returnValue !== 'ok') {
                        this.cancelAttachment();
                    }
                });
            },

            handlePopState(event) {
                const targetScreen = event.state?.screen || 'chat';
                console.log(`popstate event fired: Navigating to screen '${targetScreen}' from history state.`);
                uiUtils.showScreen(targetScreen, true);
            },

            updateZoomState() {
                if ('visualViewport' in window) {
                    const newZoomState = window.visualViewport.scale > ZOOM_THRESHOLD;
                    if (state.isZoomed !== newZoomState) {
                        state.isZoomed = newZoomState;
                        console.log(`Zoom state updated: ${state.isZoomed}`);
                        document.body.classList.toggle('zoomed', state.isZoomed);
                    }
                }
            },


            handleTouchStart(event) {
                if (!state.settings.enableSwipeNavigation) return;
                
                if (event.touches.length > 1 || state.isZoomed) {
                    state.touchStartX = 0;
                    state.touchStartY = 0;
                    state.isSwiping = false;
                    return;
                }
                state.touchStartX = event.touches[0].clientX;
                state.touchStartY = event.touches[0].clientY;
                state.isSwiping = false;
                state.touchEndX = state.touchStartX;
                state.touchEndY = state.touchStartY;
            },

            handleTouchMove(event) {
                if (!state.settings.enableSwipeNavigation) return;
                
                if (!state.touchStartX || event.touches.length > 1 || state.isZoomed) {
                    return;
                }

                const currentX = event.touches[0].clientX;
                const currentY = event.touches[0].clientY;
                const diffX = state.touchStartX - currentX;
                const diffY = state.touchStartY - currentY;

                if (Math.abs(diffX) > Math.abs(diffY)) {
                    state.isSwiping = true;
                    event.preventDefault();
                } else {
                    state.isSwiping = false;
                }
                state.touchEndX = currentX;
                state.touchEndY = currentY;
            },

            handleTouchEnd(event) {
                 if (!state.settings.enableSwipeNavigation) {
                     this.resetSwipeState();
                     return;
                 }

                 this.updateZoomState();
                 if (state.isZoomed) {
                     console.log("Zoomed state detected on touchend, skipping swipe navigation.");
                     this.resetSwipeState();
                     return;
                 }

                 if (!state.isSwiping || !state.touchStartX) {
                     this.resetSwipeState();
                     return;
                 }

                const diffX = state.touchStartX - state.touchEndX;
                const diffY = state.touchStartY - state.touchEndY;

                if (Math.abs(diffX) > SWIPE_THRESHOLD && Math.abs(diffX) > Math.abs(diffY)) {
                    if (diffX > 0) {
                        console.log("å·¦ã‚¹ãƒ¯ã‚¤ãƒ—æ¤œå‡º -> è¨­å®šç”»é¢ã¸");
                        uiUtils.showScreen('settings');
                    } else {
                        console.log("å³ã‚¹ãƒ¯ã‚¤ãƒ—æ¤œå‡º -> å±¥æ­´ç”»é¢ã¸");
                        uiUtils.showScreen('history');
                    }
                } else {
                    console.log("ã‚¹ãƒ¯ã‚¤ãƒ—è·é›¢ä¸è¶³ or ç¸¦ç§»å‹•å¤§");
                }

                this.resetSwipeState();
            },

            resetSwipeState() {
                state.touchStartX = 0;
                state.touchStartY = 0;
                state.touchEndX = 0;
                state.touchEndY = 0;
                state.isSwiping = false;
            },


            async confirmStartNewChat() {
                if (state.isSending) {
                    const confirmed = await uiUtils.showCustomConfirm("é€ä¿¡ä¸­ã§ã™ã€‚ä¸­æ–­ã—ã¦æ–°è¦ãƒãƒ£ãƒƒãƒˆã‚’é–‹å§‹ã—ã¾ã™ã‹ï¼Ÿ");
                    if (!confirmed) return;
                    this.abortRequest();
                }
                if (state.editingMessageIndex !== null) {
                    const confirmed = await uiUtils.showCustomConfirm("ç·¨é›†ä¸­ã§ã™ã€‚å¤‰æ›´ã‚’ç ´æ£„ã—ã¦æ–°è¦ãƒãƒ£ãƒƒãƒˆã‚’é–‹å§‹ã—ã¾ã™ã‹ï¼Ÿ");
                    if (!confirmed) return;
                    const msgEl = elements.messageContainer.querySelector(`.message[data-index="${state.editingMessageIndex}"]`);
                    this.cancelEditMessage(state.editingMessageIndex, msgEl);
                }
                if (state.isEditingSystemPrompt) {
                    const confirmed = await uiUtils.showCustomConfirm("ã‚·ã‚¹ãƒ†ãƒ ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆç·¨é›†ä¸­ã§ã™ã€‚å¤‰æ›´ã‚’ç ´æ£„ã—ã¦æ–°è¦ãƒãƒ£ãƒƒãƒˆã‚’é–‹å§‹ã—ã¾ã™ã‹ï¼Ÿ");
                    if (!confirmed) return;
                    this.cancelEditSystemPrompt();
                }
                
                if (state.pendingAttachments.length > 0) {
                    const confirmedAttach = await uiUtils.showCustomConfirm("æ·»ä»˜æº–å‚™ä¸­ã®ãƒ•ã‚¡ã‚¤ãƒ«ãŒã‚ã‚Šã¾ã™ã€‚ç ´æ£„ã—ã¦æ–°è¦ãƒãƒ£ãƒƒãƒˆã‚’é–‹å§‹ã—ã¾ã™ã‹ï¼Ÿ");
                    if (!confirmedAttach) return;
                    state.pendingAttachments = [];
                    uiUtils.updateAttachmentBadgeVisibility();
                }
                
                if ((state.currentMessages.length > 0 || state.currentSystemPrompt) && state.currentChatId) {
                    try {
                        await dbUtils.saveChat();
                    } catch (error) {
                        console.error("æ–°è¦ãƒãƒ£ãƒƒãƒˆé–‹å§‹å‰ã®ãƒãƒ£ãƒƒãƒˆä¿å­˜å¤±æ•—:", error);
                        const conf = await uiUtils.showCustomConfirm("ç¾åœ¨ã®ãƒãƒ£ãƒƒãƒˆã®ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸã€‚æ–°è¦ãƒãƒ£ãƒƒãƒˆã‚’é–‹å§‹ã—ã¾ã™ã‹ï¼Ÿ");
                        if (!conf) return;
                    }
                }
                this.startNewChat();
                uiUtils.showScreen('chat');
            },

            startNewChat() {
                state.currentChatId = null;
                state.currentMessages = [];
                state.currentSystemPrompt = state.settings.systemPrompt;
                state.pendingAttachments = [];
                uiUtils.updateSystemPromptUI();
                uiUtils.renderChatMessages();
                uiUtils.updateChatTitle();
                elements.userInput.value = '';
                uiUtils.adjustTextareaHeight();
                uiUtils.setSendingState(false);
            },

            async loadChat(id) {
                if (state.isSending) {
                    const confirmed = await uiUtils.showCustomConfirm("é€ä¿¡ä¸­ã§ã™ã€‚ä¸­æ–­ã—ã¦åˆ¥ã®ãƒãƒ£ãƒƒãƒˆã‚’èª­ã¿è¾¼ã¿ã¾ã™ã‹ï¼Ÿ");
                    if (!confirmed) return;
                    this.abortRequest();
                }
                if (state.editingMessageIndex !== null) {
                    const confirmed = await uiUtils.showCustomConfirm("ç·¨é›†ä¸­ã§ã™ã€‚å¤‰æ›´ã‚’ç ´æ£„ã—ã¦åˆ¥ã®ãƒãƒ£ãƒƒãƒˆã‚’èª­ã¿è¾¼ã¿ã¾ã™ã‹ï¼Ÿ");
                    if (!confirmed) return;
                    const msgEl = elements.messageContainer.querySelector(`.message[data-index="${state.editingMessageIndex}"]`);
                    this.cancelEditMessage(state.editingMessageIndex, msgEl);
                }
                if (state.isEditingSystemPrompt) {
                    const confirmed = await uiUtils.showCustomConfirm("ã‚·ã‚¹ãƒ†ãƒ ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆç·¨é›†ä¸­ã§ã™ã€‚å¤‰æ›´ã‚’ç ´æ£„ã—ã¦åˆ¥ã®ãƒãƒ£ãƒƒãƒˆã‚’èª­ã¿è¾¼ã¿ã¾ã™ã‹ï¼Ÿ");
                    if (!confirmed) return;
                    this.cancelEditSystemPrompt();
                }
                if (state.pendingAttachments.length > 0) {
                    const confirmedAttach = await uiUtils.showCustomConfirm("æ·»ä»˜æº–å‚™ä¸­ã®ãƒ•ã‚¡ã‚¤ãƒ«ãŒã‚ã‚Šã¾ã™ã€‚ç ´æ£„ã—ã¦åˆ¥ã®ãƒãƒ£ãƒƒãƒˆã‚’èª­ã¿è¾¼ã¿ã¾ã™ã‹ï¼Ÿ");
                    if (!confirmedAttach) return;
                    state.pendingAttachments = [];
                    uiUtils.updateAttachmentBadgeVisibility();
                }

                try {
                    const chat = await dbUtils.getChat(id);
                    if (chat) {
                        state.currentChatId = chat.id;
                        state.currentMessages = chat.messages?.map(msg => ({
                            ...msg,
                            attachments: msg.attachments || []
                        })) || [];

                        let needsSave = false;
                        const groupIds = new Set(state.currentMessages.filter(m => m.siblingGroupId).map(m => m.siblingGroupId));
                        groupIds.forEach(gid => {
                            const siblings = state.currentMessages.filter(m => m.siblingGroupId === gid);
                            const selected = siblings.filter(m => m.isSelected);
                            if (selected.length === 0 && siblings.length > 0) {
                                siblings[siblings.length - 1].isSelected = true;
                                needsSave = true;
                            } else if (selected.length > 1) {
                                selected.slice(0, -1).forEach(m => m.isSelected = false);
                                needsSave = true;
                            }
                        });

                        state.currentSystemPrompt = chat.systemPrompt !== undefined ? chat.systemPrompt : state.settings.systemPrompt;
                        state.pendingAttachments = [];
                        uiUtils.updateSystemPromptUI();
                        uiUtils.renderChatMessages();
                        uiUtils.updateChatTitle(chat.title);
                        elements.userInput.value = '';
                        uiUtils.adjustTextareaHeight();
                        uiUtils.setSendingState(false);

                        if (needsSave) {
                            console.log("èª­ã¿è¾¼ã¿æ™‚ã« isSelected ã‚’æ­£è¦åŒ–ã—ã¾ã—ãŸã€‚DBã«ä¿å­˜ã—ã¾ã™ã€‚");
                            await dbUtils.saveChat();
                        }

                        history.replaceState({ screen: 'chat' }, '', '#chat');
                        state.currentScreen = 'chat';
                        console.log("ãƒãƒ£ãƒƒãƒˆèª­ã¿è¾¼ã¿å®Œäº†:", id, "å±¥æ­´çŠ¶æ…‹ã‚’ #chat ã«è¨­å®š");
                    } else {
                        await uiUtils.showCustomAlert("ãƒãƒ£ãƒƒãƒˆå±¥æ­´ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚");
                        this.startNewChat();
                        uiUtils.showScreen('chat');
                    }
                } catch (error) {
                    await uiUtils.showCustomAlert(`ãƒãƒ£ãƒƒãƒˆã®èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼: ${error}`);
                    this.startNewChat();
                    uiUtils.showScreen('chat');
                }
            },

            async duplicateChat(id) {
                if (state.isSending) { const conf = await uiUtils.showCustomConfirm("é€ä¿¡ä¸­ã§ã™ã€‚ä¸­æ–­ã—ã¦ãƒãƒ£ãƒƒãƒˆã‚’è¤‡è£½ã—ã¾ã™ã‹ï¼Ÿ"); if (!conf) return; this.abortRequest(); }
                if (state.editingMessageIndex !== null) { const conf = await uiUtils.showCustomConfirm("ç·¨é›†ä¸­ã§ã™ã€‚å¤‰æ›´ã‚’ç ´æ£„ã—ã¦ãƒãƒ£ãƒƒãƒˆã‚’è¤‡è£½ã—ã¾ã™ã‹ï¼Ÿ"); if (!conf) return; const msgEl = elements.messageContainer.querySelector(`.message[data-index="${state.editingMessageIndex}"]`); this.cancelEditMessage(state.editingMessageIndex, msgEl); }
                if (state.isEditingSystemPrompt) { const conf = await uiUtils.showCustomConfirm("ã‚·ã‚¹ãƒ†ãƒ ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆç·¨é›†ä¸­ã§ã™ã€‚å¤‰æ›´ã‚’ç ´æ£„ã—ã¦ãƒãƒ£ãƒƒãƒˆã‚’è¤‡è£½ã—ã¾ã™ã‹ï¼Ÿ"); if (!conf) return; this.cancelEditSystemPrompt(); }
                if ((state.currentMessages.length > 0 || state.currentSystemPrompt) && state.currentChatId && state.currentChatId !== id) { try { await dbUtils.saveChat(); } catch (error) { console.error("è¤‡è£½å‰ã®ç¾ãƒãƒ£ãƒƒãƒˆä¿å­˜å¤±æ•—:", error); const conf = await uiUtils.showCustomConfirm("ç¾åœ¨ã®ãƒãƒ£ãƒƒãƒˆä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸã€‚è¤‡è£½ã‚’ç¶šè¡Œã—ã¾ã™ã‹ï¼Ÿ"); if (!conf) return; } }
                if (state.pendingAttachments.length > 0) {
                    const confirmedAttach = await uiUtils.showCustomConfirm("æ·»ä»˜æº–å‚™ä¸­ã®ãƒ•ã‚¡ã‚¤ãƒ«ãŒã‚ã‚Šã¾ã™ã€‚ç ´æ£„ã—ã¦ãƒãƒ£ãƒƒãƒˆã‚’è¤‡è£½ã—ã¾ã™ã‹ï¼Ÿ");
                    if (!confirmedAttach) return;
                    state.pendingAttachments = [];
                }

                try {
                    const chat = await dbUtils.getChat(id);
                    if (chat) {
                        const originalTitle = chat.title || "ç„¡é¡Œã®ãƒãƒ£ãƒƒãƒˆ";
                        const newTitle = originalTitle.replace(new RegExp(DUPLICATE_SUFFIX.replace(/([().])/g, '\\$1') + '$'), '').trim() + DUPLICATE_SUFFIX;

                        const duplicatedMessages = [];
                        const groupIdMap = new Map();
                        (chat.messages || []).forEach(msg => {
                            const newMsg = JSON.parse(JSON.stringify(msg));
                            newMsg.attachments = msg.attachments ? JSON.parse(JSON.stringify(msg.attachments)) : [];
                            newMsg.isCascaded = msg.isCascaded ?? false;
                            newMsg.isSelected = msg.isSelected ?? false;
                            if (msg.siblingGroupId) {
                                if (!groupIdMap.has(msg.siblingGroupId)) {
                                    groupIdMap.set(msg.siblingGroupId, `dup-${Date.now()}-${Math.random().toString(36).substring(2, 8)}`);
                                }
                                newMsg.siblingGroupId = groupIdMap.get(msg.siblingGroupId);
                            } else {
                                delete newMsg.siblingGroupId;
                            }
                            duplicatedMessages.push(newMsg);
                        });

                        const newGroupIds = new Set(duplicatedMessages.filter(m => m.siblingGroupId).map(m => m.siblingGroupId));
                        newGroupIds.forEach(gid => {
                            const siblings = duplicatedMessages.filter(m => m.siblingGroupId === gid);
                            siblings.forEach((m, idx) => {
                                m.isSelected = (idx === siblings.length - 1);
                            });
                        });

                        const newChatData = {
                            messages: duplicatedMessages,
                            systemPrompt: chat.systemPrompt || '',
                            updatedAt: Date.now(),
                            createdAt: Date.now(),
                            title: newTitle
                        };
                        const newChatId = await new Promise((resolve, reject) => {
                            const store = dbUtils._getStore(CHATS_STORE, 'readwrite');
                            const request = store.add(newChatData);
                            request.onsuccess = (event) => resolve(event.target.result);
                            request.onerror = (event) => reject(event.target.error);
                        });
                        console.log("ãƒãƒ£ãƒƒãƒˆè¤‡è£½å®Œäº†:", id, "->", newChatId);
                        if (state.currentScreen === 'history') {
                            uiUtils.renderHistoryList();
                        } else {
                            await uiUtils.showCustomAlert(`ãƒãƒ£ãƒƒãƒˆã€Œ${newTitle}ã€ã‚’è¤‡è£½ã—ã¾ã—ãŸã€‚`);
                        }
                    } else {
                        await uiUtils.showCustomAlert("è¤‡è£½å…ƒã®ãƒãƒ£ãƒƒãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚");
                    }
                } catch (error) {
                    await uiUtils.showCustomAlert(`ãƒãƒ£ãƒƒãƒˆè¤‡è£½ã‚¨ãƒ©ãƒ¼: ${error}`);
                }
            },

            async exportChat(chatId, chatTitle) {
                 const confirmed = await uiUtils.showCustomConfirm(`ãƒãƒ£ãƒƒãƒˆã€Œ${chatTitle || 'ã“ã®å±¥æ­´'}ã€ã‚’ãƒ†ã‚­ã‚¹ãƒˆå‡ºåŠ›ã—ã¾ã™ã‹ï¼Ÿ`);
                 if (!confirmed) return;

                 try {
                     const chat = await dbUtils.getChat(chatId);
                     if (!chat || ((!chat.messages || chat.messages.length === 0) && !chat.systemPrompt)) {
                         await uiUtils.showCustomAlert("ãƒãƒ£ãƒƒãƒˆãƒ‡ãƒ¼ã‚¿ãŒç©ºã§ã™ã€‚");
                         return;
                     }
                     let exportText = '';
                     if (chat.systemPrompt) {
                         exportText += `<|#|system|#|>\n${chat.systemPrompt}\n<|#|/system|#|>\n\n`;
                     }
                     if (chat.messages) {
                         chat.messages.forEach(msg => {
                             if (msg.role === 'user' || msg.role === 'model') {
                                 let attributes = '';
                                 if (msg.role === 'model') {
                                     if (msg.isCascaded) attributes += ' isCascaded';
                                     if (msg.isSelected) attributes += ' isSelected';
                                 }
                                 if (msg.role === 'user' && msg.attachments && msg.attachments.length > 0) {
                                     const fileNames = msg.attachments.map(a => a.name).join(';');
                                     attributes += ` attachments="${fileNames.replace(/"/g, '&quot;')}"`;
                                 }
                                 exportText += `<|#|${msg.role}|#|${attributes}>\n${msg.content}\n<|#|/${msg.role}|#|>\n\n`;
                             }
                         });
                     }
                     const blob = new Blob([exportText.trim()], { type: 'text/plain;charset=utf-8' });
                     const url = URL.createObjectURL(blob);
                     const a = document.createElement('a');
                     const safeTitle = (chatTitle || `chat_${chatId}_export`).replace(/[<>:"/\\|?*\s]/g, '_');
                     a.href = url;
                     a.download = `${safeTitle}.txt`;
                     document.body.appendChild(a);
                     a.click();
                     document.body.removeChild(a);
                     URL.revokeObjectURL(url);
                     console.log("ãƒãƒ£ãƒƒãƒˆã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆå®Œäº†:", chatId);
                 } catch (error) {
                     await uiUtils.showCustomAlert(`ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã‚¨ãƒ©ãƒ¼: ${error}`);
                 }
            },

            async confirmDeleteChat(id, title) {
                 const confirmed = await uiUtils.showCustomConfirm(`ã€Œ${title || 'ã“ã®å±¥æ­´'}ã€ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ`);
                 if (confirmed) {
                    const isDeletingCurrent = state.currentChatId === id;
                    const currentScreenBeforeDelete = state.currentScreen;

                    try {
                        await dbUtils.deleteChat(id);
                        console.log("ãƒãƒ£ãƒƒãƒˆå‰Šé™¤:", id);

                        if (isDeletingCurrent) {
                            console.log("è¡¨ç¤ºä¸­ã®ãƒãƒ£ãƒƒãƒˆãŒå‰Šé™¤ã•ã‚ŒãŸãŸã‚ã€å†…éƒ¨çŠ¶æ…‹ã‚’æ–°è¦ãƒãƒ£ãƒƒãƒˆã«ãƒªã‚»ãƒƒãƒˆã€‚");
                            this.startNewChat();
                        }

                        if (currentScreenBeforeDelete === 'history') {
                            console.log("å±¥æ­´ç”»é¢ã§ã®æ“ä½œã®ãŸã‚ã€ãƒªã‚¹ãƒˆUIã‚’æ›´æ–°ã—ã¾ã™ã€‚");
                            await uiUtils.renderHistoryList();
                            const listIsEmpty = elements.historyList.querySelectorAll('.history-item:not(.js-history-item-template)').length === 0;

                            if (listIsEmpty) {
                                console.log("å±¥æ­´ãƒªã‚¹ãƒˆãŒç©ºã«ãªã‚Šã¾ã—ãŸã€‚");
                                if (!isDeletingCurrent) {
                                    this.startNewChat();
                                }
                            }
                        }

                    } catch (error) {
                        await uiUtils.showCustomAlert(`ãƒãƒ£ãƒƒãƒˆå‰Šé™¤ã‚¨ãƒ©ãƒ¼: ${error}`);
                        uiUtils.setSendingState(false);
                    }
                }
            },

            async editHistoryTitle(chatId, titleElement) {
                const currentTitle = titleElement.textContent;
                const newTitle = await uiUtils.showCustomPrompt("æ–°ã—ã„ã‚¿ã‚¤ãƒˆãƒ«:", currentTitle);

                const trimmedTitle = (newTitle !== null) ? newTitle.trim() : '';

                if (newTitle !== '' && trimmedTitle !== '' && trimmedTitle !== currentTitle) {
                    const finalTitle = trimmedTitle.substring(0, 100);
                    try {
                        await dbUtils.updateChatTitleDb(chatId, finalTitle);
                        titleElement.textContent = finalTitle;
                        titleElement.title = finalTitle;
                        const dateElement = titleElement.closest('.history-item')?.querySelector('.updated-date');
                        if(dateElement) dateElement.textContent = `æ›´æ–°: ${uiUtils.formatDate(Date.now())}`;
                        if (state.currentChatId === chatId) {
                            uiUtils.updateChatTitle(finalTitle);
                        }
                    } catch (error) {
                        await uiUtils.showCustomAlert(`ã‚¿ã‚¤ãƒˆãƒ«æ›´æ–°ã‚¨ãƒ©ãƒ¼: ${error}`);
                    }
                } else {
                    console.log("ã‚¿ã‚¤ãƒˆãƒ«ç·¨é›†ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã¾ãŸã¯å¤‰æ›´ãªã—");
                }
            },

            async handleSend(isRetry = false, retryUserMessageIndex = -1) {
                if (state.editingMessageIndex !== null) { await uiUtils.showCustomAlert("ä»–ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ç·¨é›†ä¸­ã§ã™ã€‚"); return; }
                if (state.isEditingSystemPrompt) { await uiUtils.showCustomAlert("ã‚·ã‚¹ãƒ†ãƒ ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’ç·¨é›†ä¸­ã§ã™ã€‚"); return; }

                let text = '';
                let attachmentsToSend = [];
                if (isRetry) {
                    const retryUserMessage = state.currentMessages[retryUserMessageIndex];
                    if (!retryUserMessage || retryUserMessage.role !== 'user') {
                        console.error("ãƒªãƒˆãƒ©ã‚¤å¯¾è±¡ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚", retryUserMessageIndex);
                        uiUtils.setSendingState(false);
                        return;
                    }
                    text = retryUserMessage.content || '';
                    attachmentsToSend = retryUserMessage.attachments ? [...retryUserMessage.attachments] : [];
                } else {
                    text = elements.userInput.value.trim();
                    attachmentsToSend = [...state.pendingAttachments];
                }

                if (state.isSending || (!text && attachmentsToSend.length === 0)) {
                    if(!text && attachmentsToSend.length === 0) console.log("å…¥åŠ›ã‚‚æ·»ä»˜ãƒ•ã‚¡ã‚¤ãƒ«ã‚‚ã‚ã‚Šã¾ã›ã‚“ã€‚");
                    return;
                }
                if (!state.settings.apiKey) { await uiUtils.showCustomAlert("APIã‚­ãƒ¼ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚è¨­å®šç”»é¢ã‚’é–‹ãã¾ã™ã€‚"); uiUtils.showScreen('settings'); return; }

                uiUtils.setSendingState(true);

                let userMessageIndex = isRetry ? retryUserMessageIndex : -1;
                let existingSiblingGroupId = null;
                let firstResponseIndexForRetry = -1;
                let siblingGroupIdToUse = null;

                if (!isRetry) {
                    const userMessage = {
                        role: 'user',
                        content: text,
                        timestamp: Date.now(),
                        attachments: attachmentsToSend
                    };
                    state.currentMessages.push(userMessage);
                    userMessageIndex = state.currentMessages.length - 1;
                    uiUtils.appendMessage(userMessage.role, userMessage.content, userMessageIndex, false, null, userMessage.attachments);
                    elements.userInput.value = '';
                    state.pendingAttachments = [];
                    uiUtils.adjustTextareaHeight();
                    uiUtils.scrollToBottom();
                } else {
                    console.log("ãƒªãƒˆãƒ©ã‚¤å‡¦ç†é–‹å§‹ (handleSendå†…):", state.currentMessages[userMessageIndex]);
                    let siblingStartIndex = userMessageIndex + 1;
                    while (siblingStartIndex < state.currentMessages.length && state.currentMessages[siblingStartIndex].role !== 'model') {
                        siblingStartIndex++;
                    }
                    if (siblingStartIndex < state.currentMessages.length && state.currentMessages[siblingStartIndex].role === 'model') {
                         firstResponseIndexForRetry = siblingStartIndex;
                         const firstResponse = state.currentMessages[firstResponseIndexForRetry];
                         if (firstResponse.isCascaded && firstResponse.siblingGroupId) {
                             existingSiblingGroupId = firstResponse.siblingGroupId;
                             state.currentMessages.forEach(msg => {
                                 if (msg.siblingGroupId === existingSiblingGroupId) {
                                     msg.isSelected = false;
                                 }
                             });
                             console.log(`ãƒªãƒˆãƒ©ã‚¤: æ—¢å­˜ã®å¿œç­”ã‚°ãƒ«ãƒ¼ãƒ— (${existingSiblingGroupId}) ã® isSelected ã‚’ false ã«è¨­å®š.`);
                             siblingGroupIdToUse = existingSiblingGroupId;
                         } else {
                             console.log("ãƒªãƒˆãƒ©ã‚¤: æœ€åˆã®å¿œç­”ã‚’æ–°ã—ã„ã‚«ã‚¹ã‚±ãƒ¼ãƒ‰ã‚°ãƒ«ãƒ¼ãƒ—ã«å«ã‚ã¾ã™ã€‚");
                         }
                    } else {
                        console.warn("ãƒªãƒˆãƒ©ã‚¤å¯¾è±¡ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®å¾Œã«ãƒ¢ãƒ‡ãƒ«å¿œç­”ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚");
                    }
                }

                try {
                    let titleToSave = null;
                    if(state.currentChatId) {
                        const currentChat = await dbUtils.getChat(state.currentChatId);
                        if(currentChat) titleToSave = currentChat.title;
                    }
                    if (!titleToSave) {
                        const firstUserMsg = state.currentMessages.find(m => m.role === 'user');
                        if(firstUserMsg) {
                            titleToSave = firstUserMsg.content.substring(0, 50);
                        }
                    }
                    await dbUtils.saveChat(titleToSave);
                } catch (error) {
                    console.error("é€ä¿¡å‰ã®ãƒãƒ£ãƒƒãƒˆä¿å­˜å¤±æ•—:", error);
                    uiUtils.displayError("ãƒãƒ£ãƒƒãƒˆã®ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸãŒã€é€ä¿¡ã‚’è©¦ã¿ã¾ã™ã€‚", false);
                }

                const messagesToProcess = isRetry
                    ? state.currentMessages.slice(0, userMessageIndex + 1)
                    : [...state.currentMessages];

                const apiMessages = messagesToProcess
                    .filter(msg => {
                        if (msg.role === 'user') return true;
                        if (msg.role === 'model') return !msg.isCascaded || (msg.isCascaded && msg.isSelected);
                        return false;
                    })
                    .map(msg => {
                        const parts = [];
                        if (msg.content && msg.content.trim() !== '') {
                            parts.push({ text: msg.content });
                        }
                        if (msg.role === 'user' && msg.attachments && msg.attachments.length > 0) {
                            msg.attachments.forEach(att => {
                                parts.push({
                                    inlineData: {
                                        mimeType: att.mimeType,
                                        data: att.base64Data
                                    }
                                });
                            });
                        }
                        return { role: msg.role, parts: parts };
                    });

                const dummyUserTextForApi = state.settings.dummyUser?.trim();
                const dummyModelTextForApi = state.settings.dummyModel?.trim();
                if (dummyUserTextForApi) apiMessages.push({ role: 'user', parts: [{ text: dummyUserTextForApi }] });
                if (dummyModelTextForApi) apiMessages.push({ role: 'model', parts: [{ text: dummyModelTextForApi }] });

                const generationConfig = {};
                if (state.settings.temperature !== null) generationConfig.temperature = state.settings.temperature;
                if (state.settings.maxTokens !== null) generationConfig.maxOutputTokens = state.settings.maxTokens;
                if (state.settings.topK !== null) generationConfig.topK = state.settings.topK;
                if (state.settings.topP !== null) generationConfig.topP = state.settings.topP;

                const systemInstruction = state.currentSystemPrompt?.trim()
                    ? { role: "system", parts: [{ text: state.currentSystemPrompt.trim() }] }
                    : null;

                let modelResponseRawContent = '';
                let modelThoughtSummaryContent = '';
                let modelResponseMetadata = {};
                let currentGroundingMetadata = null;
                let finalUsageMetadataFromStream = null;

                const dummyModelTextFromSettings = state.settings.dummyModel?.trim();
                const applyDummyToThoughts = state.settings.concatDummyModel && dummyModelTextFromSettings;

                try {
                    const response = await apiUtils.callGeminiApi(apiMessages, generationConfig, systemInstruction);
                    
                    state.partialStreamContent = '';
                    state.partialThoughtStreamContent = applyDummyToThoughts ? dummyModelTextFromSettings + '\n\n' : '';
                    let isProcessingThoughtInStream = false;


                    if (state.settings.streamingOutput) {
                        const tempPlaceholderIndex = state.currentMessages.length;

                        const placeholderMessageDiv = document.createElement('div');
                        placeholderMessageDiv.classList.add('message', 'model');
                        placeholderMessageDiv.id = `streaming-message-${tempPlaceholderIndex}`;

                        if (state.settings.includeThoughts || applyDummyToThoughts) {
                            const thoughtDetails = document.createElement('details');
                            thoughtDetails.classList.add('thought-summary-details');
                            const thoughtSummaryElem = document.createElement('summary');
                            thoughtSummaryElem.textContent = 'æ€è€ƒãƒ—ãƒ­ã‚»ã‚¹';
                            thoughtDetails.appendChild(thoughtSummaryElem);
                            const thoughtContentDiv = document.createElement('div');
                            thoughtContentDiv.classList.add('thought-summary-content');
                            thoughtContentDiv.id = `streaming-thought-summary-${tempPlaceholderIndex}`;
                            thoughtDetails.appendChild(thoughtContentDiv);
                            placeholderMessageDiv.appendChild(thoughtDetails);
                        }
                        const contentDiv = document.createElement('div');
                        contentDiv.classList.add('message-content');
                        placeholderMessageDiv.appendChild(contentDiv);
                        elements.messageContainer.appendChild(placeholderMessageDiv);

                        const streamSpeed = state.settings.streamingSpeed;
                        let thoughtBuffer = ""; // Temporary buffer for thoughtText
                        let contentBuffer = ""; // Temporary buffer for contentText

                        for await (const streamData of apiUtils.handleStreamingResponse(response)) {
                            if (state.abortController?.signal.aborted) {
                                modelResponseMetadata.finishReason = 'ABORTED';
                                throw new Error("ãƒªã‚¯ã‚¨ã‚¹ãƒˆãŒã‚­ãƒ£ãƒ³ã‚»ãƒ«ã•ã‚Œã¾ã—ãŸã€‚");
                            }

                            if (streamData.type === 'chunk') {
                                if (streamData.thoughtText) {
                                    isProcessingThoughtInStream = true;
                                    thoughtBuffer += streamData.thoughtText;
                                }
                                if (streamData.contentText) {
                                    if (isProcessingThoughtInStream) {
                                        isProcessingThoughtInStream = false; 
                                        for (const char of thoughtBuffer) {
                                            if (state.abortController?.signal.aborted) break;
                                            state.partialThoughtStreamContent += char;
                                            uiUtils.updateStreamingMessage(tempPlaceholderIndex, char, true);
                                            if (streamSpeed > 0) await sleep(streamSpeed);
                                        }
                                        thoughtBuffer = ""; 
                                    }
                                    contentBuffer += streamData.contentText;
                                }

                                if (!isProcessingThoughtInStream && contentBuffer) {
                                     for (const char of contentBuffer) {
                                        if (state.abortController?.signal.aborted) break;
                                        state.partialStreamContent += char;
                                        uiUtils.updateStreamingMessage(tempPlaceholderIndex, char, false);
                                        if (streamSpeed > 0) await sleep(streamSpeed);
                                    }
                                    contentBuffer = "";
                                }
                                
                                if (state.abortController?.signal.aborted) {
                                    modelResponseMetadata.finishReason = 'ABORTED';
                                    throw new Error("ãƒªã‚¯ã‚¨ã‚¹ãƒˆãŒã‚­ãƒ£ãƒ³ã‚»ãƒ«ã•ã‚Œã¾ã—ãŸã€‚");
                                }
                                if (streamData.groundingMetadata) currentGroundingMetadata = streamData.groundingMetadata;
                                if (streamData.usageMetadata) finalUsageMetadataFromStream = streamData.usageMetadata;

                            } else if (streamData.type === 'metadata') {
                                modelResponseMetadata = {
                                    finishReason: streamData.finishReason,
                                    safetyRatings: streamData.safetyRatings,
                                };
                                if (streamData.groundingMetadata) currentGroundingMetadata = streamData.groundingMetadata;
                                if (streamData.usageMetadata) finalUsageMetadataFromStream = streamData.usageMetadata;
                                console.log("ã‚¹ãƒˆãƒªãƒ¼ãƒ çµ‚äº†ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿å—ä¿¡:", streamData);
                                break;
                            } else if (streamData.type === 'error') {
                                modelResponseMetadata.finishReason = 'ERROR';
                                modelResponseMetadata.error = streamData.error;
                                throw new Error(streamData.message || "ã‚¹ãƒˆãƒªãƒ¼ãƒ å†…ã§ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚");
                            }
                        }
                        
                        if (thoughtBuffer) {
                             for (const char of thoughtBuffer) {
                                if (state.abortController?.signal.aborted) break;
                                state.partialThoughtStreamContent += char;
                                uiUtils.updateStreamingMessage(tempPlaceholderIndex, char, true);
                                if (streamSpeed > 0) await sleep(streamSpeed);
                            }
                        }
                        if (contentBuffer && !state.abortController?.signal.aborted) {
                             for (const char of contentBuffer) {
                                state.partialStreamContent += char;
                                uiUtils.updateStreamingMessage(tempPlaceholderIndex, char, false);
                                if (streamSpeed > 0) await sleep(streamSpeed);
                            }
                        }

                        modelThoughtSummaryContent = state.partialThoughtStreamContent.trim();
                        modelResponseRawContent = state.partialStreamContent.trim();

                        if (modelResponseMetadata.finishReason === 'ABORTED' || state.abortController?.signal.aborted) {
                            throw new Error("ãƒªã‚¯ã‚¨ã‚¹ãƒˆãŒã‚­ãƒ£ãƒ³ã‚»ãƒ«ã•ã‚Œã¾ã—ãŸã€‚");
                        }

                    } else { 
                        const data = await response.json();
                        console.log("APIå¿œç­” (éžã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°):", data);
                        const candidate = data.candidates?.[0];
                        
                        let rawContentFromApi = "";
                        let thoughtSummaryFromApi = "";

                        if (candidate) {
                            modelResponseMetadata = { finishReason: candidate.finishReason, safetyRatings: candidate.safetyRatings };
                            candidate.content?.parts?.forEach(part => {
                                if (part.thought === true) {
                                    thoughtSummaryFromApi += (part.text || "") + "\n\n";
                                } else {
                                    rawContentFromApi += (part.text || "") + "\n\n";
                                }
                            });
                            thoughtSummaryFromApi = thoughtSummaryFromApi.trim();
                            rawContentFromApi = rawContentFromApi.trim();

                            currentGroundingMetadata = candidate.groundingMetadata || null;
                            finalUsageMetadataFromStream = data.usageMetadata || null;
                            if (candidate.finishReason && candidate.finishReason !== "STOP" && candidate.finishReason !== "MAX_TOKENS") {
                                rawContentFromApi += `\n\n(ç†ç”±: ${candidate.finishReason})`;
                            }
                            if (!rawContentFromApi && candidate.finishReason === "STOP" && !thoughtSummaryFromApi) {
                                rawContentFromApi = "(å¿œç­”ãŒç©ºã§ã™)";
                            }
                        } else {
                            rawContentFromApi = "å¿œç­”å€™è£œãŒã‚ã‚Šã¾ã›ã‚“";
                            if(data.promptFeedback) {
                                rawContentFromApi += ` (ç†ç”±: ${data.promptFeedback.blockReason || 'ä¸æ˜Ž'})`;
                                modelResponseMetadata.promptFeedback = data.promptFeedback;
                                modelResponseMetadata.finishReason = data.promptFeedback.blockReason || 'ERROR';
                            } else {
                                modelResponseMetadata.finishReason = 'ERROR';
                            }
                            finalUsageMetadataFromStream = data.usageMetadata || null;
                        }
                        
                        modelResponseRawContent = rawContentFromApi;
                        modelThoughtSummaryContent = applyDummyToThoughts 
                            ? (dummyModelTextFromSettings + (thoughtSummaryFromApi ? '\n\n' + thoughtSummaryFromApi : '')).trim() 
                            : thoughtSummaryFromApi;
                    }
                    
                    if (modelResponseRawContent || modelThoughtSummaryContent.trim() || modelResponseMetadata.finishReason) {
                         const newModelMessage = {
                             role: 'model',
                             content: modelResponseRawContent,
                             thoughtSummary: modelThoughtSummaryContent.trim() ? modelThoughtSummaryContent.trim() : null,
                             timestamp: Date.now(),
                             ...modelResponseMetadata,
                             groundingMetadata: currentGroundingMetadata,
                             usageMetadata: finalUsageMetadataFromStream
                         };

                         const targetUserIndexForCascade = userMessageIndex;
                         if (targetUserIndexForCascade !== -1) {
                             if (siblingGroupIdToUse === null) {
                                 siblingGroupIdToUse = `gid-${Date.now()}-${Math.random().toString(36).substring(2, 8)}`;
                                 console.log("ã‚«ã‚¹ã‚±ãƒ¼ãƒ‰ãƒ•ãƒ©ã‚°è¨­å®š: æ–°è¦ siblingGroupId ã‚’ç”Ÿæˆ:", siblingGroupIdToUse);
                             }
                             newModelMessage.isCascaded = true;
                             newModelMessage.isSelected = true;
                             newModelMessage.siblingGroupId = siblingGroupIdToUse;

                             if (isRetry && firstResponseIndexForRetry !== -1 && state.currentMessages[firstResponseIndexForRetry] && !state.currentMessages[firstResponseIndexForRetry].isCascaded) {
                                 state.currentMessages[firstResponseIndexForRetry].isCascaded = true;
                                 state.currentMessages[firstResponseIndexForRetry].siblingGroupId = siblingGroupIdToUse;
                                 console.log(`æœ€åˆã®å¿œç­” (index ${firstResponseIndexForRetry}) ã«ãƒ•ãƒ©ã‚°è¨­å®š: isCascaded=true, siblingGroupId=${siblingGroupIdToUse}`);
                             }
                             console.log(`å¿œç­”ã«ãƒ•ãƒ©ã‚°è¨­å®š: isCascaded=true, isSelected=true, siblingGroupId=${newModelMessage.siblingGroupId}`);
                         }

                         state.currentMessages.push(newModelMessage);
                         if (state.settings.streamingOutput) {
                             uiUtils.finalizeStreamingMessage(state.currentMessages.length - 1);
                         } else {
                            uiUtils.renderChatMessages();
                            uiUtils.scrollToBottom(); 
                         }
                         await dbUtils.saveChat();
                         console.log("ãƒ¢ãƒ‡ãƒ«å¿œç­”ä¿å­˜å®Œäº†");
                    } else {
                        console.log("ãƒ¢ãƒ‡ãƒ«å¿œç­”ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ãŒãªã„ãŸã‚ä¿å­˜ã—ã¾ã›ã‚“ã€‚");
                         if (state.settings.streamingOutput) {
                            const tempPlaceholderIndex = state.currentMessages.length;
                            const placeholderElement = document.getElementById(`streaming-message-${tempPlaceholderIndex}`);
                            if (placeholderElement) placeholderElement.remove();
                         }
                    }
                } catch (error) {
                    console.error("Geminiå‘¼ã³å‡ºã—/å‡¦ç†ä¸­ã®ã‚¨ãƒ©ãƒ¼:", error);
                    const isAbort = error.message === "ãƒªã‚¯ã‚¨ã‚¹ãƒˆãŒã‚­ãƒ£ãƒ³ã‚»ãƒ«ã•ã‚Œã¾ã—ãŸã€‚" || modelResponseMetadata.finishReason === 'ABORTED';
                    const displayErrorMessage = isAbort ? error.message : (error.message || "ä¸æ˜Žãªã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ");

                    const partialThoughtContentOnError = state.partialThoughtStreamContent.trim();
                    const partialContentOnError = state.partialStreamContent.trim();

                    if ((partialContentOnError || partialThoughtContentOnError) && state.settings.streamingOutput) {
                         const finalPartialContent = partialContentOnError + (partialContentOnError ? `\n\n(${isAbort ? 'ä¸­æ–­ã•ã‚Œã¾ã—ãŸ' : 'ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ'})` : `(${isAbort ? 'ä¸­æ–­ã•ã‚Œã¾ã—ãŸ' : 'ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ'})`);
                         const finalPartialThought = partialThoughtContentOnError ? partialThoughtContentOnError + `\n\n(${isAbort ? 'ä¸­æ–­ã•ã‚Œã¾ã—ãŸ' : 'ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ'})` : null;

                         const partialMessage = {
                             role: 'model',
                             content: finalPartialContent,
                             thoughtSummary: finalPartialThought,
                             timestamp: Date.now(),
                             error: true,
                             finishReason: isAbort ? 'ABORTED' : (modelResponseMetadata.finishReason || 'ERROR'),
                             ...(modelResponseMetadata.safetyRatings && { safetyRatings: modelResponseMetadata.safetyRatings }),
                             groundingMetadata: currentGroundingMetadata,
                             usageMetadata: finalUsageMetadataFromStream
                         };
                         if (isRetry && isAbort) {
                             if (siblingGroupIdToUse === null) {
                                 siblingGroupIdToUse = `gid-${Date.now()}-${Math.random().toString(36).substring(2, 8)}`;
                                 console.log("ãƒªãƒˆãƒ©ã‚¤ä¸­æ–­ã‚¨ãƒ©ãƒ¼: æ–°è¦ siblingGroupId ã‚’ç”Ÿæˆ:", siblingGroupIdToUse);
                             } else {
                                 console.log("ãƒªãƒˆãƒ©ã‚¤ä¸­æ–­ã‚¨ãƒ©ãƒ¼: æ—¢å­˜ã® siblingGroupId ã‚’ä½¿ç”¨:", siblingGroupIdToUse);
                             }
                             partialMessage.isCascaded = true;
                             partialMessage.siblingGroupId = siblingGroupIdToUse;
                             partialMessage.isSelected = true;
                             console.log(`ãƒªãƒˆãƒ©ã‚¤ä¸­æ–­ã‚¨ãƒ©ãƒ¼: éƒ¨åˆ†ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã«ã‚«ã‚¹ã‚±ãƒ¼ãƒ‰ãƒ•ãƒ©ã‚°è¨­å®š (gid: ${siblingGroupIdToUse})`);
                             if (firstResponseIndexForRetry !== -1 && state.currentMessages[firstResponseIndexForRetry] && !state.currentMessages[firstResponseIndexForRetry].isCascaded) {
                                 state.currentMessages[firstResponseIndexForRetry].isCascaded = true;
                                 state.currentMessages[firstResponseIndexForRetry].siblingGroupId = siblingGroupIdToUse;
                                 console.log(`ãƒªãƒˆãƒ©ã‚¤ä¸­æ–­ã‚¨ãƒ©ãƒ¼: æœ€åˆã®å¿œç­” (index ${firstResponseIndexForRetry}) ã«ã‚‚ãƒ•ãƒ©ã‚°è¨­å®š: isCascaded=true, siblingGroupId=${siblingGroupIdToUse}`);
                             }
                         }
                         state.currentMessages.push(partialMessage);
                         try {
                             if (state.settings.streamingOutput) {
                                 uiUtils.finalizeStreamingMessage(state.currentMessages.length - 1);
                             } else {
                                 uiUtils.renderChatMessages();
                                 uiUtils.scrollToBottom();
                             }
                             await dbUtils.saveChat();
                             console.log("éƒ¨åˆ†çš„ãªãƒ¡ãƒƒã‚»ãƒ¼ã‚¸çŠ¶æ…‹ã‚’ä¿å­˜ã—ã¾ã—ãŸã€‚");
                         } catch (saveError) {
                             console.error("éƒ¨åˆ†ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®ä¿å­˜å¤±æ•—:", saveError);
                             uiUtils.displayError(displayErrorMessage, !isAbort);
                         }
                    } else {
                        if (state.settings.streamingOutput && !isAbort) {
                            const tempPlaceholderIndex = state.currentMessages.length;
                            const placeholderElement = document.getElementById(`streaming-message-${tempPlaceholderIndex}`);
                            if (placeholderElement) placeholderElement.remove();
                        }
                        uiUtils.displayError(displayErrorMessage, !isAbort);
                    }
                } finally {
                    uiUtils.setSendingState(false);
                    state.abortController = null;
                    state.partialStreamContent = '';
                    state.partialThoughtStreamContent = '';
                    uiUtils.scrollToBottom();
                    uiUtils.updateAttachmentBadgeVisibility();
                }
            },

            abortRequest() {
                if (state.abortController) {
                    console.log("ä¸­æ–­ãƒªã‚¯ã‚¨ã‚¹ãƒˆé€ä¿¡");
                    state.abortController.abort();
                } else {
                    console.log("ä¸­æ–­ã™ã‚‹ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªãƒªã‚¯ã‚¨ã‚¹ãƒˆãŒã‚ã‚Šã¾ã›ã‚“ã€‚");
                }
            },

            async handleHistoryImport(file) {
                if (!file || !file.type.startsWith('text/plain')) {
                    await uiUtils.showCustomAlert("ãƒ†ã‚­ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ« (.txt) ã‚’é¸æŠžã—ã¦ãã ã•ã„ã€‚");
                    return;
                }
                console.log("å±¥æ­´ã‚¤ãƒ³ãƒãƒ¼ãƒˆé–‹å§‹:", file.name);
                const reader = new FileReader();

                reader.onload = async (event) => {
                    const textContent = event.target.result;
                    if (!textContent) {
                        await uiUtils.showCustomAlert("ãƒ•ã‚¡ã‚¤ãƒ«ã®å†…å®¹ãŒç©ºã§ã™ã€‚");
                        return;
                    }
                    try {
                        const { messages: importedMessages, systemPrompt: importedSystemPrompt } = this.parseImportedHistory(textContent);
                        if (importedMessages.length === 0 && !importedSystemPrompt) {
                            await uiUtils.showCustomAlert("ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰æœ‰åŠ¹ãªãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¾ãŸã¯ã‚·ã‚¹ãƒ†ãƒ ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’èª­ã¿è¾¼ã‚ã¾ã›ã‚“ã§ã—ãŸã€‚å½¢å¼ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚");
                            return;
                        }

                        let currentGroupId = null;
                        let lastUserIndex = -1;
                        for (let i = 0; i < importedMessages.length; i++) {
                            const msg = importedMessages[i];
                            if (msg.role === 'user') {
                                lastUserIndex = i;
                                currentGroupId = null;
                            } else if (msg.role === 'model' && msg.isCascaded) {
                                if (currentGroupId === null && lastUserIndex !== -1) {
                                    currentGroupId = `imp-${Date.now()}-${Math.random().toString(36).substring(2, 8)}`;
                                }
                                if (currentGroupId) {
                                    msg.siblingGroupId = currentGroupId;
                                }
                            } else {
                                currentGroupId = null;
                            }
                        }
                        const groupIds = new Set(importedMessages.filter(m => m.siblingGroupId).map(m => m.siblingGroupId));
                        groupIds.forEach(gid => {
                            const siblings = importedMessages.filter(m => m.siblingGroupId === gid);
                            const selected = siblings.filter(m => m.isSelected);
                            if (selected.length === 0 && siblings.length > 0) {
                                siblings[siblings.length - 1].isSelected = true;
                            } else if (selected.length > 1) {
                                selected.slice(0, -1).forEach(m => m.isSelected = false);
                            }
                        });

                        const fileNameWithoutExt = file.name.replace(/\.[^/.]+$/, "");
                        const newTitle = IMPORT_PREFIX + (fileNameWithoutExt || `Imported_${Date.now()}`);

                        const newChatData = {
                            messages: importedMessages,
                            systemPrompt: importedSystemPrompt || '',
                            updatedAt: Date.now(),
                            createdAt: Date.now(),
                            title: newTitle.substring(0, 100)
                        };

                        const newChatId = await new Promise((resolve, reject) => {
                            const store = dbUtils._getStore(CHATS_STORE, 'readwrite');
                            const request = store.add(newChatData);
                            request.onsuccess = (event) => resolve(event.target.result);
                            request.onerror = (event) => reject(event.target.error);
                        });

                        console.log("å±¥æ­´ã‚¤ãƒ³ãƒãƒ¼ãƒˆæˆåŠŸ:", newChatId);
                        await uiUtils.showCustomAlert(`å±¥æ­´ã€Œ${newChatData.title}ã€ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¾ã—ãŸã€‚`);
                        uiUtils.renderHistoryList();

                    } catch (error) {
                        console.error("å±¥æ­´ã‚¤ãƒ³ãƒãƒ¼ãƒˆå‡¦ç†ã‚¨ãƒ©ãƒ¼:", error);
                        await uiUtils.showCustomAlert(`å±¥æ­´ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: ${error.message}`);
                    }
                };

                reader.onerror = async (event) => {
                    console.error("ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:", event.target.error);
                    await uiUtils.showCustomAlert("ãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚");
                };

                reader.readAsText(file);
            },

            parseImportedHistory(text) {
                const messages = [];
                let systemPrompt = '';
                const blockRegex = /<\|#\|(system|user|model)\|#\|([^>]*)>([\s\S]*?)<\|#\|\/\1\|#\|>/g;
                let match;

                while ((match = blockRegex.exec(text)) !== null) {
                    const role = match[1];
                    const attributesString = match[2].trim();
                    const content = match[3].trim();

                    if (role === 'system' && content) {
                        systemPrompt = content;
                    } else if ((role === 'user' || role === 'model') && (content || attributesString.includes('attachments'))) {
                        const messageData = {
                            role: role,
                            content: content,
                            timestamp: Date.now(),
                            attachments: []
                        };
                        const attributes = {};
                        attributesString.split(/\s+/).forEach(attr => {
                            const eqIndex = attr.indexOf('=');
                            if (eqIndex > 0) {
                                const key = attr.substring(0, eqIndex);
                                let value = attr.substring(eqIndex + 1);
                                if (value.startsWith('"') && value.endsWith('"')) {
                                    value = value.substring(1, value.length - 1);
                                }
                                attributes[key] = value.replace(/&quot;/g, '"');
                            } else if (attr) {
                                attributes[attr] = true;
                            }
                        });

                        if (role === 'model') {
                            messageData.isCascaded = attributes['isCascaded'] === true;
                            messageData.isSelected = attributes['isSelected'] === true;
                        }
                        if (role === 'user' && attributes['attachments']) {
                            const fileNames = attributes['attachments'].split(';');
                            messageData.attachments = fileNames.map(name => ({
                                name: name,
                                mimeType: 'unknown/unknown',
                                base64Data: ''
                            }));
                        }
                        
                        messages.push(messageData);
                    }
                }
                console.log(`ã‚¤ãƒ³ãƒãƒ¼ãƒˆãƒ†ã‚­ã‚¹ãƒˆã‹ã‚‰ ${messages.length} ä»¶ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¨ã‚·ã‚¹ãƒ†ãƒ ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ(${systemPrompt ? 'ã‚ã‚Š' : 'ãªã—'})ã‚’ãƒ‘ãƒ¼ã‚¹ã—ã¾ã—ãŸã€‚`);
                return { messages, systemPrompt };
            },

             async handleBackgroundImageUpload(file) {
                 console.log("é¸æŠžã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«:", file.name, file.type, file.size);
                 const maxSize = 5 * 1024 * 1024;
                 if (file.size > maxSize) {
                     await uiUtils.showCustomAlert(`ç”»åƒã‚µã‚¤ã‚ºãŒå¤§ãã™ãŽã¾ã™ (${(maxSize / 1024 / 1024).toFixed(1)}MBä»¥ä¸‹ã«ã—ã¦ãã ã•ã„)`);
                     return;
                 }
                 if (!file.type.startsWith('image/')) {
                     await uiUtils.showCustomAlert("ç”»åƒãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠžã—ã¦ãã ã•ã„ (JPEG, PNG, GIF, WebPãªã©)");
                     return;
                 }
                 try {
                     uiUtils.revokeExistingObjectUrl();
                     const blob = file;
                     await dbUtils.saveSetting('backgroundImageBlob', blob);
                     state.settings.backgroundImageBlob = blob;
                     state.backgroundImageUrl = URL.createObjectURL(blob);
                     document.documentElement.style.setProperty('--chat-background-image', `url(${state.backgroundImageUrl})`);
                     uiUtils.updateBackgroundSettingsUI();
                     console.log("èƒŒæ™¯ç”»åƒã‚’æ›´æ–°ã—ã¾ã—ãŸã€‚");
                 } catch (error) {
                     console.error("èƒŒæ™¯ç”»åƒã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰å‡¦ç†ã‚¨ãƒ©ãƒ¼:", error);
                     await uiUtils.showCustomAlert(`èƒŒæ™¯ç”»åƒã®å‡¦ç†ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: ${error}`);
                     uiUtils.revokeExistingObjectUrl();
                     document.documentElement.style.setProperty('--chat-background-image', 'none');
                     state.settings.backgroundImageBlob = null;
                     uiUtils.updateBackgroundSettingsUI();
                 }
             },
             async confirmDeleteBackgroundImage() {
                 const confirmed = await uiUtils.showCustomConfirm("èƒŒæ™¯ç”»åƒã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ");
                 if (confirmed) {
                     await this.handleBackgroundImageDelete();
                 }
             },
             async handleBackgroundImageDelete() {
                 try {
                     uiUtils.revokeExistingObjectUrl();
                     await dbUtils.saveSetting('backgroundImageBlob', null);
                     state.settings.backgroundImageBlob = null;
                     document.documentElement.style.setProperty('--chat-background-image', 'none');
                     uiUtils.updateBackgroundSettingsUI();
                     console.log("èƒŒæ™¯ç”»åƒã‚’å‰Šé™¤ã—ã¾ã—ãŸã€‚");
                 } catch (error) {
                     console.error("èƒŒæ™¯ç”»åƒå‰Šé™¤ã‚¨ãƒ©ãƒ¼:", error);
                     await uiUtils.showCustomAlert(`èƒŒæ™¯ç”»åƒã®å‰Šé™¤ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: ${error}`);
                 }
             },

            async saveSettings() {
                 const newSettings = {
                     apiKey: elements.apiKeyInput.value.trim(),
                     modelName: elements.modelNameSelect.value,
                     streamingOutput: elements.streamingOutputCheckbox.checked,
                     streamingSpeed: elements.streamingSpeedInput.value === '' ? DEFAULT_STREAMING_SPEED : parseInt(elements.streamingSpeedInput.value),
                     systemPrompt: elements.systemPromptDefaultTextarea.value.trim(),
                     temperature: elements.temperatureInput.value === '' ? null : parseFloat(elements.temperatureInput.value),
                     maxTokens: elements.maxTokensInput.value === '' ? null : parseInt(elements.maxTokensInput.value),
                     topK: elements.topKInput.value === '' ? null : parseInt(elements.topKInput.value),
                     topP: elements.topPInput.value === '' ? null : parseFloat(elements.topPInput.value),
                     presencePenalty: elements.presencePenaltyInput.value === '' ? null : parseFloat(elements.presencePenaltyInput.value),
                     frequencyPenalty: elements.frequencyPenaltyInput.value === '' ? null : parseFloat(elements.frequencyPenaltyInput.value),
                     thinkingBudget: elements.thinkingBudgetInput.value === '' ? null : parseInt(elements.thinkingBudgetInput.value, 10),
                     includeThoughts: elements.includeThoughtsToggle.checked,
                     dummyUser: elements.dummyUserInput.value.trim(),
                     dummyModel: elements.dummyModelInput.value.trim(),
                     concatDummyModel: elements.concatDummyModelCheckbox.checked,
                     additionalModels: elements.additionalModelsTextarea.value.trim(),
                     pseudoStreaming: elements.pseudoStreamingCheckbox.checked,
                     enterToSend: elements.enterToSendCheckbox.checked,
                     historySortOrder: elements.historySortOrderSelect.value,
                     darkMode: elements.darkModeToggle.checked,
                     fontFamily: elements.fontFamilyInput.value.trim(),
                     hideSystemPromptInChat: elements.hideSystemPromptToggle.checked,
                     enableGrounding: elements.enableGroundingToggle.checked,
                     enableSwipeNavigation: elements.swipeNavigationToggle.checked,
                 };

                 if (isNaN(newSettings.streamingSpeed) || newSettings.streamingSpeed < 0) {
                     newSettings.streamingSpeed = DEFAULT_STREAMING_SPEED;
                 }
                 if (newSettings.temperature !== null && (isNaN(newSettings.temperature) || newSettings.temperature < 0 || newSettings.temperature > 2)) {
                     newSettings.temperature = null;
                 }
                 if (newSettings.maxTokens !== null && (isNaN(newSettings.maxTokens) || newSettings.maxTokens < 1)) {
                     newSettings.maxTokens = null;
                 }
                 if (newSettings.topK !== null && (isNaN(newSettings.topK) || newSettings.topK < 1)) {
                     newSettings.topK = null;
                 }
                 if (newSettings.topP !== null && (isNaN(newSettings.topP) || newSettings.topP < 0 || newSettings.topP > 1)) {
                     newSettings.topP = null;
                 }
                 if (newSettings.presencePenalty !== null && (isNaN(newSettings.presencePenalty) || newSettings.presencePenalty < -2.0 || newSettings.presencePenalty >= 2.0)) {
                     newSettings.presencePenalty = null;
                 }
                 if (newSettings.frequencyPenalty !== null && (isNaN(newSettings.frequencyPenalty) || newSettings.frequencyPenalty < -2.0 || newSettings.frequencyPenalty >= 2.0)) {
                     newSettings.frequencyPenalty = null;
                 }
                 if (newSettings.thinkingBudget !== null && (isNaN(newSettings.thinkingBudget) || newSettings.thinkingBudget < 0 || !Number.isInteger(newSettings.thinkingBudget))) {
                     newSettings.thinkingBudget = null;
                 }

                 try {
                     const oldSortOrder = state.settings.historySortOrder;

                     const promises = Object.entries(newSettings).map(([key, value]) =>
                         dbUtils.saveSetting(key, value)
                     );
                     await Promise.all(promises);

                     state.settings = { ...state.settings, ...newSettings };

                     uiUtils.applySettingsToUI();

                     console.log("è¨­å®šä¿å­˜æˆåŠŸ:", { ...state.settings, backgroundImageBlob: state.settings.backgroundImageBlob ? '[Blob]' : null });
                     await uiUtils.showCustomAlert("è¨­å®šã‚’ä¿å­˜ã—ã¾ã—ãŸã€‚");

                     if (newSettings.historySortOrder !== oldSortOrder && state.currentScreen === 'history') {
                         uiUtils.renderHistoryList();
                     }
                 } catch (error) {
                     await uiUtils.showCustomAlert(`è¨­å®šã®ä¿å­˜ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: ${error}`);
                 }
            },

            async updateApp() {
                if (!navigator.serviceWorker || !navigator.serviceWorker.controller) {
                    await uiUtils.showCustomAlert("Service WorkerãŒæ¤œå‡ºã•ã‚Œã¾ã›ã‚“ã§ã—ãŸã€‚ãƒšãƒ¼ã‚¸ã‚’ãƒªãƒ­ãƒ¼ãƒ‰ã—ã¦ã‹ã‚‰å†è©¦è¡Œã—ã¦ãã ã•ã„ã€‚");
                    return;
                }
                const confirmed = await uiUtils.showCustomConfirm("ã‚¢ãƒ—ãƒªã®ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ã‚¯ãƒªã‚¢ã—ã¦æœ€æ–°ç‰ˆã‚’å†å–å¾—ã—ã¾ã™ã‹ï¼Ÿ (ãƒšãƒ¼ã‚¸ãŒãƒªãƒ­ãƒ¼ãƒ‰ã•ã‚Œã¾ã™)");
                if (confirmed) {
                    navigator.serviceWorker.ready.then(reg => {
                        if (reg.active) {
                            reg.active.postMessage({ action: 'clearCache' });
                        } else {
                            uiUtils.showCustomAlert("ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªService WorkerãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚æ‰‹å‹•ã§ãƒªãƒ­ãƒ¼ãƒ‰ãŒå¿…è¦ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚");
                        }
                    }).catch(async err => {
                        await uiUtils.showCustomAlert("Service Workerã®æº–å‚™ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚");
                    });
                }
            },

            async confirmClearAllData() {
                const confirmed = await uiUtils.showCustomConfirm("æœ¬å½“ã«ã™ã¹ã¦ã®ãƒ‡ãƒ¼ã‚¿ï¼ˆãƒãƒ£ãƒƒãƒˆå±¥æ­´ã¨è¨­å®šï¼‰ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿã“ã®æ“ä½œã¯å…ƒã«æˆ»ã›ã¾ã›ã‚“ã€‚");
                if (confirmed) {
                    try {
                        uiUtils.revokeExistingObjectUrl();
                        await dbUtils.clearAllData();
                        await uiUtils.showCustomAlert("ã™ã¹ã¦ã®ãƒ‡ãƒ¼ã‚¿ãŒå‰Šé™¤ã•ã‚Œã¾ã—ãŸã€‚ã‚¢ãƒ—ãƒªã‚’ãƒªã‚»ãƒƒãƒˆã—ã¾ã™ã€‚");

                        state.currentChatId = null;
                        state.currentMessages = [];
                        state.currentSystemPrompt = '';
                        state.pendingAttachments = [];
                        state.settings = {
                            apiKey: '',
                            modelName: DEFAULT_MODEL,
                            streamingOutput: true,
                            streamingSpeed: DEFAULT_STREAMING_SPEED,
                            systemPrompt: '',
                            temperature: null,
                            maxTokens: null,
                            topK: null,
                            topP: null,
                            presencePenalty: null,
                            frequencyPenalty: null,
                            thinkingBudget: null,
                            dummyUser: '',
                            dummyModel: '',
                            concatDummyModel: false,
                            additionalModels: '',
                            pseudoStreaming: false,
                            enterToSend: true,
                            historySortOrder: 'updatedAt',
                            darkMode: window.matchMedia?.('(prefers-color-scheme: dark)').matches ?? false,
                            backgroundImageBlob: null,
                            fontFamily: '',
                            hideSystemPromptInChat: false,
                            enableSwipeNavigation: true,
                        };
                        state.backgroundImageUrl = null;

                        document.documentElement.style.setProperty('--chat-background-image', 'none');
                        uiUtils.applySettingsToUI();
                        uiUtils.updateAttachmentBadgeVisibility();
                        this.startNewChat();
                        uiUtils.showScreen('chat', true);
                    } catch (error) {
                        await uiUtils.showCustomAlert(`ãƒ‡ãƒ¼ã‚¿å‰Šé™¤ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: ${error}`);
                    }
                }
            },

            startEditSystemPrompt() {
                if (state.isSending) return;
                state.isEditingSystemPrompt = true;
                elements.systemPromptEditor.value = state.currentSystemPrompt;
                uiUtils.adjustTextareaHeight(elements.systemPromptEditor, 200);
                elements.systemPromptEditor.focus();
                console.log("ã‚·ã‚¹ãƒ†ãƒ ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆç·¨é›†é–‹å§‹");
            },
            async saveCurrentSystemPrompt() {
                const newPrompt = elements.systemPromptEditor.value.trim();
                if (newPrompt !== state.currentSystemPrompt) {
                    state.currentSystemPrompt = newPrompt;
                    try {
                        await dbUtils.saveChat();
                        console.log("ã‚·ã‚¹ãƒ†ãƒ ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆä¿å­˜å®Œäº†");
                    } catch (error) {
                        await uiUtils.showCustomAlert("ã‚·ã‚¹ãƒ†ãƒ ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã®ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸã€‚");
                    }
                }
                state.isEditingSystemPrompt = false;
                elements.systemPromptDetails.removeAttribute('open');
            },
            cancelEditSystemPrompt() {
                state.isEditingSystemPrompt = false;
                elements.systemPromptEditor.value = state.currentSystemPrompt;
                elements.systemPromptDetails.removeAttribute('open');
                uiUtils.adjustTextareaHeight(elements.systemPromptEditor, 200);
                console.log("ã‚·ã‚¹ãƒ†ãƒ ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆç·¨é›†ã‚­ãƒ£ãƒ³ã‚»ãƒ«");
            },

            async startEditMessage(index, messageElement) {
                 if (state.isSending) {
                     await uiUtils.showCustomAlert("é€ä¿¡ä¸­ã¯ç·¨é›†ã§ãã¾ã›ã‚“ã€‚");
                     return;
                 }
                 if (state.editingMessageIndex !== null && state.editingMessageIndex !== index) {
                     await uiUtils.showCustomAlert("ä»–ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ç·¨é›†ä¸­ã§ã™ã€‚");
                     return;
                 }
                 if (state.isEditingSystemPrompt) {
                     await uiUtils.showCustomAlert("ã‚·ã‚¹ãƒ†ãƒ ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’ç·¨é›†ä¸­ã§ã™ã€‚");
                     return;
                 }
                 if (state.editingMessageIndex === index) {
                     messageElement.querySelector('.edit-textarea')?.focus();
                     return;
                 }

                 const message = state.currentMessages[index];
                 if (!message) return;

                 const rawContent = message.content;
                 state.editingMessageIndex = index;

                 const contentDiv = messageElement.querySelector('.message-content');
                 const editArea = messageElement.querySelector('.message-edit-area');
                 const cascadeControls = messageElement.querySelector('.message-cascade-controls');
                 editArea.innerHTML = '';

                 let horizontalPadding = 0;
                 try {
                     const computedStyle = window.getComputedStyle(messageElement);
                     const paddingLeft = parseFloat(computedStyle.paddingLeft) || 0;
                     const paddingRight = parseFloat(computedStyle.paddingRight) || 0;
                     horizontalPadding = paddingLeft + paddingRight;
                 } catch (e) {
                     console.error("å¹…ã®å‹•çš„è¨ˆç®—ä¸­ã«ã‚¨ãƒ©ãƒ¼:", e);
                 }
                 messageElement.style.width = `calc(var(--message-max-width) + ${horizontalPadding}px + 17px)`;

                 const textarea = document.createElement('textarea');
                 textarea.value = rawContent;
                 textarea.classList.add('edit-textarea');
                 textarea.rows = 3;
                 textarea.oninput = () => uiUtils.adjustTextareaHeight(textarea, 400);

                 const actionsDiv = document.createElement('div');
                 actionsDiv.classList.add('message-edit-actions');

                 const saveButton = document.createElement('button');
                 saveButton.textContent = 'ä¿å­˜';
                 saveButton.classList.add('save-edit-btn');
                 saveButton.onclick = () => this.saveEditMessage(index, messageElement);

                 const cancelButton = document.createElement('button');
                 cancelButton.textContent = 'ã‚­ãƒ£ãƒ³ã‚»ãƒ«';
                 cancelButton.classList.add('cancel-edit-btn');
                 cancelButton.onclick = () => this.cancelEditMessage(index, messageElement);

                 actionsDiv.appendChild(saveButton);
                 actionsDiv.appendChild(cancelButton);
                 editArea.appendChild(textarea);
                 editArea.appendChild(actionsDiv);

                 messageElement.classList.add('editing');
                 if(contentDiv) contentDiv.classList.add('hidden');
                 if(cascadeControls) cascadeControls.classList.add('hidden');
                 editArea.classList.remove('hidden');

                 uiUtils.adjustTextareaHeight(textarea, 400);
                 textarea.focus();
                 textarea.select();
            },

            async saveEditMessage(index, messageElement) {
                const textarea = messageElement.querySelector('.edit-textarea');
                if (!textarea) {
                    this.cancelEditMessage(index, messageElement);
                    return;
                }
                const newRawContent = textarea.value.trim();
                const originalMessage = state.currentMessages[index];

                if (newRawContent === originalMessage.content) {
                    this.cancelEditMessage(index, messageElement);
                    return;
                }

                originalMessage.content = newRawContent;
                originalMessage.timestamp = Date.now();
                delete originalMessage.error;

                const contentDiv = messageElement.querySelector('.message-content');
                if(contentDiv && typeof marked !== 'undefined' && originalMessage.role === 'model') {
                    try {
                        contentDiv.innerHTML = marked.parse(newRawContent || '');
                    } catch (e) {
                        console.error("ç·¨é›†ä¿å­˜æ™‚ã®Markdownãƒ‘ãƒ¼ã‚¹ã‚¨ãƒ©ãƒ¼:", e);
                        contentDiv.textContent = newRawContent;
                    }
                } else if (contentDiv) {
                    const pre = contentDiv.querySelector('pre') || document.createElement('pre');
                    pre.textContent = newRawContent;
                    if(!contentDiv.querySelector('pre')) {
                        contentDiv.innerHTML = '';
                        contentDiv.appendChild(pre);
                    }
                }

                this.finishEditing(messageElement);

                let requiresTitleUpdate = (index === state.currentMessages.findIndex(m => m.role === 'user'));
                try {
                    let newTitleForSave = null;
                    if (requiresTitleUpdate) {
                        newTitleForSave = newRawContent.substring(0, 50) || "ç„¡é¡Œã®ãƒãƒ£ãƒƒãƒˆ";
                    }
                    await dbUtils.saveChat(newTitleForSave);
                    if (requiresTitleUpdate) {
                        uiUtils.updateChatTitle(newTitleForSave);
                    }
                    console.log("ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ç·¨é›†å¾Œã«ãƒãƒ£ãƒƒãƒˆä¿å­˜:", index);
                } catch (error) {
                    await uiUtils.showCustomAlert("ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ç·¨é›†å¾Œã®ãƒãƒ£ãƒƒãƒˆä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸã€‚");
                }
            },
            cancelEditMessage(index, messageElement = null) {
                  if (!messageElement) {
                      messageElement = elements.messageContainer.querySelector(`.message[data-index="${index}"]`);
                  }
                  if (messageElement) {
                      this.finishEditing(messageElement);
                  } else if (state.editingMessageIndex === index) {
                      state.editingMessageIndex = null;
                      console.log("ç·¨é›†ã‚­ãƒ£ãƒ³ã‚»ãƒ«: è¦ç´ ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸãŒã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’ãƒªã‚»ãƒƒãƒˆ:", index);
                  }
            },
            finishEditing(messageElement) {
                if (!messageElement) return;
                const editArea = messageElement.querySelector('.message-edit-area');
                const contentDiv = messageElement.querySelector('.message-content');
                const cascadeControls = messageElement.querySelector('.message-cascade-controls');
                const textarea = messageElement.querySelector('.edit-textarea');

                messageElement.style.removeProperty('width');

                messageElement.classList.remove('editing');
                if(contentDiv) contentDiv.classList.remove('hidden');
                if(cascadeControls) cascadeControls.classList.remove('hidden');
                if(editArea) {
                    editArea.classList.add('hidden');
                    editArea.innerHTML = '';
                }

                const index = parseInt(messageElement.dataset.index, 10);
                if (state.editingMessageIndex === index) {
                    state.editingMessageIndex = null;
                    console.log("ç·¨é›†çµ‚äº†:", index);
                }
            },

            async deleteMessage(index) {
                if (state.editingMessageIndex === index) {
                    this.cancelEditMessage(index);
                }
                if (state.isSending) {
                    await uiUtils.showCustomAlert("é€ä¿¡ä¸­ã¯å‰Šé™¤ã§ãã¾ã›ã‚“ã€‚");
                    return;
                }
                if (state.isEditingSystemPrompt) {
                    await uiUtils.showCustomAlert("ã‚·ã‚¹ãƒ†ãƒ ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆç·¨é›†ä¸­ã¯å‰Šé™¤ã§ãã¾ã›ã‚“ã€‚");
                    return;
                }
                if (index < 0 || index >= state.currentMessages.length) {
                     console.error("å‰Šé™¤å¯¾è±¡ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãŒç„¡åŠ¹:", index);
                     return;
                }

                const messageToDelete = state.currentMessages[index];
                const messageContentPreview = messageToDelete.content.substring(0, 30) + "...";
                let confirmMessage = "";
                let deleteTargetDescription = "";
                let indicesToDelete = [];

                if (messageToDelete.role === 'model' && messageToDelete.isCascaded && messageToDelete.siblingGroupId) {
                    const groupId = messageToDelete.siblingGroupId;
                    const siblings = state.currentMessages.filter(msg => msg.role === 'model' && msg.isCascaded && msg.siblingGroupId === groupId);
                    indicesToDelete = state.currentMessages
                        .map((msg, i) => (msg.role === 'model' && msg.isCascaded && msg.siblingGroupId === groupId) ? i : -1)
                        .filter(i => i !== -1);

                    confirmMessage = `ã€Œ${messageContentPreview}ã€ã‚’å«ã‚€å¿œç­”ã‚°ãƒ«ãƒ¼ãƒ—å…¨ä½“ (${siblings.length}ä»¶) ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ`;
                    deleteTargetDescription = `ã‚«ã‚¹ã‚±ãƒ¼ãƒ‰ã‚°ãƒ«ãƒ¼ãƒ— (gid: ${groupId}, ${indicesToDelete.length}ä»¶)`;
                } else {
                    indicesToDelete.push(index);
                    confirmMessage = `ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã€Œ${messageContentPreview}ã€(${messageToDelete.role}) ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ`;
                    deleteTargetDescription = `å˜ä¸€ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ (index: ${index}, role: ${messageToDelete.role})`;
                }

                const confirmed = await uiUtils.showCustomConfirm(confirmMessage);
                if (confirmed) {
                    console.log(`å‰Šé™¤å®Ÿè¡Œ: ${deleteTargetDescription}`);
                    const originalFirstUserMsgIndex = state.currentMessages.findIndex(m => m.role === 'user');

                    indicesToDelete.sort((a, b) => b - a).forEach(idx => {
                        state.currentMessages.splice(idx, 1);
                    });
                    console.log(`ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å‰Šé™¤å®Œäº† (state)ã€‚å‰Šé™¤ä»¶æ•°: ${indicesToDelete.length}`);

                    uiUtils.renderChatMessages();

                    const newFirstUserMsgIndex = state.currentMessages.findIndex(m => m.role === 'user');
                    let requiresTitleUpdate = indicesToDelete.includes(originalFirstUserMsgIndex);

                    try {
                        let newTitleForSave = null;
                        const currentChatData = state.currentChatId ? await dbUtils.getChat(state.currentChatId) : null;

                        if (requiresTitleUpdate) {
                            const newFirstUserMessage = newFirstUserMsgIndex !== -1 ? state.currentMessages[newFirstUserMsgIndex] : null;
                            newTitleForSave = newFirstUserMessage ? newFirstUserMessage.content.substring(0, 50) : "ç„¡é¡Œã®ãƒãƒ£ãƒƒãƒˆ";
                        } else if (currentChatData) {
                            newTitleForSave = currentChatData.title;
                        }

                        await dbUtils.saveChat(newTitleForSave);

                        if (requiresTitleUpdate) {
                            uiUtils.updateChatTitle(newTitleForSave);
                        }

                        if (state.currentMessages.length === 0 && !state.currentSystemPrompt && state.currentChatId) {
                            console.log("ãƒãƒ£ãƒƒãƒˆãŒç©ºã«ãªã£ãŸãŸã‚ãƒªã‚»ãƒƒãƒˆã—ã¾ã™ã€‚");
                            this.startNewChat();
                        }
                    } catch (error) {
                        console.error("ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å‰Šé™¤å¾Œã®ãƒãƒ£ãƒƒãƒˆä¿å­˜/å–å¾—ã‚¨ãƒ©ãƒ¼:", error);
                        await uiUtils.showCustomAlert("ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å‰Šé™¤å¾Œã®ãƒãƒ£ãƒƒãƒˆä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸã€‚");
                    }
                } else {
                     console.log("å‰Šé™¤ã‚­ãƒ£ãƒ³ã‚»ãƒ«");
                }
            },

            
            async retryFromMessage(index) {
                if (state.editingMessageIndex !== null) {
                    await uiUtils.showCustomAlert("ç·¨é›†ä¸­ã¯ãƒªãƒˆãƒ©ã‚¤ã§ãã¾ã›ã‚“ã€‚");
                    return;
                }
                if (state.isSending) {
                    await uiUtils.showCustomAlert("é€ä¿¡ä¸­ã§ã™ã€‚");
                    return;
                }
                if (state.isEditingSystemPrompt) {
                    await uiUtils.showCustomAlert("ã‚·ã‚¹ãƒ†ãƒ ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆç·¨é›†ä¸­ã¯ãƒªãƒˆãƒ©ã‚¤ã§ãã¾ã›ã‚“ã€‚");
                    return;
                }
                const userMessage = state.currentMessages[index];
                if (!userMessage || userMessage.role !== 'user') return;

                const messageContentPreview = userMessage.content.substring(0, 30) + "...";
                const attachmentInfo = (userMessage.attachments && userMessage.attachments.length > 0)
                    ? ` (${userMessage.attachments.length}ä»¶ã®æ·»ä»˜ãƒ•ã‚¡ã‚¤ãƒ«å«ã‚€)`
                    : '';
                const confirmed = await uiUtils.showCustomConfirm(`ã€Œ${messageContentPreview}ã€ã‹ã‚‰å†ç”Ÿæˆã—ã¾ã™ã‹ï¼Ÿ\n(ã“ã®å…¥åŠ›ã«å¯¾ã™ã‚‹æ—¢å­˜ã®å¿œç­”ã¯ä¿æŒã•ã‚Œã¾ã™ãŒã€**ã“ã‚Œã‚ˆã‚Šæœªæ¥ã®ä¼šè©±å±¥æ­´ã¯å‰Šé™¤ã•ã‚Œã¾ã™**)`);

                if (confirmed) {
                    console.log(`ãƒªãƒˆãƒ©ã‚¤é–‹å§‹: index=${index}`);

                    let deleteStartIndex = -1;
                    let scanIndex = index + 1;

                    let targetSiblingGroupId = null;
                    if (scanIndex < state.currentMessages.length && state.currentMessages[scanIndex].role === 'model') {
                        targetSiblingGroupId = state.currentMessages[scanIndex].siblingGroupId || null;
                        console.log(`ä¿æŒå¯¾è±¡ã® siblingGroupId: ${targetSiblingGroupId}`);
                    }

                    if (targetSiblingGroupId !== null) {
                        while (
                            scanIndex < state.currentMessages.length &&
                            state.currentMessages[scanIndex].role === 'model' &&
                            state.currentMessages[scanIndex].siblingGroupId === targetSiblingGroupId
                        ) {
                            scanIndex++;
                        }
                    } else {
                         if (scanIndex < state.currentMessages.length && state.currentMessages[scanIndex].role === 'model') {
                            scanIndex++;
                        }
                    }

                    if (scanIndex < state.currentMessages.length) {
                        deleteStartIndex = scanIndex;
                    }

                    if (deleteStartIndex !== -1) {
                        const deletedCount = state.currentMessages.length - deleteStartIndex;
                        console.log(`ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ ${deleteStartIndex} ä»¥é™ã® ${deletedCount} ä»¶ã®å±¥æ­´ã‚’å‰Šé™¤ã—ã¾ã™ã€‚`);
                        state.currentMessages.splice(deleteStartIndex);
                    } else {
                        console.log("å‰Šé™¤å¯¾è±¡ã¨ãªã‚‹æœªæ¥ã®ä¼šè©±å±¥æ­´ã¯ã‚ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚");
                    }

                    uiUtils.renderChatMessages();
                    uiUtils.scrollToBottom();
                    
                    const elementsToHide = [];
                    const messageContainer = elements.messageContainer;

                    if (targetSiblingGroupId) {
                        messageContainer.querySelectorAll(`.message.model[data-index]`).forEach(el => {
                            const msgIndex = parseInt(el.dataset.index, 10);
                            const potentialMsg = state.currentMessages[msgIndex];
                            if (potentialMsg && potentialMsg.role === 'model' && potentialMsg.siblingGroupId === targetSiblingGroupId) {
                                 el.classList.add('retrying-hidden');
                                 elementsToHide.push(el);
                            }
                        });
                         console.log(`${elementsToHide.length}ä»¶ã®æ—¢å­˜å¿œç­” (ã‚°ãƒ«ãƒ¼ãƒ— ${targetSiblingGroupId}) ã‚’ä¸€æ™‚çš„ã«éžè¡¨ç¤ºã«ã—ã¾ã—ãŸã€‚`);
                    } else if (index + 1 < state.currentMessages.length && state.currentMessages[index + 1]?.role === 'model') {
                        const element = messageContainer.querySelector(`.message.model[data-index="${index + 1}"]`);
                        if (element) {
                            element.classList.add('retrying-hidden');
                            elementsToHide.push(element);
                            console.log(`1ä»¶ã®æ—¢å­˜å¿œç­” (éžã‚«ã‚¹ã‚±ãƒ¼ãƒ‰, å‰Šé™¤å¾Œã®index: ${index + 1}) ã‚’ä¸€æ™‚çš„ã«éžè¡¨ç¤ºã«ã—ã¾ã—ãŸã€‚`);
                        }
                    }

                    await this.handleSend(true, index);
                }
            },

            getCascadedSiblings(index, includeSelf = false) {
                const targetMsg = state.currentMessages[index];
                if (!targetMsg || !targetMsg.isCascaded || !targetMsg.siblingGroupId) {
                    return [];
                }
                const groupId = targetMsg.siblingGroupId;
                const siblings = state.currentMessages.filter((msg, i) =>
                    msg.role === 'model' &&
                    msg.isCascaded &&
                    msg.siblingGroupId === groupId &&
                    (includeSelf || i !== index)
                );
                return siblings;
            },

            async navigateCascade(currentIndex, direction) {
                const currentMsg = state.currentMessages[currentIndex];
                if (!currentMsg || !currentMsg.isCascaded || !currentMsg.siblingGroupId) return;

                const groupId = currentMsg.siblingGroupId;
                const siblingsWithIndices = state.currentMessages
                    .map((msg, i) => ({ msg, originalIndex: i }))
                    .filter(item => item.msg.role === 'model' && item.msg.isCascaded && item.msg.siblingGroupId === groupId);

                const currentSiblingIndex = siblingsWithIndices.findIndex(item => item.originalIndex === currentIndex);
                if (currentSiblingIndex === -1) return;

                let targetSiblingIndex = -1;
                if (direction === 'prev' && currentSiblingIndex > 0) {
                    targetSiblingIndex = currentSiblingIndex - 1;
                } else if (direction === 'next' && currentSiblingIndex < siblingsWithIndices.length - 1) {
                    targetSiblingIndex = currentSiblingIndex + 1;
                }

                if (targetSiblingIndex !== -1) {
                    currentMsg.isSelected = false;
                    const newlySelectedMessage = siblingsWithIndices[targetSiblingIndex].msg;
                    newlySelectedMessage.isSelected = true;
                    const newlySelectedIndex = siblingsWithIndices[targetSiblingIndex].originalIndex;

                    console.log(`ã‚«ã‚¹ã‚±ãƒ¼ãƒ‰ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³: ${currentSiblingIndex + 1}/${siblingsWithIndices.length} -> ${targetSiblingIndex + 1}/${siblingsWithIndices.length}`);

                    uiUtils.renderChatMessages();

                    requestAnimationFrame(() => {
                        const newlySelectedElement = elements.messageContainer.querySelector(`.message[data-index="${newlySelectedIndex}"]`);
                        if (newlySelectedElement && !newlySelectedElement.classList.contains('editing')) {
                             const currentlyShown = elements.messageContainer.querySelector('.message.show-actions');
                             if (currentlyShown && currentlyShown !== newlySelectedElement) {
                                 currentlyShown.classList.remove('show-actions');
                             }
                             newlySelectedElement.classList.add('show-actions');
                             console.log(`.show-actions ã‚’å†ä»˜ä¸Ž: index=${newlySelectedIndex}`);
                        }
                    });

                    try {
                        await dbUtils.saveChat();
                    } catch (error) {
                        console.error("ã‚«ã‚¹ã‚±ãƒ¼ãƒ‰ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³å¾Œã®ä¿å­˜å¤±æ•—:", error);
                        await uiUtils.showCustomAlert("å¿œç­”ã®åˆ‡ã‚Šæ›¿ãˆçŠ¶æ…‹ã®ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸã€‚");
                    }
                }
            },

            async confirmDeleteCascadeResponse(indexToDelete) {
                const msgToDelete = state.currentMessages[indexToDelete];
                if (!msgToDelete || msgToDelete.role !== 'model' || !msgToDelete.isCascaded || !msgToDelete.siblingGroupId) {
                    console.warn("confirmDeleteCascadeResponse: å¯¾è±¡ã¯ã‚«ã‚¹ã‚±ãƒ¼ãƒ‰å¿œç­”ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚", indexToDelete);
                    return;
                }
                if (state.editingMessageIndex !== null) { await uiUtils.showCustomAlert("ç·¨é›†ä¸­ã¯å‰Šé™¤ã§ãã¾ã›ã‚“ã€‚"); return; }
                if (state.isSending) { await uiUtils.showCustomAlert("é€ä¿¡ä¸­ã¯å‰Šé™¤ã§ãã¾ã›ã‚“ã€‚"); return; }
                if (state.isEditingSystemPrompt) { await uiUtils.showCustomAlert("ã‚·ã‚¹ãƒ†ãƒ ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆç·¨é›†ä¸­ã¯å‰Šé™¤ã§ãã¾ã›ã‚“ã€‚"); return; }

                const siblings = this.getCascadedSiblings(indexToDelete, true);
                const currentIndexInGroup = siblings.findIndex(m => m === msgToDelete) + 1;
                const totalSiblings = siblings.length;
                const contentPreview = msgToDelete.content.substring(0, 30) + "...";
                const confirmMsg = `ã“ã®å¿œç­” (${currentIndexInGroup}/${totalSiblings})ã€Œ${contentPreview}ã€ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ\n(ã“ã®å¿œç­”ã®ã¿ãŒå‰Šé™¤ã•ã‚Œã¾ã™)`;

                const confirmed = await uiUtils.showCustomConfirm(confirmMsg);
                if (confirmed) {
                    const wasSelected = msgToDelete.isSelected;
                    const groupId = msgToDelete.siblingGroupId;

                    state.currentMessages.splice(indexToDelete, 1);
                    console.log(`ã‚«ã‚¹ã‚±ãƒ¼ãƒ‰å¿œç­”å‰Šé™¤ (å˜ä¸€): index=${indexToDelete}, groupId=${groupId}`);

                    let newlySelectedIndex = -1;
                    const remainingSiblingsWithIndices = state.currentMessages
                        .map((msg, i) => ({ msg, originalIndex: i }))
                        .filter(item => item.msg.role === 'model' && item.msg.isCascaded && item.msg.siblingGroupId === groupId);

                    if (remainingSiblingsWithIndices.length > 0) {
                        if (wasSelected) {
                            const lastSiblingItem = remainingSiblingsWithIndices[remainingSiblingsWithIndices.length - 1];
                            if (!lastSiblingItem.msg.isSelected) {
                                lastSiblingItem.msg.isSelected = true;
                                newlySelectedIndex = lastSiblingItem.originalIndex;
                                console.log(`å‰Šé™¤å¾Œã€æ–°ã—ã„é¸æŠžå¿œç­”ã‚’è¨­å®š (å˜ä¸€ã‚«ã‚¹ã‚±ãƒ¼ãƒ‰): newIndex=${newlySelectedIndex}`);
                            } else {
                                newlySelectedIndex = lastSiblingItem.originalIndex;
                            }
                        } else {
                             const stillSelectedItem = remainingSiblingsWithIndices.find(item => item.msg.isSelected);
                             if (stillSelectedItem) {
                                 newlySelectedIndex = stillSelectedItem.originalIndex;
                             }
                        }
                    } else {
                        console.log(`ã‚°ãƒ«ãƒ¼ãƒ— ${groupId} ã®æœ€å¾Œã®å¿œç­”ãŒå‰Šé™¤ã•ã‚Œã¾ã—ãŸã€‚`);
                    }

                    uiUtils.renderChatMessages();
                    requestAnimationFrame(() => {
                         if (newlySelectedIndex !== -1) {
                             const elementToShowActions = elements.messageContainer.querySelector(`.message[data-index="${newlySelectedIndex}"]`);
                             if (elementToShowActions && !elementToShowActions.classList.contains('editing')) {
                                  const currentlyShown = elements.messageContainer.querySelector('.message.show-actions');
                                  if (currentlyShown && currentlyShown !== elementToShowActions) {
                                      currentlyShown.classList.remove('show-actions');
                                  }
                                  elementToShowActions.classList.add('show-actions');
                                  console.log(`.show-actions ã‚’å†ä»˜ä¸Ž (å˜ä¸€ã‚«ã‚¹ã‚±ãƒ¼ãƒ‰å‰Šé™¤å¾Œ): index=${newlySelectedIndex}`);
                             }
                         }
                    });

                    try {
                        await dbUtils.saveChat();
                    } catch (error) {
                        console.error("å˜ä¸€ã‚«ã‚¹ã‚±ãƒ¼ãƒ‰å¿œç­”å‰Šé™¤å¾Œã®ä¿å­˜å¤±æ•—:", error);
                        await uiUtils.showCustomAlert("å¿œç­”å‰Šé™¤å¾Œã®ãƒãƒ£ãƒƒãƒˆçŠ¶æ…‹ã®ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸã€‚");
                    }
                } else {
                     console.log("å˜ä¸€ã‚«ã‚¹ã‚±ãƒ¼ãƒ‰å¿œç­”ã®å‰Šé™¤ã‚­ãƒ£ãƒ³ã‚»ãƒ«");
                }
            },
            
            async handleFileSelection(fileList) {
                if (!fileList || fileList.length === 0) return;

                const newFiles = Array.from(fileList);
                let currentTotalSize = state.selectedFilesForUpload.reduce((sum, item) => sum + item.file.size, 0);
                let addedCount = 0;
                let skippedCount = 0;
                let sizeError = false;

                elements.selectFilesBtn.disabled = true;
                elements.selectFilesBtn.textContent = 'å‡¦ç†ä¸­...';

                for (const file of newFiles) {
                    if (file.size > MAX_FILE_SIZE) {
                        await uiUtils.showCustomAlert(`ãƒ•ã‚¡ã‚¤ãƒ« "${file.name}" ã¯ã‚µã‚¤ã‚ºãŒå¤§ãã™ãŽã¾ã™ (${formatFileSize(MAX_FILE_SIZE)}ä»¥ä¸‹)ã€‚`);
                        skippedCount++;
                        continue;
                    }
                    if (currentTotalSize + file.size > MAX_TOTAL_ATTACHMENT_SIZE) {
                        sizeError = true;
                        skippedCount++;
                        continue;
                    }

                    if (state.selectedFilesForUpload.some(item => item.file.name === file.name)) {
                        console.log(`ãƒ•ã‚¡ã‚¤ãƒ« "${file.name}" ã¯æ—¢ã«è¿½åŠ ã•ã‚Œã¦ã„ã¾ã™ã€‚ã‚¹ã‚­ãƒƒãƒ—ã—ã¾ã™ã€‚`);
                        skippedCount++;
                        continue;
                    }

                    state.selectedFilesForUpload.push({ file: file });
                    currentTotalSize += file.size;
                    addedCount++;
                }

                elements.selectFilesBtn.disabled = false;
                elements.selectFilesBtn.textContent = 'ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠž';

                if (sizeError) {
                    await uiUtils.showCustomAlert(`åˆè¨ˆãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºã®ä¸Šé™ (${formatFileSize(MAX_TOTAL_ATTACHMENT_SIZE)}) ã‚’è¶…ãˆã‚‹ãŸã‚ã€ä¸€éƒ¨ã®ãƒ•ã‚¡ã‚¤ãƒ«ã¯è¿½åŠ ã•ã‚Œã¾ã›ã‚“ã§ã—ãŸã€‚`);
                }
                if (skippedCount > 0) {
                    console.log(`${skippedCount}å€‹ã®ãƒ•ã‚¡ã‚¤ãƒ«ãŒã‚¹ã‚­ãƒƒãƒ—ã•ã‚Œã¾ã—ãŸï¼ˆã‚µã‚¤ã‚ºè¶…éŽã¾ãŸã¯é‡è¤‡ï¼‰ã€‚`);
                }

                uiUtils.updateSelectedFilesUI();
                console.log(`${addedCount}å€‹ã®ãƒ•ã‚¡ã‚¤ãƒ«ãŒé¸æŠžãƒªã‚¹ãƒˆã«è¿½åŠ ã•ã‚Œã¾ã—ãŸã€‚`);
            },

            removeSelectedFile(indexToRemove) {
                if (indexToRemove >= 0 && indexToRemove < state.selectedFilesForUpload.length) {
                    const removedFile = state.selectedFilesForUpload.splice(indexToRemove, 1)[0];
                    console.log(`ãƒ•ã‚¡ã‚¤ãƒ« "${removedFile.file.name}" ã‚’ãƒªã‚¹ãƒˆã‹ã‚‰å‰Šé™¤ã—ã¾ã—ãŸã€‚`);
                    uiUtils.updateSelectedFilesUI();
                }
            },

            async confirmAttachment() {
                if (state.selectedFilesForUpload.length === 0) {
                    state.pendingAttachments = [];
                    console.log("æ·»ä»˜ãƒ•ã‚¡ã‚¤ãƒ«ãƒªã‚¹ãƒˆãŒç©ºã®çŠ¶æ…‹ã§ç¢ºå®šã•ã‚Œã¾ã—ãŸã€‚é€ä¿¡å¾…ã¡ãƒªã‚¹ãƒˆã‚’ã‚¯ãƒªã‚¢ã—ã¾ã™ã€‚");
                    elements.fileUploadDialog.close('ok');
                    uiUtils.adjustTextareaHeight();
                    uiUtils.updateAttachmentBadgeVisibility();
                    return;
                }

                elements.confirmAttachBtn.disabled = true;
                elements.confirmAttachBtn.textContent = 'å‡¦ç†ä¸­...';

                const attachmentsToAdd = [];
                let encodingError = false;

                for (const item of state.selectedFilesForUpload) {
                    try {
                        const base64Data = await fileToBase64(item.file);
                        let browserMimeType = item.file.type || '';
                        const fileName = item.file.name;
                        const fileExtension = fileName.slice(((fileName.lastIndexOf(".") - 1) >>> 0) + 2).toLowerCase();

                        let guessedMimeType = null;
                        if (fileExtension && extensionToMimeTypeMap[fileExtension]) {
                            guessedMimeType = extensionToMimeTypeMap[fileExtension];
                        }

                        let finalMimeType;
                        if (guessedMimeType) {
                            finalMimeType = guessedMimeType;
                            if (finalMimeType !== browserMimeType) {
                                console.log(`ãƒ•ã‚¡ã‚¤ãƒ« "${fileName}": æ‹¡å¼µå­(.${fileExtension})ã‹ã‚‰MIMEã‚¿ã‚¤ãƒ—ã‚’ "${finalMimeType}" ã«è¨­å®š (ãƒ–ãƒ©ã‚¦ã‚¶æä¾›: ${browserMimeType || 'ç©º'})`);
                            }
                        } else if (browserMimeType) {
                            finalMimeType = browserMimeType;
                            console.log(`ãƒ•ã‚¡ã‚¤ãƒ« "${fileName}": ãƒ–ãƒ©ã‚¦ã‚¶æä¾›ã®MIMEã‚¿ã‚¤ãƒ— "${finalMimeType}" ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚(æ‹¡å¼µå­ã‹ã‚‰ã®æŽ¨æ¸¬ãªã—)`);
                        } else {
                            finalMimeType = 'application/octet-stream';
                            console.warn(`ãƒ•ã‚¡ã‚¤ãƒ« "${fileName}": MIMEã‚¿ã‚¤ãƒ—ä¸æ˜Žã€‚æ‹¡å¼µå­(.${fileExtension})ã«ã‚‚ãƒžãƒƒãƒ”ãƒ³ã‚°ãªã—ã€‚'application/octet-stream' ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚`);
                        }

                        attachmentsToAdd.push({
                            file: item.file,
                            name: fileName,
                            mimeType: finalMimeType,
                            base64Data: base64Data
                        });
                    } catch (error) {
                        console.error(`ãƒ•ã‚¡ã‚¤ãƒ« "${item.file.name}" ã®Base64ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ä¸­ã«ã‚¨ãƒ©ãƒ¼:`, error);
                        encodingError = true;
                        await uiUtils.showCustomAlert(`ãƒ•ã‚¡ã‚¤ãƒ« "${item.file.name}" ã®å‡¦ç†ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚`);
                        break;
                    }
                }

                elements.confirmAttachBtn.disabled = false;
                elements.confirmAttachBtn.textContent = 'æ·»ä»˜ã—ã¦é–‰ã˜ã‚‹';

                if (!encodingError) {
                    state.pendingAttachments = attachmentsToAdd;
                    console.log(`${state.pendingAttachments.length}ä»¶ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ·»ä»˜æº–å‚™å®Œäº†:`, state.pendingAttachments.map(a => `${a.name} (${a.mimeType})`));
                    elements.fileUploadDialog.close('ok');
                    uiUtils.adjustTextareaHeight();
                    uiUtils.updateAttachmentBadgeVisibility();
                }
            },

            cancelAttachment() {
                state.selectedFilesForUpload = [];
                console.log("ãƒ•ã‚¡ã‚¤ãƒ«æ·»ä»˜ã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã—ã¾ã—ãŸã€‚");
                elements.fileUploadDialog.close('cancel');
                uiUtils.updateAttachmentBadgeVisibility();
            },

        };

        appLogic.initializeApp();
    </script>
</body>
</html>
